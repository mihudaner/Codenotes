## 软中断

### 中断描述符表要写入中断控制器么？

> 不需要。中断控制器负责接收和处理硬件中断信号，并将中断请求发送给CPU。==而中断描述符表是CPU内部的一部分==，它包含了中断处理程序的地址和属性，当中断发生时，CPU会根据IDT中的信息跳转到相应的中断处理程序。
>
> 中断控制器（如PIC、APIC）主要是管理中断的优先级、屏蔽和分发中断信号，而中断描述符表则由操作系统在初始化阶段配置好并加载到CPU的相关寄存器中。
>

### 中断控制器怎么利用中断描述符表（IDT）获得地址的

> ChatGPT
>
> 当中断控制器（例如PIC或APIC）接收到硬件中断并将其发送给CPU时，CPU会进行以下步骤来处理该中断并利用中断描述符表（IDT）获得中断处理程序的地址：
>
> 1. **识别中断向量**：中断控制器发送一个中断请求信号给CPU，并提供一个中断向量（Interrupt Vector）。这个中断向量是一个数字，用来标识发生了哪个中断。
> 2. **索引IDT**：CPU使用中断向量作为索引，查找中断描述符表（IDT）中的相应条目。IDT是一个包含256个条目的数组，每个条目描述一个中断或异常的处理程序。
> 3. **获取中断处理程序地址**：每个IDT条目包含中断处理程序的地址（分为高16位和低16位）和其他一些信息（如段选择子、特权级别等）。CPU读取这个地址信息，从而知道该中断对应的中断处理程序的位置。
> 4. **跳转到中断处理程序**：根据IDT条目中的信息，CPU跳转到相应的中断处理程序执行。此时，CPU会保存当前的执行状态，以便中断处理程序完成后能够恢复原来的执行状态。
>
> 以下是一个简化的示例，描述了IDT条目结构（假设为32位模式）：
>
> ```
> c复制代码struct IDTEntry {
>     uint16_t offset_low;  // 中断处理程序地址的低16位
>     uint16_t selector;    // 代码段选择子
>     uint8_t  zero;        // 保留，置为0
>     uint8_t  type_attr;   // 类型和属性
>     uint16_t offset_high; // 中断处理程序地址的高16位
> };
> ```
>
> 假设中断向量是`n`，对应IDT的第`n`个条目，那么CPU通过以下步骤获取中断处理程序的地址：
>
> ```
> c复制代码IDTEntry entry = IDT[n];
> uint32_t handler_address = (entry.offset_high << 16) | entry.offset_low;
> ```
>
> 然后，CPU跳转到`handler_address`处执行中断处理程序。
>
> 



### CPU怎么找到中断描述符表（IDT）的

CPU找到中断描述符表（IDT）的过程是通过一个特殊的寄存器来实现的，这个寄存器叫做中断描述符表寄存器（IDTR）



### 中断描述符表寄存器（IDTR）又是怎么找到的

> ChatGPT
>
> 中断描述符表寄存器（IDTR）是CPU内部的一个特殊寄存器，它的存在和使用是由CPU的硬件设计和体系结构决定的。以下是关于IDTR的详细说明：
>
> 
>
> 总结来说，==IDTR是CPU硬件设计的一部分，始终存在于CPU内部==。操作系统在启动和初始化过程中通过`lidt`指令设置IDTR的值。当中断发生时，CPU自动使用IDTR来查找和访问IDT，从而跳转到正确的中断处理程序。
>
> 
> 
> 以下是详细过程：
> 
> 1. **中断发生**：
>   - 当硬件中断发生时，中断控制器（如PIC或APIC）向CPU发送一个中断请求（IRQ）。
>    - CPU响应中断请求，保存当前的状态，包括程序计数器（EIP/RIP）、标志寄存器（EFLAGS/RFLAGS）等。
>2. **中断向量**：
>    - CPU接收到中断请求后，从中断控制器获取中断向量（一个标识具体中断类型的数字）。
> 3. **查找IDT**：
>    - CPU使用中断向量作为索引，从IDTR（中断描述符表寄存器）中获取IDT的基地址和限制。
>    - 根据中断向量和IDT的基地址，计算出对应的IDT条目的地址。
> 4. **读取IDT条目**：
>       - CPU从IDT中读取对应条目，获取中断处理程序的地址及相关信息。
> 5. **跳转到中断处理程序**：
>    - CPU根据IDT条目中的地址跳转到中断处理程序执行。
> 
> 这一系列操作完全在硬件层面进行，不需要操作系统代码的介入。操作系统的职责是在系统启动时配置和加载IDT（使用`lidt`指令），并为每个中断向量提供适当的中断处理程序。中断发生时，硬件自动处理上下文切换和中断处理程序的调用。
>
> 所以，中断处理的触发和初步处理（查找IDT和跳转到中断处理程序）是由CPU硬件完成的，而具体的中断处理逻辑（中断处理程序的代码）是由操作系统提供和编写的。
>

### 那软中段是怎么实现的

> 软中断（Software Interrupt）是通过软件指令触发的中断，不需要依赖硬件中断控制器。它们常用于操作系统内核与应用程序之间的交互，以及在内核内部进行特定任务。以x86架构为例，软中断主要通过`int`指令实现。
>
> 以下是软中断的实现过程：
>
> ### 1. 软中断指令
>
> 在x86架构上，`int`指令用于触发软中断。指令格式如下：
>
> ```
>assembly
> 复制代码
> int n
> ```
> 
> 其中`n`是中断向量号，它指定了要触发的中断类型。
>
> ### 2. CPU处理软中断的步骤
>
> 当CPU执行`int n`指令时，会执行以下步骤：
>
> 1. **保存上下文**：
>
>    - CPU保存当前的执行状态，包括程序计数器（EIP/RIP）、标志寄存器（EFLAGS/RFLAGS）、段寄存器等。
>
> 2. **查找IDT**：
>
>    - CPU使用中断向量`n`作为索引，从IDTR（中断描述符表寄存器）中获取IDT的基地址和限制。
>   - 计算出对应的IDT条目的地址，例如：`IDT_base + n * 8`（在32位模式下，每个IDT条目占8字节）。
> 
> 3. **读取IDT条目**：
>
>    - CPU从IDT中读取对应条目，获取中断处理程序的地址及相关信息。
>
>    - IDT条目结构如下：
>
>      ```
>     c复制代码struct IDTEntry {
>          uint16_t offset_low;  // 中断处理程序地址的低16位
>          uint16_t selector;    // 代码段选择子
>          uint8_t  zero;        // 保留，置为0
>          uint8_t  type_attr;   // 类型和属性
>          uint16_t offset_high; // 中断处理程序地址的高16位
>      };
>      ```
> 
>    - 计算中断处理程序的地址：`handler_address = (entry.offset_high << 16) | entry.offset_low`
>
> 4. **跳转到中断处理程序**：
>
>    - 根据从IDT条目中读取的地址，CPU跳转到相应的中断处理程序执行。
>
> ### 3. 中断处理程序
>
> 软中断处理程序是操作系统提供的函数，用于处理特定的中断请求。它的职责包括：
>
> - 执行与中断相关的任务，例如系统调用处理、调度、异常处理等。
>- 恢复被中断的任务状态，使得任务可以继续执行。
> 
> ### 4. 返回中断处理程序
>
> 中断处理程序完成后，使用`iret`指令返回到被中断的代码执行。`iret`指令会恢复之前保存的执行状态，包括程序计数器和标志寄存器等。
>
> ### 示例
>
> 以下是一个简单的软中断例子，用于调用中断向量0x80（通常用于Linux系统调用）：
>
> ```
>assembly复制代码section .text
> global _start
> 
> _start:
>     ; 触发0x80软中断
>     mov eax, 1      ; 系统调用号1：sys_exit
>     xor ebx, ebx    ; 返回码0
>     int 0x80        ; 触发0x80中断（Linux系统调用）
> ```
> 
> 这个程序通过触发0x80中断来调用Linux内核的`sys_exit`系统调用。
>
> 总之，软中断通过软件指令触发，中断处理的初始过程（如查找IDT和跳转到中断处理程序）由CPU硬件自动处理，而具体的中断处理逻辑由操作系统提供的中断处理程序实现。
>
> 如果用c++写内核程序怎么触发一个软中断
>
> ChatGPT
>
> 在C++内核程序中，触发软中断通常需要使用内联汇编，因为C++本身并不提供直接触发中断的关键字或函数。以下是一个例子，展示如何在C++内核代码中触发一个软中断：
>
> ### 示例代码
>
> 假设我们要触发中断向量`0x80`，这在Linux系统中通常用于系统调用。以下是一个简单的示例：
>
> ```
>cpp复制代码#include <cstdint>
> 
> extern "C" void trigger_soft_interrupt(uint8_t interrupt_vector) {
>     asm volatile (
>         "int %0"
>         :
>         : "i" (interrupt_vector)
>     );
> }
> 
> int main() {
>     trigger_soft_interrupt
> ```
> 
> 

### 汇编触发软中段的的伪代码

> ChatGPT
>
> 以下是用汇编语言触发软中断的伪代码，并在C++内核程序中使用内联汇编来实现触发软中断的示例。
>
> ### 汇编触发软中断的伪代码
>
> ```
> assembly复制代码; 假设我们要触发中断向量 n
> int n  ; 使用 `int` 指令触发软中断
> ```
>
> ### C++ 内联汇编触发软中断的示例
>
> 以下是如何在C++代码中使用内联汇编来触发一个软中断的示例：
>
> ```
> cpp复制代码#include <cstdint>
> 
> // 函数声明
> extern "C" void trigger_soft_interrupt(uint8_t interrupt_vector);
> 
> extern "C" void trigger_soft_interrupt(uint8_t interrupt_vector) {
>     // 使用内联汇编触发软中断
>     asm volatile (
>         "int %0"          // `int` 指令触发中断
>         :                 // 没有输出操作数
>         : "i" (interrupt_vector)  // 输入操作数，`interrupt_vector` 表示中断向量号
>         : "memory"        // 通知编译器该指令可能会修改内存
>     );
> }
> 
> int main() {
>     // 触发中断向量 0x80 (通常用于系统调用)
>     trigger_soft_interrupt(0x80);
>     return 0;
> }
> ```
>
> ### 解释
>
> 1. **声明函数**：
>
>    ```
>    cpp
>    复制代码
>    extern "C" void trigger_soft_interrupt(uint8_t interrupt_vector);
>    ```
>
> 2. **实现函数**：
>
>    ```
>    cpp复制代码extern "C" void trigger_soft_interrupt(uint8_t interrupt_vector) {
>        asm volatile (
>            "int %0"          // `int` 指令触发中断
>            :                 // 没有输出操作数
>            : "i" (interrupt_vector)  // 输入操作数，`interrupt_vector` 表示中断向量号
>            : "memory"        // 通知编译器该指令可能会修改内存
>        );
>    }
>    ```
>
> 3. **调用函数**：
>
>    ```
>    cpp复制代码int main() {
>        trigger_soft_interrupt(0x80);
>        return 0;
>    }
>    ```
>
> 这个代码示例展示了如何在C++内核程序中使用内联汇编触发一个软中断。通过调用`trigger_soft_interrupt`函数，并传递中断向量号（例如`0x80`），可以触发相应的软中断。这在操作系统内核编程中非常有用，特别是在实现系统调用等功能时。
>

### 不用实现保护现场什么的么？

> 在实际的操作系统内核编程中，触发软中断时确实需要保护和恢复CPU的上下文（现场），但这些操作通常是由中断处理程序（ISR）来完成的，而不是由触发软中断的代码负责。触发软中断的代码只需要简单地发出一个`int`指令即可。
>
> ### 触发软中断的代码（C++内联汇编）
>
> ```
>cpp复制代码#include <cstdint>
> 
>// 函数声明
> extern "C" void trigger_soft_interrupt(uint8_t interrupt_vector);
> 
> extern "C" void trigger_soft_interrupt(uint8_t interrupt_vector) {
>  asm volatile (
>      "int %0"          // `int` 指令触发中断
>      :                 // 没有输出操作数
>      : "i" (interrupt_vector)  // 输入操作数，`interrupt_vector` 表示中断向量号
>         : "memory"        // 通知编译器该指令可能会修改内存
>     );
>    }
>    
>    int main() {
>     // 触发中断向量 0x80 (通常用于系统调用)
>  trigger_soft_interrupt(0x80);
>  return 0;
> }
>    ```
>    
>    ### 中断处理程序（汇编）
> 
> 假设这是你的中断处理程序（ISR），需要保存和恢复CPU上下文。这部分代码通常是用汇编语言编写的，因为它需要直接访问CPU寄存器。
>
> ```
>assembly复制代码global isr_handler
> 
>isr_handler:
>  ; 保存通用寄存器的现场
>  pusha
>  push ds
>  push es
>     push fs
>     push gs
>    
>     ; 加载内核数据段选择子
>     mov ax, 0x10
>     mov ds, ax
>  mov es, ax
>     mov fs, ax
>     mov gs, ax
>    
>     ; 调用实际的中断处理程序（C 函数）
>     call c_isr_handler
>    
>  ; 恢复通用寄存器的现场
>     pop gs
>     pop fs
>  pop es
>     pop ds
>     popa
>    
>     ; 使用 iret 指令返回
>     iret
>    ```
> 
>    ### 实际的中断处理程序（C++）
>    
> 这是你的中断处理程序，它会在中断发生时被调用
>
> ```
>cpp复制代码extern "C" void c_isr_handler() {
>  // 在这里处理中断
> // 例如，处理系统调用，调度任务等
> }
> ```
>    

### 软中断内核线程

> 还有一个区别，硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字==通常为「ksoftirqd/CPU 编号」==，比如 0 号 CPU 对应的软中断内核线程的名字是 ksoftirqd/0，这个软中断内核线程又是起什么作用
>
> 
>
> 你说的区别是准确的。硬中断和软中断在处理方式上确实有所不同，尤其是在Linux内核中，==这两种中断处理机制被清晰地划分为上半部和下半部==。
>
> ### 硬中断（上半部）
>
> 硬中断处理程序（ISR）是由硬件触发的，当硬中断发生时，CPU立即暂停当前正在执行的任务，转而执行ISR。这部分处理程序必须尽可能短小精悍，以确保系统的实时响应性。通常，ISR只负责最基本的和时间紧迫的工作，比如：
>
> - 硬件设备的状态确认。
> - 读取或写入数据缓冲区。
> - 安排需要进一步处理的任务。
>
> 因为硬中断处理程序是在中断上下文中运行的，所以它不能进行任何会阻塞的操作，如等待I/O，分配内存等。
>
> ### 软中断（下半部）
>
> 软中断处理程序负责完成硬中断处理程序未完成的工作，这些工作可以稍微延迟且不需要立即处理。软中断通常以内核线程的方式执行。在Linux内核中，软中断的处理通过软中断内核线程`ksoftirqd`来实现。
>
> ### 软中断内核线程 `ksoftirqd`
>
> 每个CPU对应一个软中断内核线程，名字通常为`ksoftirqd/CPU编号`，例如0号CPU对应的线程为`ksoftirqd/0`。这些线程的主要作用是：
>
> 1. **处理软中断**：`ksoftirqd`线程主要处理被硬中断处理程序或其他内核代码标记的软中断。软中断包括任务队列、网络包处理等需要在稍后执行的任务。
> 2. **延迟处理**：通过将延迟处理的工作移到`ksoftirqd`线程，可以避免在硬中断处理程序中进行复杂的或长时间的处理，从而保持系统的高响应性。
> 3. **内核线程运行**：`ksoftirqd`线程在内核空闲时被调度运行，处理挂起的软中断。它们的优先级通常较低，以避免对正常任务调度造成过多影响。
>
> ### 软中断的工作流程
>
> 1. **硬中断触发**：当硬件设备触发一个硬中断时，CPU调用硬中断处理程序（ISR）。
> 2. **标记软中断**：在ISR中，必要时会标记软中断。例如，网络驱动程序在ISR中接收网络包后，会标记需要处理网络包的软中断。
> 3. **软中断调度**：内核调度器会在适当的时候调度`ksoftirqd`线程来处理标记的软中断。`ksoftirqd`线程会遍历所有挂起的软中断，并依次处理它们。
>
> ### 示例代码
>
> 以下是一个简化的示例，展示硬中断和软中断的基本工作流程：
>
> ```
> c复制代码#include <linux/interrupt.h>
> #include <linux/kernel.h>
> #include <linux/module.h>
> #include <linux/irq.h>
> 
> // 假设硬中断号为 1
> #define HARDIRQ_NUM 1
> 
> // 定义软中断
> void my_softirq_handler(struct softirq_action *action);
> 
> // 定义硬中断处理程序
> irqreturn_t my_isr(int irq, void *dev_id) {
>     // 处理硬中断（上半部）
>     printk(KERN_INFO "Hard IRQ: %d\n", irq);
> 
>     // 标记软中断
>     raise_softirq_irqoff(0);
> 
>     return IRQ_HANDLED;
> }
> 
> // 注册硬中断和软中断
> static int __init my_module_init(void) {
>     // 注册硬中断处理程序
>     if (request_irq(HARDIRQ_NUM, my_isr, IRQF_SHARED, "my_isr", NULL)) {
>         printk(KERN_ERR "Failed to register hard irq\n");
>         return -1;
>     }
> 
>     // 注册软中断处理程序
>     open_softirq(0, my_softirq_handler);
> 
>     return 0;
> }
> 
> // 注销硬中断和软中断
> static void __exit my_module_exit(void) {
>     free_irq(HARDIRQ_NUM, NULL);
> }
> 
> // 软中断处理程序
> void my_softirq_handler(struct softirq_action *action) {
>     printk(KERN_INFO "Soft IRQ handled\n");
> }
> 
> module_init(my_module_init);
> module_exit(my_module_exit);
> 
> MODULE_LICENSE("GPL");
> MODULE_AUTHOR("Example Author");
> MODULE_DESCRIPTION("Example module with hard and soft IRQ handling");
> ```
>
> ### 解释
>
> - **硬中断处理程序**：`my_isr`是硬中断处理程序，当硬中断发生时，它会被调用。`raise_softirq_irqoff`函数用于标记一个软中断，以便稍后由`ksoftirqd`线程处理。
> - **软中断处理程序**：`my_softirq_handler`是软中断处理程序，它会在`ksoftirqd`线程中被调用，处理挂起的软中断任务。
>
> 通过这种方式，硬中断和软中断协调工作，可以确保系统的高效和实时响应能力，同时避免在硬中断处理程序中进行复杂的处理。

## 虚拟地址和分段分页



![image-20240708213840498](.\img\image-20240708213840498.png)



### &取到的地址是虚拟地址还是虚拟地址的偏移？

> 
>
> ![image-20240708220200137](.\img\image-20240708220200137.png)
>
> 在编程时，使用`&`运算符取到的地址是虚拟地址，而不是虚拟地址的偏移。

### 怎么保证不同进程里相同的虚拟地址可以映射到不同的物理地址

> ，这是通过操作系统的虚拟内存管理机制实现的。这种机制使得每个进程拥有独立的地址空间，从而增强了系统的安全性和稳定性。以下是其实现原理：
>
> 虚拟内存管理机制
> 虚拟内存管理机制使用页表（page tables）来管理虚拟地址和物理地址的映射关系。==每个进程都有自己的页表==，记录该进程的虚拟地址到物理地址的映射。这意味着相同的虚拟地址在不同的进程中可以映射到不同的物理地址



> 假设我们有两个进程A和B，它们的页表分别如下：
>
> - **进程A的页表**：
>
> | 虚拟地址 | 物理地址 |
> | -------- | -------- |
> | 0x400000 | 0x100000 |
> | 0x400100 | 0x100100 |
>
> - **进程B的页表**：
>
> | 虚拟地址 | 物理地址 |
> | -------- | -------- |
> | 0x400000 | 0x200000 |
> | 0x400100 | 0x200100 |
>
> 即使进程A和进程B的虚拟地址0x400000相同，它们通过各自的页表映射到不同的物理地址0x100000和0x200000。



> 建立映射时确保不同进程不会映射到同一个物理内存地址，==是通过操作系统的内存管理子系统来实现的==。这个子系统负责分配、追踪和管理所有进程的物理内存。以下是具体机制和步骤：
>
> ### 内存管理子系统
>
> 1. **物理内存管理器**：
>    - 物理内存管理器==维护一个全局的物理内存分配==表，==跟踪每个物理内存块的使用情况==，确保不会将同一物理内存块分配给多个进程。
> 2. **内存分配算法**：
>    - 操作系统使用内存分配算法（如Buddy系统、Slab分配器等）来分配物理内存块。这些算法保证每次分配的物理内存块都是唯一且未被占用的



## malloc和mmap

> 区别**内存管理单元（MMU）**：
>
> - MMU负责将虚拟地址转换为物理地址。它使用当前进程的页表信息来进行地址转换，因此每个进程的地址空间是独立的，不会互相干扰
>
>   



> 1. **高效文件I/O**：
>    - 通过内存映射，文件内容可以直接在内存中操作，避免了多次系统调用带来的开销。
> 2. **进程间通信**：
>    - 共享内存映射允许多个进程共享一块内存区域，实现高效的进程间通信。
> 3. **设备内存访问**：
>    - 通过映射设备内存，进程可以直接访问硬件设备的寄存器和内存。



### 进程间通信？

> mmap怎么实现多进程的共享内存的？mmap映射的应该是虚拟内存地址吧，不同进程经过虚拟地址转换后就不一样了吧
>
> 
>
> `mmap` 的确是映射虚拟内存地址的，但通过某些特定的配置，可以实现多进程共享同一块物理内存，从而实现进程间的共享内存。具体实现方式如下：
>
> ### 使用 `mmap` 实现多进程共享内存
>
> 1. **使用共享内存文件**：
>    - 可以使用一个文件或通过特殊的共享内存文件（如`/dev/shm`）来实现共享。
> 2. **使用 `MAP_SHARED` 标志**：
>    - 在调用 `mmap` 时，使用 `MAP_SHARED` 标志，表示映射的内存区域是共享的，所有对该区域的修改对所有映射该区域的进程都是可见的。对该区域的修改对所有映射该区域的进程都是可见的。

## 文件系统

### 文件的存储

> 当你在Linux系统中挂载一个移动硬盘时，文件系统会读取一些特定的信息并将其加载到内存中，以便系统能够正常访问和管理该文件系统。这些信息主要包括以下几个部分：
>
> ### 1. 超级块（Superblock）
>
> 超级块是文件系统的一个关键数据结构，包含了整个文件系统的重要信息。每个文件系统都有一个超级块，当挂载文件系统时，超级块会被读取到内存中。超级块包含的信息包括：
>
> - 文件系统类型
> - 文件系统大小
> - 块大小
> - 空闲块和inode计数
> - 文件系统状态
> - 其他文件系统特定的信息
>
> ### 2. 组描述符（Group Descriptors）
>
> 对于如ext3、ext4等文件系统，超级块后面跟着的是一组组描述符，每个组描述符描述了文件系统中一个块组的元数据信息。组描述符会被读取到内存中，用于管理文件系统的分配策略和状态。
>
> ### 3. 块位图和inode位图（Block Bitmap and Inode Bitmap）
>
> 这些位图用于跟踪文件系统中块和inode的分配状态。位图会被读取到内存中，以便在文件创建、删除或修改时快速更新。
>
> ### 4. inode表（Inode Table）
>
> inode表包含了文件系统中所有文件和目录的元数据信息（如文件大小、权限、时间戳、数据块指针等）。在挂载时，只有必要的一部分inode会被读取到内存中，而其他inode会在访问时按需加载。
>
> ### 5. 目录项（Directory Entries）
>
> 目录项包含了目录中所有文件和子目录的列表。在挂载时，根目录的目录项通常会被读取到内存中，以便能够快速访问文件系统的根目录。
>
> ### 6. 日志（Journal）
>
> 对于带有日志功能的文件系统（如ext3、ext4、btrfs等），文件系统在挂载时会读取日志以恢复未完成的事务，从而确保文件系统的一致性和完整性。
>
> ### 7. 文件系统缓存（Page Cache, Dentry Cache, Inode Cache）
>
> 为了提高文件系统的性能，Linux会将文件系统的元数据和文件数据缓存到内存中。这些缓存包括：
>
> - **Page Cache**：用于缓存文件数据的页面。
> - **Dentry Cache**：用于缓存目录项。
> - **Inode Cache**：用于缓存inode信息。
>
> ### 挂载过程
>
> 挂载文件系统时的具体过程如下：
>
> 1. **读取超级块**：操作系统读取文件系统的超级块，并验证文件系统类型和完整性。
> 2. **初始化数据结构**：操作系统初始化与文件系统相关的数据结构，如组描述符、位图、inode表等。
> 3. **恢复日志**：如果文件系统具有日志功能，操作系统会读取并回放日志，以确保文件系统的一致性。
> 4. **挂载根目录**：操作系统将文件系统的根目录挂载到指定的挂载点，并将相关的目录项和inode信息加载到内存中。
> 5. **准备缓存**：操作系统准备文件系统的缓存，以提高后续文件访问的性能
>
> 
>
> 
>
> 4o
>
> 这些信息是存在磁盘的还是插上硬盘后构建的数据结构
>
> 
>
> ChatGPT
>
> 这些信息（超级块、组描述符、块位图、inode位图、inode表、目录项、日志等）主要存储在磁盘上。当你插入并挂载硬盘后，操作系统会从磁盘读取这些信息并构建相应的数据结构在内存中，以便于后续的文件操作



### 空闲管理是位图法

### MMap

**文件映射区**：通过`mmap`将文件或设备内容映射到进程的虚拟地址空间，使得应用程序可以通过内存地址直接访问文件内容。

**多进程共享内存**：使用`mmap`和`MAP_SHARED`可以实现多个进程间共享内存，允许它们通过映射区共享数据。

### 大文件传输+ MMap + 零拷贝

==传统方法==

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png)

期间共**发生了 4 次用户态与内核态的上下文切换**，因为发生了两次系统调用，一次是 `read()` ，一次是 `write()`，

==mmap==

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png)

具体过程如下：

- 应用进程调用了 `mmap()` 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；
- 应用进程再调用 `write()`，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；
- 最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。



==sendfile==

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png)

但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。



### Page Cache

最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O

可能是触发swap的情况下吧







### 命令

ifconfig



ip



netstat



ss

当 socket 状态处于 `Established`时：

- *Recv-Q* 表示 socket 缓冲区中还没有被应用程序读取的字节数；
- *Send-Q* 表示 socket 缓冲区中还没有被远端主机确认的字节数；

而当 socket 状态处于 `Listen` 时：

- *Recv-Q* 表示全连接队列的长度；
- *Send-Q* 表示全连接队列的最大长度；

















