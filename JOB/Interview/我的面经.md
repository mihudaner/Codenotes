

# 自我介绍

### Q:自我介绍，

* 面试官好，我叫王凯，是西安电子科技大学电子工程学院的硕士研究生。我的专业是新一代电子信息技术，就是之前的电子信息工程

  

* 我所在的影像处理实验室是科技部重点领域创新团队,实验室大方向是做深度学习的，我自己的研究方向是3D目标检测。

  

* 在校期间多次获得奖学金。在本科阶段，获得二次二等两次三等，硕士期间每个学期均二等。也有积极参加编程类竞赛，比如软件精英挑战赛西北赛区二等奖，嵌入式软件大赛西北13名，大学生数学竞赛三等奖等等

  

* 研究生期间也有参与组内和清华大学以及华为合作的项目，在其中负责一部分算法和客户端开发工作，参与验收。

  

* 研究成果方面，目前有一篇《3D Object Detection Method Based on CA Sampling and Local Attention Feature Encoding 已投的smartiot会议论文和一篇准备投的期刊论文。

  

* 专业技能方面，有QT客户端界面开发经验，熟悉操作系统，网络协议，以及深度学习框架pytorch。





# 专业技能

![image-20240809164344538](.\img\image-20240809164344538.png)

## c/c++

### c和c++语言的区别

1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、
   auto变量等。
2. C++是面对对象的编程语言；C语言是面对过程的编程语言。
3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而
   C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针等等；
4. C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。
   C++的STL库相对于C语言的函数库更灵活、更通用  

### 面向对象

> 它基于将程序视为一组对象（objects）的集合，这些对象由类（classes）定义，并且彼此交互来完成任务。面向对象的核心思想是通过抽象、封装、继承和多态等概念来提高代码的重用性、可维护性和扩展性。
>
> ### 面向对象的四大基本原则：
>
> 1. **抽象（Abstraction）：**
>    - 抽象是从现实世界的事物中提取出共性，忽略不必要的细节，从而形成一个通用的类。这可以帮助开发者专注于对象的行为和属性，而不是细节实现。
> 2. **封装（Encapsulation）：**
>    - 封装是将对象的属性和行为绑定在一起，并通过访问控制（如私有化属性）来隐藏内部实现细节。这使得对象的内部状态不会被外部代码任意修改，从而保证了数据的完整性。
> 3. **继承（Inheritance）：**
>    - 继承允许一个类从另一个类继承属性和行为，从而实现代码重用。子类可以继承父类的所有特性，并可以添加新的特性或重写（覆盖）父类的方法。
> 4. **多态（Polymorphism）：**
>    - 多态是指相同的操作可以作用于不同的对象上，并且表现出不同的行为。多态通常通过接口（Interface）或继承实现，允许程序更加灵活和可扩展。

### 新特性

> C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：
>
> 1. 语法的改进
>    （1）统一的初始化方法
>    （2）成员变量默认初始化
>    （3）auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行
>    初始化）
>    （4）decltype 求表达式的类型
>    （5）智能指针 shared_ptr
>    （6）空指针 nullptr（原来NULL）
>    （7）基于范围的for循环
>    （8）右值引用和move语义 让程序员有意识减少进行深拷贝操作
> 2. 标准库扩充（往STL里新加进一些模板类，比较好用）
>    （9）无序容器（哈希表） 用法和功能同map一模一样，区别在于哈希表的效率更高
>    （10）正则表达式 可以认为正则表达式 实质上是一个字符串，该字符串描述了一种特定模式的字
>    符串
>    （11）Lambda表达式  

### 前置++与后置++

```c
//前置
self &operator++() {
    node = (linktype)((node).next);
    return *this;
}
//后置
const self operator++(int) {
    self tmp = *this;
    ++*this;
    return tmp;
}
```

为了区分前后置，重载函数是以参数类型来区分，在调⽤的时候，编译器默默给int指定为⼀个0

> 1、==为什么后置返回对象，⽽不是引⽤==
> 因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，如果返回引⽤，那么我请问
> 你？你的对象对象都被销毁了，你引⽤啥呢？

> 2、==为什么后置前⾯也要加const==
> 其实也可以不加，但是为了防⽌你使⽤i++++,连续两次的调⽤后置++重载符，为什么呢?
> 原因：
> 它与内置类型⾏为不⼀致；你⽆法活得你所期望的结果，因为第⼀次返回的是旧值，⽽不是原对象，你调⽤两次后
> 置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const  

### 设计模式

 常用的设计模式

 介绍一下工厂模式，以及为什么需要使用工厂模式



#### 单例设计模式

项目中的某一个类只需要唯一的一个实例，即仅创建一次

使用单件模式，确保使用者也只能创建出一个实例

```c
class TaskManeger()
{
 private:
    // 私有构造函数，防止外部创建实例
    TaskManeger();
    {
        if(instance==nulltpr)
        {
            instance =  new TaskManeger();
            return instance;
        }
    }
    // 禁用拷贝构造函数和赋值运算符
    TaskManager(const TaskManager& other) = delete;
    TaskManager& operator=(const TaskManager& other) = delete;
    
    TaskManeger * instance = nulltpr;
public:
    TaskManeger * getinstance()
    {
        return instance;
    }
}
```



#### 工厂模式

依旧是文件分割器。但是需要构建不同的分割器，由于需求的变化，导致对象的具体类型经常变化

变化被推迟到更上层的MainForm创建的时候

存在的问题

- 由于MainForm的稳定依赖了具体的（变化的）子类，造成了类间依赖关系的不稳定，违反了DIP（依赖倒置原则），是不推荐的情况。

> 解决方法
>
> - 使用工厂模式：实现一个方法，绕开new，同样返回一个对象。定义一个用于创建对象的接口，让子类决定实例化某个类。
> - 用于隔离类对象的使用者和具体类型之间的耦合关系
> - 通过面向对象，将创建具体对象的工作延迟到子类

```c
class TxtSplitter: public ISplitter {

};

class PictureSplitter: public ISplitter {

};

class VideoSplitter: public ISplitter {

};


class MainForm {
public:
    void buttonClick() {
        // 没有绕开具体类
        ISplitter* splitter = new BinarySplitter();
        splitter->split();
    }
};
```



```c
class VideoSplitterFactory: public SplitterFactory {
public:
    virtual ISplitter* CreateSpitter() {
        return new VideoSplitter();
    }
};

// MainForm不再依赖具体类
class MainForm {
private:
    SplitterFactory* factory;
public:
    MainForm(SplitterFactory* factory) {
        this->factory = factory;
    }
    void buttonClick() {
        // 多态new
        ISplitter* splitter = factory->CreateSpitter();
        splitter->split();
    }
};
```



#### 抽象工厂

使用抽象工厂：工厂不再单一生产单个对象，而是将一系列操作放进一个工厂，都由一个工厂生产，故名抽象工厂

```c
// 数据库相关基类
class IDBConnection {

};

class IDBCommand {

};

class IDataReader {

};

// 抽象工厂
class IDBFactory {
public:
    virtual IDBConnection* CreateDBConnection() = 0;
    virtual IDBCommand* CreateDBCommand() = 0;
    virtual IDataReader* CreateDataReader() = 0;
};
```

#### 观察者模式

 存在的问题

- 观察者会变化，需要更改目标的通知实现方式，对于观察者增减的需求不满足开闭原则；通知的具体实现在目标处完成，没有独立抽象，不符合DIP（依赖倒置原则）原则。

\5. 解决方法

- 使用观察者模式：定义对象间的一对多的关系，以便一个对象发生变化时，能够及时通知所依赖的其他对象（观察者），方便添加或删除观察者，并且符合DIP原则。

```c
#include <iostream>
using namespace std;

class FileSplitter {
private:
    string m_filePath;
    int m_fileNumber;
    ProgressBar* m_progressBar;

public:
    FileSplitter(string& filePath, int fileNumber, ProgressBar* progressBar):
        m_filePath(filePath), 
        m_fileNumber(fileNumber), 
        m_progressBar(progressBar) {
    }

    void split() {
        for (int i = 0; i < m_fileNumber; ++i) {
            m_progressBar->setValue();
        }
    }
};

// 主逻辑
class Form {};

class TextBox {
public:
    string getText() {
        return "";
    }
};

class ProgressBar {
public:
    void setValue() {}
};

class MainForm: Form {
private:
    TextBox* txtFilePath;
    TextBox* txtFileNumber;
    ProgressBar* progressBar;

public:
    void buttonClick() {
        string filePath = txtFilePath->getText();
        int fileNumber = atoi(txtFileNumber->getText().c_str());

        FileSplitter* splitter = new FileSplitter(filePath, fileNumber, progressBar);
        splitter->split();
    }
};
```

- 可以独立改变目标与观察者（松耦合）
- 目标发送通知时，无需指定观察者，只管通知机制，而通知自动传播
- 观察者自己决定是否订阅通知

```c
#include <iostream>
#include <vector>
using namespace std;

class IProgress {
public:
    virtual void DoProgress(float value) = 0;
    virtual ~IProgress() {}
};

class FileSplitter {
private:
    string m_filePath;
    int m_fileNumber;
    // 抽象通知机制
    IProgress* m_iprogress;
    // 多个观察者使用容器保存
    vector<IProgress*> m_iprogressVector;

public:
    FileSplitter(string& filePath, int fileNumber, IProgress* iprogress):
        m_filePath(filePath), 
        m_fileNumber(fileNumber), 
        m_iprogress(iprogress) {
    }

    void split() {
        for (int i = 0; i < m_fileNumber; ++i) {
            m_iprogress->DoProgress(i);
            // 多个观察者使用容器保存
        }
    }

    // 多个观察者
    void add() {}

    void remove() {}
};

// 主逻辑
class Form {};

class TextBox {
public:
    string getText() {
        return "";
    }
};

class ProgressBar {
public:
    void setValue() {}
};

class MainForm: public Form, public IProgress {
private:
    TextBox* txtFilePath;
    TextBox* txtFileNumber;
    ProgressBar* progressBar;

public:
    void buttonClick() {
        string filePath = txtFilePath->getText();
        int fileNumber = atoi(txtFileNumber->getText().c_str());

        // this比较重要
        FileSplitter* splitter = new FileSplitter(filePath, fileNumber, this);

        splitter->split();
    }

    // 不论有多少个观察者，都可以实现自己的通知机制
    virtual void Doprogress(float value) {
        progressBar->setValue();
    }
};
```

FileSplitter* splitter = new FileSplitter(filePath, fileNumber, this);==this比较重要==

#### 依赖导致原则

**依赖倒置原则**是软件开发中的一项重要设计原则，‌旨在通过解耦和提高灵活性来构建可插拔的系统。‌该原则最早由罗伯特·C·马丁提出，‌基于两个关键概念：‌高层模块不应该依赖低层模块，‌二者都应该依赖其抽象；‌抽象不应该依赖细节，‌细节应该依赖抽象。‌简而言之，‌依赖倒置原则要求我们通过抽象来将高层和低层模块连接起来，‌而不是直接依赖于具体的实现。‌

## 网络

### TCP

### IP

### HTTPS



##  排序

### 冒泡

```
// 1 冒泡排序：‌
// 时间复杂度：‌最好情况为O(n)，‌当数组完全逆序时。‌平均时间复杂度为O(n^2)。‌
// 稳定性：‌稳定。‌
```

### 快速排序

```c

// 2  快速排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)，‌最好情况为O(nlogn)，‌最坏情况为O(n^2)。‌
// 稳定性：‌不稳定

void quiksort(int l, int r)
{
    if(l>=r) return;
    int i = l-1, j = r+1, mid = (l + r)/2;
    int target = nums[mid];
    while (i < j)
    {
        do i++; while (nums[i] < target);
        do j--; while (nums[j] > target);
            
        if (i < j)
            swap(nums[i], nums[j]);
        //cout << i << " " <<  j << endl;
    }
    quiksort(l, j);
    quiksort(j+1, r);
    return;
}
```

### 插入排序

```c

//3  直接插入排序：‌
// 时间复杂度：‌平均时间复杂度为O(n^2)，‌最好情况为O(n)。‌
// 稳定性：‌稳定。‌

void  insert_sort()
{
    vector<int> res(nums.size(),0);
    
    for(int i=0;i<nums.size();i++)
    {
        int idx = i;
        while(idx>0&&res[idx-1]>nums[i])
        {
            res[idx] = res[idx-1];
            idx--;
        }
        res[idx] = nums[i];
    }
    for(int i=0;i<nums.size();i++) nums[i] = res[i];
    return;
}

```

### 归并排序

```c


// 4 归并排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)。‌
// 稳定性：‌稳定。‌

void merge_sort(int l, int r)
{
    if(l>=r) return;
    int mid = (l+r)/2;
    merge_sort(l,mid);
    merge_sort(mid+1,r);
    vector<int> temp;
    int i=l,j=mid+1;
    while(i<=mid&&j<=r)
    {
        if(nums[i]<=nums[j]) temp.push_back(nums[i++]);
        else temp.push_back(nums[j++]);
    }
    
    while(i<=mid) temp.push_back(nums[i++]);
    while(j<=r) temp.push_back(nums[j++]);
    int idx = 0;
    while(idx<temp.size()) 
    {
        nums[l++]=temp[idx++];
    }
    return;
}
```

### 堆排序

```c

// 5 堆排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)。‌
// 稳定性：‌不稳定。‌

void heapdown(int i, int max)
{
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < max && nums[left] > nums[largest])
        largest = left;
    if (right < max && nums[right] > nums[largest])
        largest = right;

    if (largest != i)
    {
        swap(nums[i], nums[largest]);
        heapdown(largest, max);
    }
}

void build_heap()
{
    
    for(int i=n/2-1;i>=0;i--)
    {
        heapdown(i, n);
    }
    return;
}


void  heap_sort()
{
    build_heap();
    for(int i=n-1;i>=0;i--)
    {
        swap(nums[0],nums[i]);
        heapdown(0, i);
    }
}

```





# 项目

## Q介绍自己做过的最满意一个项目

清华大学以及华为合作的项目我觉得都是挺重要的经历 。可能和清华大学目前合作的项目是我觉得在硕士期间比较得到锻炼的一个项目，因为这个项目主要是我在负责，包括和对方负责人的沟通，界面开发，功能的开发测试都是我在弄，也去清华那边出差了好几次去调试。项目设计的内容也挺多的，比如传感器之间的标定算法，看一些设备的文档进行二次开发，一些深度学习模型的部署，QT的用户界面开发，也涉及到一些多进程的知识。



## Q:在这个项目中最大的收获

 A:这是第一次多人合作的比较大的一个项目，再与对面的组员进行对接、沟通过程中与锻炼了与自己合作的能力。项目中用到的很多需求之前没接触过，也是边学边开发。在短时间内的自学能力得到了提升，也锻炼了自己阅读文档的能力，后面自己也要写一个关于这个项目的文档。







# Q:反问环节

几轮面试

工作时长和出差情况

入职培养机制



