

# 自我介绍

### Q:自我介绍，

* 面试官好，我叫王凯，是西安电子科技大学电子工程学院的硕士研究生。我的专业是新一代电子信息技术，就是之前的电子信息工程

  

* 我所在的影像处理实验室是科技部重点领域创新团队,实验室大方向是做深度学习的，我自己的研究方向是3D目标检测。

  

* 在校期间多次获得奖学金。在本科阶段，获得二次二等两次三等，硕士期间每个学期均二等。也有积极参加编程类竞赛，比如软件精英挑战赛西北赛区二等奖，嵌入式软件大赛西北13名，大学生数学竞赛三等奖等等

  

* 研究生期间也有参与组内和清华大学以及华为合作的项目，在其中负责一部分算法和客户端开发工作，参与验收。

  

* 研究成果方面，目前有一篇《3D Object Detection Method Based on CA Sampling and Local Attention Feature Encoding 已投的smartiot会议论文和一篇准备投的期刊论文。

  

* 专业技能方面，有QT客户端界面开发经验，熟悉操作系统，网络协议，以及深度学习框架pytorch。





# 专业技能

![image-20240809164344538](.\img\image-20240809164344538.png)

## c/c++

### c和c++语言的区别

1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、
   auto变量等。
2. C++是面对对象的编程语言；C语言是面对过程的编程语言。
3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而
   C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针等等；
4. C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。
   C++的STL库相对于C语言的函数库更灵活、更通用  

### 面向对象

> 它基于将程序视为一组对象（objects）的集合，这些对象由类（classes）定义，并且彼此交互来完成任务。面向对象的核心思想是通过抽象、封装、继承和多态等概念来提高代码的重用性、可维护性和扩展性。
>
> ### 面向对象的四大基本原则：
>
> 1. **抽象（Abstraction）：**
>    - 抽象是从现实世界的事物中提取出共性，忽略不必要的细节，从而形成一个通用的类。这可以帮助开发者专注于对象的行为和属性，而不是细节实现。
> 2. **封装（Encapsulation）：**
>    - 封装是将对象的属性和行为绑定在一起，并通过访问控制（如私有化属性）来隐藏内部实现细节。这使得对象的内部状态不会被外部代码任意修改，从而保证了数据的完整性。
> 3. **继承（Inheritance）：**
>    - 继承允许一个类从另一个类继承属性和行为，从而实现代码重用。子类可以继承父类的所有特性，并可以添加新的特性或重写（覆盖）父类的方法。
> 4. **多态（Polymorphism）：**
>    - 多态是指相同的操作可以作用于不同的对象上，并且表现出不同的行为。多态通常通过接口（Interface）或继承实现，允许程序更加灵活和可扩展。

### 新特性

> C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：
>
> 1. 语法的改进
>    （1）统一的初始化方法
>    （2）成员变量默认初始化
>    （3）auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行
>    初始化）
>    （4）decltype 求表达式的类型
>    （5）智能指针 shared_ptr
>    （6）空指针 nullptr（原来NULL）
>    （7）基于范围的for循环
>    （8）右值引用和move语义 让程序员有意识减少进行深拷贝操作
> 2. 标准库扩充（往STL里新加进一些模板类，比较好用）
>    （9）无序容器（哈希表） 用法和功能同map一模一样，区别在于哈希表的效率更高
>    （10）正则表达式 可以认为正则表达式 实质上是一个字符串，该字符串描述了一种特定模式的字
>    符串
>    （11）Lambda表达式  

### C++常用库

> STL库
>
> STL（Standard Template Library）是C++标准库的一部分，提供了丰富的容器和算法，包括vector、list、set、map等容器，以及sort、find、replace等算法。STL库的使用简单明了，能够快速实现常见数据结构和算法。
>
> Boost库
>
> Boost库是一个由C++标准委员会外的开发者开发的、基于C++标准的开源库，提供了大量的跨平台、高质量的库，包括智能指针、线程、日期时间等。Boost库的功能非常丰富，可以满足各种需求，是一个非常不错的选择。
>
> OpenCV库
>
> OpenCV（Open Source Computer Vision Library）是一个开源计算机视觉库，提供了一系列视觉算法和工具，包括图像处理、计算机视觉、机器学习等。OpenCV库广泛应用于计算机视觉领域，例如人脸识别、运动跟踪等
>
> QT
>
> httplib
>
> cstring
>
> cjson
>
> Opengl
>
> pcl

### 新特性

### 前置++与后置++

```c
//前置
self &operator++() {
    node = (linktype)((node).next);
    return *this;
}
//后置
const self operator++(int) {
    self tmp = *this;
    ++*this;
    return tmp;
}
```

为了区分前后置，重载函数是以参数类型来区分，在调⽤的时候，编译器默默给int指定为⼀个0

> 1、==为什么后置返回对象，⽽不是引⽤==
> 因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，如果返回引⽤，那么我请问
> 你？你的对象对象都被销毁了，你引⽤啥呢？

> 2、==为什么后置前⾯也要加const==
> 其实也可以不加，但是为了防⽌你使⽤i++++,连续两次的调⽤后置++重载符，为什么呢?
> 原因：
> 它与内置类型⾏为不⼀致；你⽆法活得你所期望的结果，因为第⼀次返回的是旧值，⽽不是原对象，你调⽤两次后
> 置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const  



### 基本数据类型长度

> **无符号整数类型**：`size_t` 是一个无符号整数类型，也就是说它只能表示非负整数。
>
> **与平台相关**：`size_t` 的大小取决于平台的位数。在 32 位系统上，`size_t` 通常是 32 位宽；在 64 位系统上，`size_t` 通常是 64 位宽。

![img](https://img2.baidu.com/it/u=844834421,2336424125&fm=253&fmt=auto&app=138&f=PNG?w=661&h=500)



## 设计模式

 常用的设计模式

 介绍一下工厂模式，以及为什么需要使用工厂模式

#### 单例设计模式

项目中的某一个类只需要唯一的一个实例，即仅创建一次

使用单件模式，确保使用者也只能创建出一个实例

```c
class TaskManeger()
{
 private:
    // 私有构造函数，防止外部创建实例
    TaskManeger();
    {
        if(instance==nulltpr)
        {
            instance =  new TaskManeger();
            return instance;
        }
    }
    // 禁用拷贝构造函数和赋值运算符
    TaskManager(const TaskManager& other) = delete;
    TaskManager& operator=(const TaskManager& other) = delete;
    
    TaskManeger * instance = nulltpr;
public:
    TaskManeger * getinstance()
    {
        return instance;
    }
}
```



#### 工厂模式

依旧是文件分割器。但是需要构建不同的分割器，由于需求的变化，导致对象的具体类型经常变化

变化被推迟到更上层的MainForm创建的时候

存在的问题

- 由于MainForm的稳定依赖了具体的（变化的）子类，造成了类间依赖关系的不稳定，违反了DIP（依赖倒置原则），是不推荐的情况。

> 解决方法
>
> - 使用工厂模式：实现一个方法，绕开new，同样返回一个对象。定义一个用于创建对象的接口，让子类决定实例化某个类。
> - 用于隔离类对象的使用者和具体类型之间的耦合关系
> - 通过面向对象，将创建具体对象的工作延迟到子类

```c
class TxtSplitter: public ISplitter {

};

class PictureSplitter: public ISplitter {

};

class VideoSplitter: public ISplitter {

};


class MainForm {
public:
    void buttonClick() {
        // 没有绕开具体类
        ISplitter* splitter = new BinarySplitter();
        splitter->split();
    }
};
```



```c
class VideoSplitterFactory: public SplitterFactory {
public:
    virtual ISplitter* CreateSpitter() {
        return new VideoSplitter();
    }
};

// MainForm不再依赖具体类
class MainForm {
private:
    SplitterFactory* factory;
public:
    MainForm(SplitterFactory* factory) {
        this->factory = factory;
    }
    void buttonClick() {
        // 多态new
        ISplitter* splitter = factory->CreateSpitter();
        splitter->split();
    }
};
```



#### 抽象工厂

使用抽象工厂：工厂不再单一生产单个对象，而是将一系列操作放进一个工厂，都由一个工厂生产，故名抽象工厂

```c
// 数据库相关基类
class IDBConnection {

};

class IDBCommand {

};

class IDataReader {

};

// 抽象工厂
class IDBFactory {
public:
    virtual IDBConnection* CreateDBConnection() = 0;
    virtual IDBCommand* CreateDBCommand() = 0;
    virtual IDataReader* CreateDataReader() = 0;
};
```

#### 观察者模式

 存在的问题

- 观察者会变化，需要更改目标的通知实现方式，对于观察者增减的需求不满足开闭原则；通知的具体实现在目标处完成，没有独立抽象，不符合DIP（依赖倒置原则）原则。

\5. 解决方法

- 使用观察者模式：定义对象间的一对多的关系，以便一个对象发生变化时，能够及时通知所依赖的其他对象（观察者），方便添加或删除观察者，并且符合DIP原则。

```c
#include <iostream>
using namespace std;

class FileSplitter {
private:
    string m_filePath;
    int m_fileNumber;
    ProgressBar* m_progressBar;

public:
    FileSplitter(string& filePath, int fileNumber, ProgressBar* progressBar):
        m_filePath(filePath), 
        m_fileNumber(fileNumber), 
        m_progressBar(progressBar) {
    }

    void split() {
        for (int i = 0; i < m_fileNumber; ++i) {
            m_progressBar->setValue();
        }
    }
};

// 主逻辑
class Form {};

class TextBox {
public:
    string getText() {
        return "";
    }
};

class ProgressBar {
public:
    void setValue() {}
};

class MainForm: Form {
private:
    TextBox* txtFilePath;
    TextBox* txtFileNumber;
    ProgressBar* progressBar;

public:
    void buttonClick() {
        string filePath = txtFilePath->getText();
        int fileNumber = atoi(txtFileNumber->getText().c_str());

        FileSplitter* splitter = new FileSplitter(filePath, fileNumber, progressBar);
        splitter->split();
    }
};
```

- 可以独立改变目标与观察者（松耦合）
- 目标发送通知时，无需指定观察者，只管通知机制，而通知自动传播
- 观察者自己决定是否订阅通知

```c
#include <iostream>
#include <vector>
using namespace std;

class IProgress {
public:
    virtual void DoProgress(float value) = 0;
    virtual ~IProgress() {}
};

class FileSplitter {
private:
    string m_filePath;
    int m_fileNumber;
    // 抽象通知机制
    IProgress* m_iprogress;
    // 多个观察者使用容器保存
    vector<IProgress*> m_iprogressVector;

public:
    FileSplitter(string& filePath, int fileNumber, IProgress* iprogress):
        m_filePath(filePath), 
        m_fileNumber(fileNumber), 
        m_iprogress(iprogress) {
    }

    void split() {
        for (int i = 0; i < m_fileNumber; ++i) {
            m_iprogress->DoProgress(i);
            // 多个观察者使用容器保存
        }
    }

    // 多个观察者
    void add() {}

    void remove() {}
};

// 主逻辑
class Form {};

class TextBox {
public:
    string getText() {
        return "";
    }
};

class ProgressBar {
public:
    void setValue() {}
};

class MainForm: public Form, public IProgress {
private:
    TextBox* txtFilePath;
    TextBox* txtFileNumber;
    ProgressBar* progressBar;

public:
    void buttonClick() {
        string filePath = txtFilePath->getText();
        int fileNumber = atoi(txtFileNumber->getText().c_str());

        // this比较重要
        FileSplitter* splitter = new FileSplitter(filePath, fileNumber, this);

        splitter->split();
    }

    // 不论有多少个观察者，都可以实现自己的通知机制
    virtual void Doprogress(float value) {
        progressBar->setValue();
    }
};
```

FileSplitter* splitter = new FileSplitter(filePath, fileNumber, this);==this比较重要==

#### 依赖导致原则

**依赖倒置原则**是软件开发中的一项重要设计原则，‌旨在通过解耦和提高灵活性来构建可插拔的系统。‌该原则最早由罗伯特·C·马丁提出，‌基于两个关键概念：‌高层模块不应该依赖低层模块，‌二者都应该依赖其抽象；‌抽象不应该依赖细节，‌细节应该依赖抽象。‌简而言之，‌依赖倒置原则要求我们通过抽象来将高层和低层模块连接起来，‌而不是直接依赖于具体的实现。‌

## 网络

### TCP

#### TCP 三次握手过程是怎样的？

TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:50%;" />



> - 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
> - 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。
> - 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。
> - 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
> - 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。
>
> 从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。
>
> 一旦完成三次握手，双方都处于 `ESTABLISHED` 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。

### IP

### HTTPS



##  排序

### 冒泡

```
// 1 冒泡排序：‌
// 时间复杂度：‌最好情况为O(n)，‌当数组完全逆序时。‌平均时间复杂度为O(n^2)。‌
// 稳定性：‌稳定。‌
```

### 快速排序

```c

// 2  快速排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)，‌最好情况为O(nlogn)，‌最坏情况为O(n^2)。‌
// 稳定性：‌不稳定

void quiksort(int l, int r)
{
    if(l>=r) return;
    int i = l-1, j = r+1, mid = (l + r)/2;
    int target = nums[mid];
    while (i < j)
    {
        do i++; while (nums[i] < target);
        do j--; while (nums[j] > target);
            
        if (i < j)
            swap(nums[i], nums[j]);
        //cout << i << " " <<  j << endl;
    }
    quiksort(l, j);
    quiksort(j+1, r);
    return;
}
```

### 插入排序

```c

//3  直接插入排序：‌
// 时间复杂度：‌平均时间复杂度为O(n^2)，‌最好情况为O(n)。‌
// 稳定性：‌稳定。‌

void  insert_sort()
{
    vector<int> res(nums.size(),0);
    
    for(int i=0;i<nums.size();i++)
    {
        int idx = i;
        while(idx>0&&res[idx-1]>nums[i])
        {
            res[idx] = res[idx-1];
            idx--;
        }
        res[idx] = nums[i];
    }
    for(int i=0;i<nums.size();i++) nums[i] = res[i];
    return;
}

```

### 归并排序

```c


// 4 归并排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)。‌
// 稳定性：‌稳定。‌

void merge_sort(int l, int r)
{
    if(l>=r) return;
    int mid = (l+r)/2;
    merge_sort(l,mid);
    merge_sort(mid+1,r);
    vector<int> temp;
    int i=l,j=mid+1;
    while(i<=mid&&j<=r)
    {
        if(nums[i]<=nums[j]) temp.push_back(nums[i++]);
        else temp.push_back(nums[j++]);
    }
    
    while(i<=mid) temp.push_back(nums[i++]);
    while(j<=r) temp.push_back(nums[j++]);
    int idx = 0;
    while(idx<temp.size()) 
    {
        nums[l++]=temp[idx++];
    }
    return;
}
```

### 堆排序

```c

// 5 堆排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)。‌
// 稳定性：‌不稳定。‌

void heapdown(int i, int max)
{
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < max && nums[left] > nums[largest])
        largest = left;
    if (right < max && nums[right] > nums[largest])
        largest = right;

    if (largest != i)
    {
        swap(nums[i], nums[largest]);
        heapdown(largest, max);
    }
}

void build_heap()
{
    
    for(int i=n/2-1;i>=0;i--)
    {
        heapdown(i, n);
    }
    return;
}


void  heap_sort()
{
    build_heap();
    for(int i=n-1;i>=0;i--)
    {
        swap(nums[0],nums[i]);
        heapdown(0, i);
    }
}

```



## [select和epoll详解](https://zhuanlan.zhihu.com/p/179071801?utm_id=0)

> ### select
>
> `select` 是一种较老的 I/O 多路复用机制，几乎在所有 UNIX 系统上都可用。
>
> 1. **性能限制**：当处理大量文件描述符时，性能会显著下降。每次调用 `select` 都需要线性扫描所有的文件描述符。
> 2. **文件描述符限制**：`select` 的文件描述符数量有限制（通常为 1024），虽然可以通过修改系统参数来增加这个限制，但仍然不适合处理大规模连接。
> 3. **可移植性问题**：在不同的平台上可能会有一些细微的差别。
>
> ### epoll
>
> `epoll` 是 Linux 特有的 I/O 多路复用机制，设计用于替代 `select` 和 `poll`，在处理大量文件描述符时性能更佳。
>
> **优点**：
>
> 1. **高性能**：`epoll` 使用事件驱动机制，可以高效处理大量文件描述符。它避免了线性扫描文件描述符集，使用 O(1) 的复杂度。
> 2. **没有文件描述符限制**：`epoll` 没有像 `select` 那样的文件描述符数量限制，可以处理大规模连接。
> 3. **支持边缘触发和水平触发**：可以配置为只在有新的事件时通知，减少系统调用次数。
>
> **缺点**：
>
> 1. **仅限于 Linux**：`epoll` 仅在 Linux 系统上可用，降低了程序的可移植性。
> 2. **使用复杂**：相比 `select`，`epoll` 的使用稍微复杂一些。





> ### `select` 的瓶颈
>
> 1. **文件描述符限制**：
>    - `select` 在设计时对监视的文件描述符数量有限制，这通常是由系统的 `FD_SETSIZE` 限制的，默认值可能是1024（可以通过重新编译内核或调整系统参数来改变）。这意味着 `select` 处理的并发连接数有限，如果超出限制就无法再使用 `select`。
> 2. **性能开销**：
>    - 每次调用 `select` 时，都会将 `fd_set` 结构从用户态复制到内核态，并将其复制回去。这个操作在文件描述符数量非常大的情况下会产生显著的性能开销。
> 3. **线性扫描**：
>    - `select` 需要扫描整个文件描述符集合，检查哪些文件描述符准备好进行读写。这种线性扫描的方式会在文件描述符数量多时显著影响性能
>
> ### `epoll` 的瓶颈
>
> epoll适合连接多活跃的少、
>
> epoll移植性差
>
> **需要重新注册文件描述符**：‌在epoll模型下，‌为了保证同一个连接的数据始终落到同一个线程上，‌必须在每次处理完数据后重新把文件描述符加入epoll中，‌这增加了额外的操作复杂度
>
> ### [epoll反应堆监听写事件为什么要下树](http://www.baidu.com/link?url=LLljGulX5lz7VNrEJ77erUoJ0gMSi0qVGaL58wINe7VhVjG-m4RSNkVjsZdcZuCVFNWm-oUxcNdN0cqvJqzavt9FYUeR5TV4siU-LbFQ95y)
>
> (1) 如此频繁的增加删除不是浪费CPU资源吗？
> 答：对于同一个socket而言，完成收发至少占用两个树上的位置。
> 而交替只需要一个。任何一种设计方式都会有浪费CPU资源的时候，
> 关键看你浪费得值不值，此处的耗费能否换来更大的收益才是衡量是否浪费的标准。
> 和第二个问题综合来看，这里不算浪费
>
> (2) 为什么要可读以后设置可写，然后一直交替？
> 答：服务器的基本工作无非数据的收发，epoll反应堆模型准从TCP模式，一问一答。
> 服务器收到了数据，再给予回复，是目前绝大多数服务器的情况。
> (2-1) 服务器能收到数据并不是一定能写数据
> 假设一 ：服务器接收到客户端数据，刚好此时客户端的接收滑动窗口满，
> 我们假设不进行可写事件设置，并且客户端是有意让自己的接收滑动窗口满的情况(黑客)。
> 那么，当前服务器将随客户端的状态一直阻塞在可写事件，除非你自己在写数据时设置非阻塞+错误处理
> 假设二 ：客户端在发送完数据后突然由于异常原因停止，这将导致一个FIN发送至服务器，
> 如果服务器不设置可写事件监听，那么在接收数据后写入数据会引发异常SIGPIPE，最终服务器进程终止。







# 项目

## Q介绍自己做过的最满意一个项目

清华大学以及华为合作的项目我觉得都是挺重要的经历 。可能和清华大学目前合作的项目是我觉得在硕士期间比较得到锻炼的一个项目，因为这个项目主要是我在负责，包括和对方负责人的沟通，界面开发，功能的开发测试都是我在弄，也去清华那边出差了好几次去调试。项目设计的内容也挺多的，比如传感器之间的标定算法，看一些设备的文档进行二次开发，一些深度学习模型的部署，QT的用户界面开发，也涉及到一些多进程的知识。



## Q:在这个项目中最大的收获

 A:这是第一次多人合作的比较大的一个项目，再与对面的组员进行对接、沟通过程中与锻炼了与自己合作的能力。项目中用到的很多需求之前没接触过，也是边学边开发。在短时间内的自学能力得到了提升，也锻炼了自己阅读文档的能力，后面自己也要写一个关于这个项目的文档。



# 手撕

## mem函数

![image-20240811194358234](img/image-20240811194358234.png)



```c
void kernel_memcpy (void * dest, void * src, int size) {
    if (!dest || !src || !size) {
        return;
    }

    uint8_t * s = (uint8_t *)src;
    uint8_t * d = (uint8_t *)dest;
    while (size--) {
        *d++ = *s++;
    }
}

void kernel_memset(void * dest, uint8_t v, int size) {
    if (!dest || !size) {
        return;
    }

    uint8_t * d = (uint8_t *)dest;
    while (size--) {
        *d++ = v;
    }
}

int kernel_memcmp (void * d1, void * d2, int size) {
    if (!d1 || !d2) {
        return 1;
    }

	uint8_t * p_d1 = (uint8_t *)d1;
	uint8_t * p_d2 = (uint8_t *)d2;
	while (size--) {
		if (*p_d1++ != *p_d2++) {
			return 1;
		}
	}

	return 0;
}

void kernel_itoa(char * buf, int num, int base) {
    // 转换字符索引[-15, -14, ...-1, 0, 1, ...., 14, 15]
    static const char * num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char * p = buf;
    int old_num = num;

    // 仅支持部分进制
    if ((base != 2) && (base != 8) && (base != 10) && (base != 16)) {
        *p = '\0';
        return;
    }

    // 只支持十进制负数
    int signed_num = 0;
    if ((num < 0) && (base == 10)) {
        *p++ = '-';
        signed_num = 1;
    }

    if (signed_num) {
        do {
            char ch = num2ch[num % base + 15];
            *p++ = ch;
            num /= base;
        } while (num);
    } else {
        uint32_t u_num = (uint32_t)num;
        do {
            char ch = num2ch[u_num % base + 15];
            *p++ = ch;
            u_num /= base;
        } while (u_num);
    }
    *p-- = '\0';

    // 将转换结果逆序，生成最终的结果
    char * start = (!signed_num) ? buf : buf + 1;
    while (start < p) {
        char ch = *start;
        *start = *p;
        *p-- = ch;
        start++;
    }
}

```

## str函数

```c
//拷贝
void kernel_strcpy (char * dest, const char * src) {
    if (!dest || !src) {
        return;
    }

    while (*dest && *src) {
        *dest++ = *src++;
    }
    *dest = '\0';
}
//拷贝
char* strcpy(char *dst,const char *src) {// [1]
     assert(dst != NULL && src != NULL); // [2]
     char *ret = dst; // [3]
     while ((*dst++=*src++)!='\0'); // [4]
     return ret;
}
//拷贝n个
void kernel_strncpy(char * dest, const char * src, int size) {
    if (!dest || !src || !size) {
        return;
    }

    char * d = dest;
    const char * s = src;

    while ((size-- > 0) && (*s)) {
        *d++ = *s++;
    }
    if (size == 0) {
        *(d - 1) = '\0';
    } else {
        *d = '\0';
    }
}
//长度
int kernel_strlen(const char * str) {
    if (str == (const char *)0) {
        return 0;
    }

	const char * c = str;

	int len = 0;
	while (*c++) {
		len++;
	}

	return len;
}

/**
 * 比较两个字符串，最多比较size个字符
 * 如果某一字符串提前比较完成，也算相同
 */
int kernel_strncmp (const char * s1, const char * s2, int size) {
    if (!s1 || !s2) {
        return -1;
    }

    // 2023-3-18 这里size没有用到
    while (*s1 && *s2 && (*s1 == *s2) && size) {
    	s1++;
    	s2++;
    	size--;
    }

    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
}
```



## atoi

注意异常返回-1 int溢出

```c
int atoi(const char *str) {
    int sign = 1, base = 0, i = 0;

    // 去除前导空白字符
    while (str[i] == ' ') { i++; }
    
    // 处理正负号
    if (str[i] == '+' || str[i] == '-') {
        sign = (str[i++] == '-') ? -1 : 1;
    }
    
    // 转换数字字符
    while (str[i] >= '0' && str[i] <= '9') {
        base = base * 10 + (str[i++] - '0');
    }
    
    return sign * base;
}
```



## 手写字符串

```c++
class String
{
public:
     String(const char *str = NULL);
     String(const String &other);
     ~ String(void);
     String & operate =(const String &other);
    private:
char *m_data;
};


// 构造函数
String::String(const char *str)
{
    if (str == NULL)
    {
        m_data = new char[1]; // 对空字符串⾃动申请存放结束标志'\0'
        *m_data = '\0';
    }
    else
    {
        int length = strlen(str);
        m_data = new char[length + 1];
        strcpy(m_data, str);
    }
}
// 析构函数
String::~String(void)
{
    delete[] m_data; // 或delete m_data;
}
// 拷⻉构造函数
String::String(const String &other)
{
    int length = strlen(other.m_data);
    m_data = new char[length + 1];
    strcpy(m_data, other.m_data);
}
// 赋值函数
String &String::operate = (const String &other)
{
    if (this == &other)
    {
        return *this; // 检查⾃赋值
    }
    delete[] m_data; // 释放原有的内存资源
    int length = strlen(other.m_data);
    m_data = new char[length + 1]; // 对m_data加NULL判断
    strcpy(m_data, other.m_data);
    return *this; // 返回本对象的引⽤
}

```

## 手写Vector

```c++
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<limits>
#include<cstring>
using namespace std;
 
template <class T>
class myVector
{
    private:
        T* data;
        int len;
        int size;
    public:
        myVector()
        {
            data = NULL;
            len = size = 0;
        }
 
        myVector(int _len)
        {
            data = new T[_len];
            len = _len;
            size = 0;
        }
 
        myVector(const myVector& tmp)
        {
            if(this == &tmp)
                return;
 
            //delete []data;
            data = new T[tmp.len];
            for(int i=0; i<tmp.size; ++i)
                data[i] = tmp.data[i];
            len = tmp.len;
            size = tmp.size;
        }
 
        T& operator[](int index)
        {
            return data[index];
        }
 
        const myVector& push_back(const T tmp)
        {
            if(size >= len)
            {
                T* newData = new T[len*2 + 1];
                memcpy(newData, data, len*sizeof(T));
                delete []data;
                data = newData;
                len = 2*len + 1;
            }
            data[size++] = tmp;
            printALL();
            return *this;
        }
 
        int getSize()
        {
            return size;
        }
 
        void printALL()
        {
            cout<<len<<":"<<size<<endl;
            for(int i=0; i<size; ++i)
                cout<<data[i].f<<" ";
            cout<<endl;
            cout<<"********************"<<endl;
        }
};
 
struct A{
    int f;
    public:
     A(int r):f(r){}
     A()
     {
         f =1;
     }
};
 
int main()
{
    myVector<A> v;
    v.push_back(A(2));
    v.push_back(A(3));
    v.push_back(A(4));
    v.push_back(A(5));
    v.push_back(A(6));
 
 
    //node* head = buildTree();
 
    //cout<<i<<"q";
    //system("pause");
    return 0;
}


```

> ****
>
> ```c
>  // 常量版本
> 
>   const T& operator[](int index) const
>   {
> ​    return data[index];
>   }
>   
> `const T&`（返回值类型）**：确保通过这个下标运算符访问的元素不能被修改。
> `const`（成员函数）**：保证这个函数不会修改类的状态，从而可以被`const`对象调用。
> ```

# Q:反问环节

几轮面试

工作时长和出差情况

入职培养机制



