



# 自我介绍

### Q:自我介绍，

* 面试官好，我叫王凯，是西安电子科技大学电子工程学院的硕士研究生。我的专业是新一代电子信息技术，就是之前的电子信息工程

  

* 我所在的影像处理实验室是科技部重点领域创新团队,实验室大方向是做深度学习的，我自己的研究方向是3D目标检测。

  

* 在校期间多次获得奖学金。在本科阶段，获得二次二等两次三等，硕士期间每个学期均二等。也有积极参加编程类竞赛，比如软件精英挑战赛西北赛区二等奖，嵌入式软件大赛西北13名，大学生数学竞赛三等奖等等

  

* 研究生期间也有参与组内和清华大学以及华为合作的项目，在其中负责一部分算法和开发工作，参与验收。

  

* 研究成果方面，目前有一篇《3D Object Detection Method Based on CA Sampling and Local Attention Feature Encoding 已投的smartiot会议论文和一篇准备投的期刊论文。

  

* 专业技能方面，有QT客户端界面开发经验，熟悉常用算法，操作系统，网络协议，以及深度学习框架pytorch。





![image-20240809164344538](.\img\image-20240809164344538.png)

# ==c/c++==

## c和c++语言的区别

1. C语言是C++的==子集==，C++可以很好兼容C语言。但是C++又有很多==新特性==，如引用、智能指针、
   auto变量等。
2. C++是==面对对象==的编程语言；C语言是==面对过程==的编程语言。
3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而
   C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针等等；
4. C++可==复用性高，C++==引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。
   C++的==STL库==相对于C语言的函数库更灵活、更通用  



## C++常用库

> **STL库**
>
> STL（包括vector、list、set、map等容器，以及sort、find、replace等算法。STL库的使用简单明了，能够快速实现常见数据结构和算法。
>
> **Boost库**
>
> Boost库是一个由C++标准委员会外的开发者开发的、基于C++标准的开源库，提供了大量的跨平台、高质量的库，包括智能指针、线程、日期时间等。Boost库的功能非常丰富，可以满足各种需求，是一个非常不错的选择。
>
> **OpenCV库**
>
> OpenCV（Open Source Computer Vision Library）是一个开源计算机视觉库，提供了一系列视觉算法和工具，包括图像处理、计算机视觉、机器学习等。OpenCV库广泛应用于计算机视觉领域，例如人脸识别、运动跟踪等
>
> 
>
> QT
>
> httplib
>
> cstring
>
> cjson
>
> Opengl
>
> pcl



## 面向对象

> 将程序视为一组对象（objects）的集合，这些对象由类（classes）定义，并且彼此交互来完成任务。面向对象的核心思想是通过抽象、封装、继承和多态等概念来提高代码的重用性、可维护性和扩展性。
>
> ### 面向对象的四大基本原则：
>
> 1. **抽象（Abstraction）：**
>    - 抽象是从现实世界的事物中提取出共性，从而形成一个通用的类。
> 2. **封装（Encapsulation）：**
>    - 封装是将对象的属性和行为绑定在一起，并通过访问控制（如私有化属性）来隐藏内部实现细节。
> 3. **继承（Inheritance）：**
>    - 继承允许一个类从另一个类继承属性和行为，从而实现代码重用。子类可以继承父类的所有特性，并可以添加新的特性或重写（覆盖）父类的方法。
> 4. **多态（Polymorphism）：**
>    - 多态是指相同的操作可以作用于不同的对象上，并且表现出不同的行为。多态通常通过虚函数实现，允许程序更加灵活和可扩展。





## 多态

> 多态：多态的实现原理主要依赖于==虚函数表（vtable）和动态绑==定。‌用父类型别的指针引用指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，静态多态和动态多态
>
> 
>
> ==静态多态==：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错  
>
> 
>
> ==动态多态==：其实要实现动态多态，需要几个条件——即动态绑定条件：
> \1. 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
> \2. 通过基类类型的指针或引用来调用虚函数  

## 虚函数

当一个类中声明了虚函数，==编译器会为该类生成一个虚函数表（vtable）==，表中存储了该类所有虚函数的地址。

这个表由编译器自动生成和维护。每个对象都有一个指向虚函数表的指针vptr，这个指针通常==位于对象的开头==。

当通过基类指针或引用调用一个虚函数时，运行时会在对象的vptr指向的虚函数表中查找相应的函数地址并调用。根据对象的实际类型来调用相应的函数，即多态。

‌**动态联编**‌：通过基类指针或引用调用虚函数时，编译时不确定具体调用哪个实现，而是==在运行时根据对象的实际类型==确定。首先需要取到对象的首地址，然后再解引用取到虚函数表的首地址后，再加上偏移量才能找到要调的虚函数，然后call调用



## 字节对齐

![image-20240904213720875](E:\codenotes\JOB\Interview\img\image-20240904213720875.png)

> 1. 对齐原则： 
>
> 【原则1】数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为 0的地方，以后==每个数据成员==的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。 
>
> 
>
> 【原则2】结构(或联合)的==整体对齐==规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
>
> 
>
>  【原则3】结构体作为成员：如果一个==结构里有某些结构体成员==，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。

> **位域**：不能跨类型存储，若跨类型存储要考虑字节对齐
>
> struct Test
>
> {    
>
> char a : 1;    
>
> int b : 1; 
>
> }8字节
>
> **枚举类型的大小是4个字节，超过就longlong**
>
> **联合体**
>
> **<img src="https://i-blog.csdnimg.cn/blog_migrate/c153ca3aa193deed681c04b473806949.png" alt="在这里插入图片描述" style="zoom:50%;" />*
>
> typedef不占用结构体空间







## new和malloc

![image-20240822163918079](.\img\image-20240822163918079.png)



**brk和mmap**

> **申请内存**
>
> 
>
> 方式一：小于 128 KB，通过 **brk()** 系统调用从堆分配内存 
>
> 方式二：通过 **mmap()** 系统调用在文件映射区域分配内存；
>
> **malloc()** 在分配内存的时候，并不是按申请的字节数来分配内存空间大小，而是会 预分配更大的空间作为**内存池**。



> **释放内存**
>
> 
>
> 如果 malloc 通过 mmap 方式申请的内存，free 释放内存后就会归归还给操作系统。
>
> malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是 缓存在 malloc 的内存池中，待下次使用；



> **各自缺点**
>
> 
>
> **mmap()**向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用 户态，运行态的切换会耗费不少时间。
>
> 
>
> **brk()**如果我们连续申请了 10k，20k，30k 这三片内存，如果 10k 和 20k 这两片释放了，变为了空闲内存 空间，如果下次申请的内存大于 30k，没有可用的空闲内存空间，必须向 OS 申请，实际使用内存继续 增大。 因此，随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多**不可用的碎片，导致“内存泄露”**。而这种“泄露”现象使用 valgrind 是无法检测出来的





## 内存泄漏

**什么是内存泄漏**

> 简单地说就是申请了一块内存空间，使用完毕后没有释放掉。
>
> （1）new和malloc申请资源使用后，没有用delete和free释放；
>
> （2）子类继承父类时，父类析构函数不是虚函数 

**如何避免内存泄漏**

> 将内存的分配封装在类中，
>
> 构造函数分配内存，析构函数释放内存；
>
> 使⽤智能指针  确保使用 RAII

**如何查看内存泄漏**

> - 检查代码
>
> - 在使用 `gdb` 调试程序时，可以设置断点并逐步检查程序的内存使用情况。
> - 可以使用 `info proc` 命令来查看当前进程的内存使用情况，尽管它不能直接检测内存泄漏，但可以帮助你识别可疑的内存增长点
>
> - Valgrind（memcheck）



## C11新特性

> C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：
>
> 1. 语法的改进
>    （1）统一的初始化方法
>    （2）成员变量默认初始化
>    （3）auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行
>    初始化）
>    （4）decltype 通过编译器分析表达式来推断其类型
>    （5）**智能指针 shared_ptr**
>    （6）**空指针 nullptr（原来NULL）**
>    （7）基于范围的for循环
>    （8）**右值引用和move语义** 让程序员有意识减少进行深拷贝操作
> 2. 标准库扩充（往STL里新加进一些模板类，比较好用）
>    （9）线程库
>    （10）正则表达式 可以认为正则表达式 实质上是一个字符串，该字符串描述了一种特定模式的字
>    符串
>    （11）**Lambda表达式**  



## 右值左值

**左值（Lvalue）**‌是指能够出现在赋值表达式左边的表达式。左值具有两个关键特性：它们可以取地址（即具有内存地址），并且可以被赋值。

**右值（Rvalue）**‌是指只能出现在赋值表达式右边的数值。右值通常指的是引用了一个存储在某个内存地址里的数据值。右值可以是常量、字面量、临时变量等，它们提供了要赋给左值的数据。右值相当于数据值本身，不具有左值的内存地址特性，因此不能被赋值或取地址。

> ### move原理是什么
>
> 那么我们能看出move就是将参数原来的修饰符全部都删掉，在强转为右值引用输出，就是这么简单，move没有干任何移动的过程

> ```c
> struct A {
>  A(){              // 基本构造
>      cout<<"construct: "<<++g_constructCount<<endl;    
>  }
> 
>  A(const A& a) {   // 拷贝构造
>      cout<<"copy construct: "<<++g_copyConstructCount <<endl;
>  }
> 
>  ~A() {            // 析构
>      cout<<"destruct: "<<++g_destructCount<<endl;
>  }
> };
> 
> A getA() {
>  A a;            // 第一次构造
>  return a;
>  // return A();  // 等价，分开写是为了便于说明
> }
> 
> int main() {
>  A a2 = getA();    // 非右值引用
>     //三次还有返回值一次
>  A&& a3 = getA();  // 右值引用 
>    //共两次，一次是在getA()函数中创建局部变量a时，一次是在将a的值转移给a3时触发的移动构造函数
>  return 0;
> }
> ```
>
> 
>
> - 非右值引用，关闭返回值优化
>
>   ```c
>   construct: 1        // 第一次构造，getA() 中的局部变量 a
>   copy construct: 1   // 第二次构造，将 a 复制给一个临时变量
>   destruct: 1           // 析构局部变量 a
>   copy construct: 2   // 第三次构造，将临时变量复制给 a2
>   destruct: 2           // 析构临时变量
>   destruct: 3           // 程序结束，析构变量 a2
>   ```





## nullptr 和隐式类型转换

> #### [**`NULL` 和 `nullptr` 在比较时的区别**](https://www.cnblogs.com/nntzhc/p/14085844.html)
>
> 
>
> `c++中NULL` 被视为整数 `0`，然后进行指针比较。在大多数情况下，它可以正常工作，因为编译器会将 `0` 转换为适当的指针类型。
>
> - 但是，如果你在使用函数重载或模板时，这种比较可能会导致编译器无法正确推导类型。例如，在函数重载中，如果有一个接受整数和另一个接受指针的重载，使用 `NULL` 可能会导致调用错误的重载。
>
> - 当你使用 `ptr == nullptr` 进行比较时，`nullptr` 明确表示为一个空指针，编译器可以清楚地知道你在进行指针比较。它只能隐式转换为指针类型，不能转换为整数或其他类型。这种类型安全性减少了意外的类型转换问题
>



> #### **如果写Null==nullptr会发生什么**
>
> 
>
> 比较 `NULL == nullptr`：
>
> 1. 隐式转换
>    - 编译器会将 `NULL`（即 `0`）隐式转换为 `nullptr` 可以比较的空指针类型。被转换为一个空指针，与 `nullptr` 进行比较时，它们都表示同样的空指针状态。
>



> ### 隐式类型转换
>
> 
>
> #### 阻止隐式类型转换    explicit
>
> ```c
> class MyClass {
> public:
>     explicit MyClass(int value) {
>         // 构造函数的实现
>     }
> 
> MyClass obj = 10; // 错误：不能隐式转换
> ```
>
> - c++中void* 不能隐式类型转换为其他类型指针，c语言可以
>
> - null本质是0但是还是有区别，null有二义，0没有
>
>   ```c
>   void test(void* p);
>   void test(int num);
>   ```



## 智能指针

### 智能指针的了解

> 2. 常见的智能指针有shared_ptr、unique_ptr和weak_ptr等。它们各有不同的使用场景和特点:
>    - shared_ptr允许多个智能指针共享同一个对象,引用计数机制确保对象在最后一个指针释放时被删除。
>    - unique_ptr独占对象的所有权,不允许拷贝,只能移动。
>    - weak_ptr不会增加引用计数,用于打破shared_ptr之间的循环引用。



### 线程安全

对于智能指针shared_ptr的引用计数本身是安全且无锁的，但**对象的读写则不是**，

- 同一个shared_ptr被并发读时，是安全的，但是写是不安全的

- 共享引用计数的shared_ptr被并发读写时，都是安全的

  

### 循环引用

当我们的两个类出于以下状态时：

```text
struct A {
    std::shared_ptr<B> shrd_ptr;
};

struct B {
    std::shared_ptr<A> shrd_ptr;
};

std::shared_ptr<A> ptr_A (std::make_shared<A> ());
std::shared_ptr<B> ptr_B (std::make_shared<B> ());
ptr_A->shrd_ptr = ptr_B;
ptr_B->shrd_ptr = ptr_A;
```

假如我们的类A想要析构的时候，发现类B里还有个指针指着自己，怎么也得等类B析构完，完了类A才能析构成功，但是类B想要析构的时候发现类A也有一个指针指向自己，析构不了了！于是就一直僵持，最后内存泄露，把其中一个类的`shared_ptr`换成`weak_ptr` ，weak_ptr是个辅助指针，只能用由`shraed_ptr`来构造，他不会增加`shread_ptr`的引用计数 ，只跟踪对象，当我们需要操控对象时，使用lock方法，就会将他转换成一个`shread_ptr`返回。



# ==多线程==

## 通信方式

**线程**

线程因为共享一份全局内存区，包括初始化数据段、未初始化数据段，以及堆内存段等，所以可以方便、快速地共享信息。 只需要考虑同步问题。 线程同步方法：

 1.信号、 2.加锁：互斥锁，读写锁，自旋锁 3.条件变量 4.信号量

**进程**

- **管道**（匿名管道）：本质上是内核中维护的一块内存缓冲区，Linux系统中由pipe()函数创建，只能用于具有亲缘关系的进程间通信。
- **命名管道**：不同于匿名管道之处在于它提供了一个路径名与之关联，进程通过访问该路径就能相互通信，适用于没有亲缘关系的进程间通信

- **信号**：一种异步通信方式，信号可以让一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。

- **消息队列**：是一个消息链表且随内核持续，具有特定的格式和特定的优先级，由具有写权限的进程添加消息，由具有读权限的进程读走消息。

- **共享内存**：允许两个或者多个进程共享物理内存的同一块区域（通常被称为段），无需内核介入，速度比管道快。

- **内存映射** ：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。

- **信号量**：主要用来解决进程和线程间并发执行时的同步问题，信号量操作分为P操作和V操作，P将信号量值-1，V将信号量值+1。当信号量值<=0时，进行P操作进线程会被阻塞，直到另一个进程或线程执行了V操作将信号量的值大于0时。

- **Socket 套接字**：一般用于网络中不同主机上的进程之间的通信，且提供了应用层进程利用网络协议交换数据的机制



## 进程状态

创建态，就绪态，运行态，阻塞态，终止态

进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源，初始化PCB，当进程创建完成后，就进入“就绪态”，

就绪态的进程已经具备运行的条件，由于没有空闲CPU，暂时无法运行，当CPU空闲时选择一个处于就绪态的进程上CPU运行，则处于“运行态”，

运行态中如果需要请求等待某个事件的发生（如：请求某种系统资源或等待其他进程的响应），则下CPU进入“阻塞态”，

当等待的事件发生了，再进入“就绪态”；

处于运行态的进程，时间片已到或者处理机被抢占，则转入“就绪态”。

进程运行结束或者发生不可修复的错误，进行就进入“终止态”，系统会回收该进程拥有的资源并撤销PCB

## 区别进程和线程区别 上下文切换

> ### 区别
>
> **本质区别**：进程是资源分配的基本单位，线程是CPU调度的基本单位。
>
> 
>
>  **内存消耗**：进程有独立的虚拟地址空间，而同一个进程的线程之间共享进程的资源，自身只有栈和寄存器等少量独立的空间。 
>
> 
>
> **切换开销**：进程和线程切换时，需要切换上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，各种页表、打开的文件等都需要切换，耗费资源较大，效率要差一些。 
>
> - **进程切换**：每个进程的状态、寄存器、内存管理信息、打开的文件描述符等。涉及到内存空间的切换，可能需要进行上下文的更新、页表的更改等
> - **线程切换**：只需保存和恢复线程的状态（如寄存器、程序计数器、堆栈指针等），而不需要涉及整个进程的内存管理信息
>
> 
>
> **并发性：**进程的并发性较低，线程的并发性较高。
>
> 
>
>  **健壮性**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃导致整个进程都死掉。所以多进程要比多线程健壮
>
> 



## 锁

### 死锁

> **死锁**：由于两个或两个以上的进程由于竞争资源而导致进程都无法执行的情况
>
> 
>
> **产生的条件**：互斥、不可抢占、请求与保持、循环等待 
>
> 
>
> **如何避免**：破坏不可抢占条件（可以让优先级高的进程抢占优先级低的进程的资源）、破坏请求与保持条件（当进程申请不到自己所需要的的资源时，必须释放掉自己所持有的资源）、破坏循环等待条件（进程只能往前申请资源，不能往后申请资源） 
>
> 
>
> **如何预防**：有序资源分配法、银行家算法
>
> 
>
> **如何查看？**
>
> - 增加日志：在程序中添加详细的日志记录，尤其是在获取和释放锁的地方。通过分析日志，可以查看死锁发生的情况。
>
> - 调试工具：使用调试器（如 `gdb`）调试程序，通过查看线程的状态和持有的锁来分析死锁
>
> - Valgrind 的 `Helgrind` 工具是另一个常用的死锁检测工具。









### 乐观悲观

> ### 乐观锁（Optimistic Locking）
>
> **基本思想**：乐观锁的核心思想是“假设不会发生并发冲突”，因此在操作资源之前不加锁，只有在提交时才会检查是否有冲突发生。
>
> **工作流程**：
>
> 1. **读取数据**：读取当前版本的数据。
> 2. **执行操作**：在内存中执行数据的更新操作，而不加锁。
> 3. **校验冲突**：在提交操作时，检查在读取和更新期间，数据是否被其他事务修改。如果数据未被修改，则提交操作成功；如果数据已被修改，则操作失败，通常需要重试。
>
> **实现方式**：
>
> - 版本号控制：每次读数据时带上一个版本号，提交更新时检查版本号是否变化。
> - 时间戳控制：每次更新操作都会比较当前时间戳和上次操作的时间戳。
>
> **适用场景**：
>
> - 适用于读多写少的场景，因为冲突较少，避免了锁的开销，提高了系统的并发性能。
>
> **优点**：
>
> - **高并发性能**：因为没有加锁，操作之间不会产生等待，提高了系统的并发性能。
> - **减少锁的开销**：特别是在大量读操作的场景下，减少了不必要的锁操作。
>
> **缺点**：
>
> - **失败重试**：在发生并发冲突时，操作会失败并需要重试，可能导致性能下降。



> ### 悲观锁（Pessimistic Locking）
>
> **基本思想**：悲观锁的核心思想是“假设会发生并发冲突”，因此在操作资源之前就对其加锁，以防止其他事务对资源进行修改。
>
> **工作流程**：
>
> 1. **读取数据并加锁**：在读取数据时对其加锁（通常是排他锁），防止其他事务同时读取或修改。
> 2. **执行操作**：在锁的保护下安全地执行数据操作。
> 3. **提交或回滚**：操作完成后，提交更改并释放锁。
>
> **实现方式**：
>
> - 数据库锁机制：通过数据库提供的锁机制（如行锁、表锁）来实现悲观锁。
> - 线程间锁：在多线程编程中，可以使用互斥锁（Mutex）等机制来实现悲观锁。
>
> **适用场景**：
>
> - 适用于写多读少或冲突较多的场景，因为冲突频繁时，乐观锁的失败重试成本较高，而悲观锁能有效避免数据冲突。
>
> **优点**：
>
> - **防止冲突**：在操作资源时加锁，防止其他操作修改资源，确保数据的完整性和一致性。
>
> **缺点**：
>
> - **降低并发性能**：由于资源被锁定，其他操作必须等待锁释放，可能导致系统性能下降。
> - **可能引发死锁**：如果多个操作尝试获取不同资源的锁，且这些锁的顺序不一致，可能会引发死

## 线程安全

### 原因

> 
>
> 第一，线程是==抢占式执行==，线程之间的调度之间充满不确定性，和随机性。（这就是根本原因）。
>
> 
>
> 第二，==多个线程同时读取和修改共享数据时，导致最终结果不确定==。例如，两个线程同时对同一个变量进行递增操作，但由于操作不是原子性的，可能导致最终结果不正确。
>
> 
>
> 第三点，针对变量的操作不是原子性的，就是说==一个操作还可以分成好几小部分来执行，这个容易出错==。
> 
>

### 解决

#### 锁（[mutex](https://www.cnblogs.com/vLiion/p/17796865.html)）

```c
void increment() {
    for (int i = 0; i < 1000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        counter++; // 保护临界区，防止竞态条件
    }
}

//std::unique_lock<std::mutex> lock(queueMutex); 可以lock(mutex, std::defer_lock); // 延迟加锁，显示解锁
```

> **使用场景**: 当需要保护[共享资源](https://so.csdn.net/so/search?q=共享资源&spm=1001.2101.3001.7020)不被多个线程同时修改时使用。
>
> 互斥锁当一个线程占用锁时，其他线程必须等待该锁被释放
>
> 锁住某个互斥锁的线程必须是解锁它的线程。也就是说，一个线程不能解锁由另一个线程锁住的互斥锁



#### 原子操作

```c
std::atomic<int> counter(0);
void increment() {
    for (int i = 0; i < 1000; ++i) {
        counter++; // 原子操作，线程安全
    }
}
```

#### **memory_order**

==在线程中执行多个原子操作时，会进行重排序==，以提高性能，因此会产生不可预见的结果

> - **memory_order_relaxed:** 可对应load和store操作。保障原子性和可见性，不保障顺序性
>
>   
>
> - **memory_order_acquire**: 仅对应于load操作，保障原子性和可见性，及部分的顺序性(后面的操作不能跑到该指令的前面去) 
>
>   保证当前线程的读取操作（读数据的线程）不会被重排序到该操作之前
>
>   
>
> - **memory_order_release：**仅对应于store操作，保障原子性和可见性，及部分的顺序性(前面的操作不能跑到该指令的后面去)
>
>   保证当前线程的写入操作（写数据的线程）不会被重排序到该操作之后
>
>   
>
>   原文链接：https://blog.csdn.net/qq_41634872/article/details/128335062



#### [condition_variable](https://www.jb51.net/program/299603ugo.htm)

> ```
> std::unique_lock<std::mutex> lock(queueMutex);
> 	构造会上锁，析构自动释放
> 
> condition.wait(lock, [this] {return stop || !tasks.empty();});
> 	true会尝试往下运行
>         当 pred 为 true收到通知才会往下运行，并再次尝试获取锁。
>         当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，同时释放锁
> ```



# ==设计模式==



**依赖倒置原则**是软件开发中的一项重要设计原则，‌旨在通过解耦和提高灵活性来构建可插拔的系统。‌基于两个关键概念：‌高层模块不应该依赖低层模块，‌二者都应该依赖其抽象；‌抽象不应该依赖细节，‌细节应该依赖抽象。‌简而言之，‌依赖倒置原则要求我们通过抽象来将高层和低层模块连接起来，‌而不是直接依赖于具体的实现。‌

### 单例设计模式

项目中的某一个类只需要唯一的一个实例，即仅创建一次

使用单件模式，确保使用者也只能创建出一个实例



**懒汉模式**

```c
#include <iostream>
using namespace std;

class Singleton {
// 构造函数声明私有，否则外部也可以构建
private:
    Singleton();
    Singleton(const Singleton &other);
       // 禁用拷贝构造函数和赋值运算符
    Singleton(const Singleton& other) = delete;
    Singleton& operator=(const Singleton& other) = delete;
public:
    static Singleton *getInstance();
    static Singleton *m_instance;
};

// 
Singleton *Singleton::getInstance() {
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}

```

**线程安全版本**

**原子操作**

```c

// C++11，使用原子操作
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton *Singleton::getInstance() {
    // tmp不会被reorder
    Singleton *tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire); // 获取内存fence

    if (tmp == nullptr) {
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if (tmp == nullptr) {
            tmp = new Singleton();
            std::atomic_thread_fence(std::memory_order_release); // 释放内存fence
            m_instance.store(std::memory_order_relaxed);
        }
    }
    return tmp;
}
https://zhuanlan.zhihu.com/p/625067062
```

**饿汉模式**

```c
#include <iostream>
using namespace std;
class Singleton
{
private:
    static Singleton* ptr;
    Singleton(const Singleton & other) = delete;
    Singleton operator=(const Singleton & other) = delete;
    Singleton(){};
    class Des
    {
    public:
        ~Des()
        {
            if(Singleton::ptr != NULL)
            {
                delete Singleton::ptr;
                Singleton::ptr = NULL;
            }
        }
    };
    static Des des;
public:
    static Singleton* instance()
    {
        return ptr;
    }
};

Singleton* Singleton::ptr = new Singleton();


```



### 工厂模式

**问题**

> 但是需要构建不同的子类，由于需求的变化，导致对象的具体类型经常变化
>
> 造成了类间依赖关系的不稳定，违反了DIP（依赖倒置原则），是不推荐的情况。

**作用**

> 1.  ‌**提高系统的可扩展性**‌：这有助于保持系统的灵活性，使得扩展变得更加容易。
> 2.  **减少修改量**‌：提供了统一的接口来创建对象，避免在代码中直接使用`new`操作符创建对象，降低了代码的耦合度
> 3.  **统一管理对象创建**‌：统一管理所有对象的创建过程，确保对象的创建符合一定的标准和规范，从而提高代码的质量和可维护性。

**解决方法**

> - 使用工厂模式：实现一个方法，绕开new，同样返回一个对象。定义一个用于创建对象的接口，让子类决定实例化某个类。
>- 用于隔离类对象的使用者和具体类型之间的耦合关系
> - 通过面向对象，将创建具体对象的工作延迟到子类
> - 变化被推迟到更上层的MainForm创建的时候

```c
class ISplitter{
public:
    virtual void split()=0;
    virtual ~ISplitter(){}
};

class TxtSplitter: public ISplitter {

};

class PictureSplitter: public ISplitter {

};

class VideoSplitter: public ISplitter {

};


class MainForm : public Form
{
public:
    void buttonClick() {
        // 没有绕开具体类
        ISplitter* splitter = new BinarySplitter();
        splitter->split();
    }
};
```

**简单工厂模式**

```c
using namespace std;
enum type
{
    Txt,
    Picture,
    Video,
};

class ISplitter
{

};
class TxtSplitter: public ISplitter {

};

class PictureSplitter: public ISplitter {

};

class VideoSplitter: public ISplitter {

};

class SplitterFactory
{
public:
    ISplitter* CreateSpitter(type type)
    {
        switch(type)
        {
            case Txt:
                return new TxtSplitter();
            case Picture:
                return new TxtSplitter();
            case Video:
                return new TxtSplitter();
            default:
                return nullptr;
        }
    }
};

// MainForm不再依赖具体类
class MainForm {
private:
    SplitterFactory* factory;
public:
    MainForm(SplitterFactory* factory) {
        this->factory = factory;
    }
    void buttonClick() {
        // 多态new
        ISplitter* splitter = factory->CreateSpitter(Txt);
        splitter->split();
    }
};
```



**工厂模式**

```c
class VideoSplitterFactory: public SplitterFactory {
public:
    virtual ISplitter* CreateSpitter() {
        return new VideoSplitter();
    }
};

// MainForm不再依赖具体类
class MainForm {
private:
    SplitterFactory* factory;
public:
    MainForm(SplitterFactory* factory) {
        this->factory = factory;
    }
    void buttonClick() {
        // 多态new
        ISplitter* splitter = factory->CreateSpitter();
        splitter->split();
    }
};
```



**抽象工厂**

使用抽象工厂：工厂不再单一生产单个对象，而是将一系列操作放进一个工厂，都由一个工厂生产，故名抽象工厂

```c
// 数据库相关基类
class IDBConnection {

};

class IDBCommand {

};

class IDataReader {

};

// 抽象工厂
class IDBFactory {
public:
    virtual IDBConnection* CreateDBConnection() = 0;
    virtual IDBCommand* CreateDBCommand() = 0;
    virtual IDataReader* CreateDataReader() = 0;
};
```

### 观察者模式

> 观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种**一对多**的依赖关系，使得一个对象状态的改变能够自动通知并更新多个依赖它的对象。观察者模式在事件驱动系统和发布-订阅模式中非常常见。
>
> \- **Subject（主题/被观察者）**：被观察的对象状态发生变化时，它会通知所有的观察者。主题通常维护一个观察者列表，并提供注册（attach）和移除（detach）观察者的方法。
>\- **Observer（观察者）**：观察者是那些需要在主题状态改变时得到通知的对象。每个观察者都实现了一个接口，该接口定义了一个更新方法，用于在主题发生变化时接收通知并执行相应操作。



> ### 工作流程
>
> 1. **观察者注册**：观察者（Observer）向主题（Subject）注册，以便在主题状态发生变化时收到通知。
>2. **状态变化**：当主题的状态发生变化时，它会遍历其内部维护的观察者列表，通知所有已注册的观察者。
> 3. **更新通知**：每个观察者接收到通知后，通过调用自己的更新方法来获取主题的最新状态，并进行相应的处理。
> 



> ### 典型应用场景
>
> \- **GUI事件处理**：在图形用户界面编程中，当用户操作某个控件（如按钮）时，其他控件需要响应这个事件，通常通过观察者模式实现。
>\- **模型-视图-控制器（MVC）架构**：在MVC架构中，模型（Model）可以作为主题，视图（View）作为观察者。当模型状态发生变化时，视图会自动更新以反映最新的状态。
> \- **事件驱动的系统**：在一些事件驱动的系统中，比如订阅-发布系统，发布者（主题）将事件通知给订阅者（观察者）。



> ### 观察者模式的优点
>
> \- **松耦合**：观察者模式将主题和观察者解耦，使得主题只需知道观察者的接口，而不需要了解具体的观察者是谁。这种松耦合结构有利于系统的扩展和维护。
>\- **动态订阅**：观察者可以在运行时动态地注册和取消订阅，使得系统更加灵活。
> 
> ### 观察者模式的缺点
>
> \- **可能导致性能问题**：如果有大量的观察者，通知所有观察者可能会导致性能问题，尤其是在同步通知的情况下。
>\- **可能导致意外更新顺序**：在某些情况下，观察者的更新顺序可能会导致意外的行为，特别是当多个观察者之间存在依赖关系时。

```c
#include <iostream>
using namespace std;

class FileSplitter {
private:
    string m_filePath;
    int m_fileNumber;
    ProgressBar* m_progressBar;

public:
    FileSplitter(string& filePath, int fileNumber, ProgressBar* progressBar):
        m_filePath(filePath), 
        m_fileNumber(fileNumber), 
        m_progressBar(progressBar) {
    }

    void split() {
        for (int i = 0; i < m_fileNumber; ++i) {
            m_progressBar->setValue();
        }
    }
};

// 主逻辑
class Form {};

class TextBox {
public:
    string getText() {
        return "";
    }
};

class ProgressBar {
public:
    void setValue() {}
};

class MainForm: Form {
private:
    TextBox* txtFilePath;
    TextBox* txtFileNumber;
    ProgressBar* progressBar;

public:
    void buttonClick() {
        string filePath = txtFilePath->getText();
        int fileNumber = atoi(txtFileNumber->getText().c_str());
	//把进度条传进去更新
        FileSplitter* splitter = new FileSplitter(filePath, fileNumber, progressBar);
        splitter->split();
    }
};
```

- 可以独立改变目标与观察者（松耦合）
- 目标发送通知时，无需指定观察者，只管通知机制，而通知自动传播
- 观察者自己决定是否订阅通知

```c
#include <iostream>
#include <vector>
using namespace std;

class IProgress {
public:
    virtual void DoProgress(float value) = 0;
    virtual ~IProgress() {}
};

class FileSplitter {
private:
    string m_filePath;
    int m_fileNumber;
    // 抽象通知机制
    IProgress* m_iprogress;
    // 多个观察者使用容器保存
    //vector<IProgress*> m_iprogressVector;

public:
    FileSplitter(string& filePath, int fileNumber, IProgress* iprogress):
        m_filePath(filePath), 
        m_fileNumber(fileNumber), 
        m_iprogress(iprogress) {
    }

    void split() {
        for (int i = 0; i < m_fileNumber; ++i) {
            m_iprogress->DoProgress(i);
            // 多个观察者使用容器保存
        }
    }

    // 多个观察者
    void add() {}

    void remove() {}
};

// 主逻辑
class Form {};

class TextBox {
public:
    string getText() {
        return "";
    }
};

class ProgressBar {
public:
    void setValue() {}
};

class MainForm: public Form, public IProgress {
private:
    TextBox* txtFilePath;
    TextBox* txtFileNumber;
    ProgressBar* progressBar;

public:
    void buttonClick() {
        string filePath = txtFilePath->getText();
        int fileNumber = atoi(txtFileNumber->getText().c_str());

        // 直接传递this比较重要
        FileSplitter* splitter = new FileSplitter(filePath, fileNumber, this);

        splitter->split();
    }

    // 不论有多少个观察者，都可以实现自己的通知机制
    virtual void Doprogress(float value) {
        progressBar->setValue();
    }
};
```

可以分开功能，FileSplitter只需要处理之后通知观察者，  Mainwindows只需要重写Doprogress然后将自己添加到FileSplitter的观察者



# ==网络==



**响应时间** **RTT( round-trip time)**是数据流往返的网络耗时，我们一般的http请求与服务端的交互时间

 **TTL**（Time to Live，生存时间）防止数据包在网络中无限循环。每经过一个路由器，TTL 的值都会减 1

**MSL**（Maximum Segment Lifetime） 是 TCP 协议中的一个概念，表示 TCP 段在网络中可以存在的最大时间。它是防止旧的、过期的 TCP 段干扰新的连接的重要机制\

**MSL 应该要大于等于 TTL 消耗为 0 的时间**

## 基础知识和头部长度结构

> - [IP头部结构](https://blog.csdn.net/weixin_45583303/article/details/119984861#IP_1)
> - [TCP头部结构](https://blog.csdn.net/weixin_45583303/article/details/119984861#TCP_116)
> - [UDP头部结构](https://blog.csdn.net/weixin_45583303/article/details/119984861#UDP_147)
> - [TCP和UDP的区别](https://blog.csdn.net/weixin_45583303/article/details/119984861#TCPUDP_159)
> - [MAC地址、IP地址、端口号](https://blog.csdn.net/weixin_45583303/article/details/119984861#MACIP_168)
> - [数据传输过程图解](https://blog.csdn.net/weixin_45583303/article/details/119984861#_190)
> - 

> IP的总长度 - IP的头部长度- TCP的头部长度（20Bytes） = TCP的Data的长度
>
> 
>
> **IP头部：**
>
> - IP头部的标准长度为**20字节**。但由于IP头部可能包含可选字段，这些字段可以使IP头部的长度增加到最多**60字节**。
> - ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fd9e55e5aa6112e8e6528c29ef76825b.png)
>
> **UDP头部：**
>
> - UDP头部的长度是固定的，为**8字节**。
> - <img src="https://i-blog.csdnimg.cn/blog_migrate/71f3ea7e179beb9ae49d9991ddc7fbed.png" alt="在这里插入图片描述" style="zoom: 80%;" />
>
> **TCP头部：**
>
> - TCP头部的最小长度为**20字节**。同样，TCP头部也可以包含可选字段，因此TCP头部的长度可以增加，最大为**60字**
> - <img src="https://i-blog.csdnimg.cn/blog_migrate/199762dd7ebc7085c5f6f917ff8c9834.png" alt="在这里插入图片描述" style="zoom: 80%;" />
>
> 

## 网络模型

![img](https://img-blog.csdnimg.cn/direct/763e50ee0555427db1fe61fd1fe4e32e.jpeg)

OSI(Open System InterConnection)开放式系统互联

> **应用层**
> 直接为用户提供服务,如HTTP、FTP、STMP(邮件服务)、DNS、Telnet(远程控制)等
> **表示层**
> 将应用层的数据转换为OSI模型支持的数据格式,还提供数据加密/解密、压缩/解压缩的功能
> **会话层**
> 管理两个实体之间的会话状态,提供寻址功能,如根据ip地址建立两台主机之间的连接
> **传输层**
> 传输层的主要作用是确保数据正确的传输,可在此层进行流量控制和错误处理。分为面向连接(TCP)和面向无连接(UTP)两种
> **网络层**
> 提供寻址功能,通过路由算法选择最合适的路径传输报文
> **数据链路层**
> 建立和管理节点之间的链路,接收上层数据解析成比特流发送给物理层
> **物理层**
> 光缆、电缆等现实世界中存在的物理硬件,实现计算机节点之间的比特流的透明传输

## TCP和UDP不同

> 1. 
>
>    ‌**连接方式**‌：
>
>    - TCP是面向连接的协议，在进行数据传输之前，需要通过三次握手来建立连接。这种连接方式确保了数据的可靠传输。
>    - UDP则是无连接的协议，不需要预先建立连接就可以直接发送数据包。这种无连接的特性使得UDP在某些情况下非常高效。
>
> 2. 
>
>    ‌**可靠性**‌：
>
>    - TCP提供了可靠的数据传输服务，通过重传机制和确认机制避免数据丢失或损坏，保证了数据的可靠性和顺序性。
>    - UDP则不提供可靠性保证，数据传输不可靠，数据包可能会在传输过程中丢失或乱序。
>
> 3. 
>
>    ‌**数据传输方式**‌：
>
>    - TCP是基于字节流的传输协议，数据被看作是一个连续的字节流，没有明显的消息边界。
>    - UDP是基于数据报的协议，每个UDP数据包都是独立的，有明确的边界。
>
> 4. 
>
>    ‌**速度与效率**‌：
>
>    - 由于TCP的可靠性机制，如确认应答和重传等，它通常比UDP慢一些。
>    - UDP由于没有连接建立和维护的开销，以及不需要确认应答，因此传输速度更快。
>
> 5. 
>
>    ‌**首部开销**‌：
>
>    - TCP的首部开销较大，为20字节，携带了用于保证连接和数据传输可靠性的信息。
>    - UDP的首部开销较小，仅为8字节，只携带了最基本的信息。
>
> 6. **使用场景**
>
>    UDP的优点是块，报头开销比TCP少，没有TCP的繁琐机制，数据来了就发，有多快发多块，只管输出不管结果，网络条件差时会导致部分包的丢失。适用于==游戏、视频==等对实时性要求高，容许丢失的应用 
>
>    TCP是面向连接保证可靠交付的，使用一系列机制保证 无损 不丢失 按序 不重复到达， 适用于高可靠性要求的应用，如浏览器向Ser获取资源使用http基于TCP，保证资源无损，邮件服务器使用SMTP基于TCP，保证发送和接收的邮件不出错 
>
>    ==远程登陆、超文本、文件、身份信息、重要内容==
>
> 

## TCP

### 头部

![TCP 头格式](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)



### TCP 三次握手过程是怎样的？

TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:50%;" />



> - 一开始，客户端和服务端都处于 `CLOSE` 状态。服务端主动监听某个端口，处于 `LISTEN` 状态
> - 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。
> - 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。
> - 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
> - 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。
>
> **第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。



> ### 为什么不是两次
>
> ![两次握手无法阻止历史连接](https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png)
>
> 可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止 掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。
>
> 
>
> 接下来，以三个方面分析三次握手的原因： 
>
> 三次握手才可以阻止重复==历史连接的初始化（主要原因）== 
>
> 三次握手才可以同步双方的初始序列号
>
>  三次握手才可以避免资源浪费



### TCP四次挥手过程是怎样的？

![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

> ![image-20240904214828785](E:\codenotes\JOB\Interview\img\image-20240904214828785.png)
>
> ![image-20240904221321619](E:\codenotes\JOB\Interview\img\image-20240904221321619.png)







### 序列号的计算

![image-20240823151453720](.\img\image-20240823151453720.png)

序列号等于上一个应答号



公式一：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文 是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。 

公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。

### tcp是如何保证可靠性的

（校验和，确认应答，确认序号，超时重传，流量控制，拥塞控制）



### 可读、可写

> ### 不可读状态
>
> 1. **连接关闭或断开**：
>    - 如果远程端点==正常关闭连接==，本地端的 `recv` 操作会返回 0，表示对方已经关闭连接
>    - 当连接被关闭时，文件描述符仍然有效，但你将无法读取数据。你应检查 `recv` 返回值为 0 来确认连接是否关闭。
> 2. **网络问题**：
>    - 如果发生==网络故障或断开==（例如网络断开或对方主机不可达），读取操作可能会被阻塞，直到网络问题解决或连接超时。在这种情况下，读取操作将变得不可读，通常表现为读取阻塞或 `recv` 返回错误码（如 `-1`）。
> 3. **非阻塞模式下的读取操作**：
>    - 如果文件描述符设置为非阻塞模式，并且没有数据可读，那么 `recv` 调用将会立即返回 `-1` 并设置 `errno` 为 `EAGAIN` 或 `EWOULDBLOCK`。这表示当前没有数据可读取，即不可读
>
> ### 不可写状态
>
> 1. **连接关闭或断开**：
>    - 如果本地端或远程端调用了 `shutdown`（例如 `shutdown(SHUT_WR)`）==关闭了写半部分==，这会导致写操作变得不可写。这种情况下，写操作会返回 `-1` 并设置 `errno` 为 `EPIPE`（管道破裂），表示连接已经被关闭，不能再写入数据。
> 2. **网络问题**：
>    - ==TCP 堵塞==（网络拥塞导致的缓冲区满）也可能导致写操作变得不可写。你可能会遇到 `send` 调用阻塞，或者返回 `-1` 并设置 `errno` 为 `EAGAIN` 或 `EWOULDBLOCK`（在非阻塞模式下）。
> 3. **应用层流量控制**：
>    - TCP 协议自身具有流量控制机制。如果==接收端处理速度较慢，发送端的发送缓冲区==可能会满，这时写操作会被阻塞，直到接收端处理并释放缓冲区空间。在这种情况下，写操作暂时不可写。
> 4. **非阻塞模式下的写操作**：
>    - 如果文件描述符设置为非阻塞模式，并且==发送缓冲区已满==，`send` 调用会立即返回 `-1` 并设置 `errno` 为 `EAGAIN` 或 `EWOULDBLOCK`，表示当前无法进行写操作，即不可写。
>
> ### 检测可读可写状态
>
> - **`select`、`poll` 和 `epoll`**：
>
>   - 使用这些 I/O 多路复用机制可以检测文件描述符是否有可读或可写事件发生。
>
>   - 例如，使用 `select` 可以监控文件描述符的读写状态：
>
>     ```c
>     c复制代码fd_set read_fds, write_fds;
>     FD_ZERO(&read_fds);
>     FD_ZERO(&write_fds);
>     FD_SET(fd, &read_fds);  // 监控可读事件
>     FD_SET(fd, &write_fds); // 监控可写事件
>                                                                                                             
>     int result = select(fd + 1, &read_fds, &write_fds, NULL, NULL);
>                                                                                                             
>     if (result > 0) {
>         if (FD_ISSET(fd, &read_fds)) {
>             // 连接可读
>         }
>         if (FD_ISSET(fd, &write_fds)) {
>             // 连接可写
>         }
>     }
>     ```

### [重传，滑动窗口，流量拥塞控制](https://www.xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6)



> ## **滑动窗口**
>
> 是让服务器没有ack但是客户端可以继续发
>
> TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据
>



> ## **流量控制**
>
> 是服务器接受也ack了，但是缓充区没读，所以反馈让客户端调整发生窗口大小
>
> > 发送方不能无脑的发数据给接收方，要考虑接收方处理能力。 
> >
> > 如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流 量的无端的浪费。 
> >
> > 为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制 发送的数据量，这就是所谓的流量控制。
>

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/22.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

> ## **拥塞控制**
>
> > 为什么要有拥塞控制呀，不是有流量控制了吗？ 前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什，也就是**发生了超时重传，就会认为网络出现了拥塞。**

> - 当发送窗口swnd小于慢开始门限时，使用==慢开始算法(指数增长）== 
>
> - 当发送窗口swnd大于慢开始门限时，停止使用慢开始算法而改用==拥塞避免算法（线性加1）== 
>
> - 超时重传，出现拥塞，慢开始门限值更新为发生拥塞时的==拥塞窗口值的一半，拥塞窗口值减少为1，重新开始慢开始算法== 
>
> - 发送方一旦受到3个重复确认，就知道丢失了个别报文段，立即重传相应报文段，执行快恢复算法：发送方将==慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，然后开始执行拥塞避免算法==（让拥塞窗口值按线性加1的规律增大）
>
> ![image-20240905101658645](E:\codenotes\JOB\Interview\img\image-20240905101658645.png)

### 粘包

> TCP粘包是指发送方在发送数据时，将多个小数据包粘成一个大数据包发送给接收方 解决方法：
>
> 1、关闭Nagle算法（小合大）
>
>  2、发送定长数据包 
>
> 3、加入\r\n标记 4、数据包头加上数据包长度

### 队头阻塞

![image-20240912200305518](E:\codenotes\JOB\Interview\img\image-20240912200305518.png)



#### 队头阻塞优化http2

![image-20240912200856196](E:\codenotes\JOB\Interview\img\image-20240912200856196.png)







## IP

### arp

ARP 在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机==「路由表」==确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。 

由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 ARP 协议，求得下一跳的 MAC 地 址。简单地说，

ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的。 主机会通过==广播发送 ARP 请求==，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中 的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。

 操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址，

> ARP表帮助找到对应的MAC地址   路由表是下一条ip

## HTTP

### 状态码

> HTTP的状态码含义： 1、1xx：表示连接成功了，并继续等待下一次的连接，如100 2、2xx：表示连接成功，并返回响应体，如200 3、3xx：表示重定向 4、4xx：表示客户端出现错误，如404; 5、5xx：表示服务器出现错误，如505

### GET POST

> 1.最明显的功能用途不同，GET用于查询/获取数据，POST用于提交或修改数据 
>
> 2.GET有长度限制(2048字节)，POST没有长度限制 
>
> 3.GET的参数会附在url之后，以?分隔url和传输的数据，而POST的内容会放在请求体之中。 
>
> 4.GET是明文传输，可以直接在url中看到信息，而POST传输的数据无法直接看到
>
> 5.GET请求会保存在浏览器历史记录中，会被浏览器主动缓存，而post不会，除非手动设置
>
> 6。GET请求的参数类型只接受ASCII字符，而Post没有限制 ... 



## HTTPS

### 和http区别

1. ==HTTP是基于TCP的，而HTTPS是基于TLS==(Transport Layer Security,基于TCP)的
2. HTTP的默认端口号为==80==，而HTTPS的默认端口号为==443==,HTTP只需要创建一次TCP连接，而HTTPS需要创建==两次TCP连接==,当客户端向服务器端请求数据时，服务器会将客户端重定向到该服务器的443端口，进行新的TCP连接，此时服务器会返回一个证书文件，客户端验证证书文件紧接创建对称密钥，之后重新和服务器建立TLS连接，当服务器返回ACK确认之后，连接正式建立，所以，HTTP的安全性很差，而HTTPS的安全性很强。
3. HTTP的往返时间为1RTT，而HTTPS的往返时间为3RTT缺点：HTTPS握手阶段耗费时间，HTTPS的证书需要购买，功能越强大的证书价格更高，HTTPS的加密并不能阻止某些网络攻击



1. **建立TCP连接**：1RTT
2. **SSL/TLS握手**：2RTT（包括ClientHello和ServerHello的往返，以及密钥交换等）



> ### 加密算法： 
>
> RSA 加密算法
>
> 

**TSL/RSA**

浏览器怎么知道证书的签发机构是不是受信任的？因为受信任机构的根证书安装到了系统中，你总得相信微软吧！

> 传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。
>
> 在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息





### 加密流程

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https_rsa.png)

> ### HTTPS 的加密具体流程
>
> HTTPS（超文本传输安全协议）是 HTTP 的安全版本，通过在传输层使用 SSL/TLS 协议来加密数据。其加密流程通常包括以下几个步骤：
>
> 1. **客户端发起请求**：
>    - 客户端（如浏览器）向服务器发送 HTTPS 请求，请求服务器的数字证书。
> 2. **服务器响应**：
>    - 服务器返回其数字证书，其中包含公钥和由受信任的证书颁发机构（CA）签名的信息。
> 3. **证书验证**：
>    - 客户端验证服务器返回的数字证书的有效性，包括检查证书是否过期、是否被吊销以及是否由受信任的 CA 签名。
> 4. **生成会话密钥**：
>    - 客户端生成一个随机的对称密钥（称为会话密钥），并使用服务器的公钥对该密钥进行加密。
> 5. **发送会话密钥**：
>    - 客户端将加密后的会话密钥发送给服务器。
> 6. **服务器解密会话密钥**：
>    - 服务器使用其私钥解密会话密钥，获得对称密钥。
> 7. **加密通信**：
>    - 客户端和服务器使用会话密钥进行后续的对称加密通信，确保数据的机密性和完整性。
> 8. **结束会话**：
>    - 一旦会话结束，双方可以丢弃会话密钥。
>
> ### 9. 为什么要对称加密也要非对称加密
>
> 对称加密和非对称加密各有优缺点，因此 HTTPS 中同时使用这两种加密方式，原因主要包括：
>
> 1. **性能**：
>    - 对称加密算法（如 AES）速度快，适合加密大量数据。非对称加密算法（如 RSA）计算较慢，通常用于较小数据量（如密钥交换）。
> 2. **安全性**：
>    - 非对称加密用于密钥交换，可以安全地在不安全的信道上交换对称加密所需的密钥。即使攻击者截获了公钥，也不能轻易地得到私钥。
> 3. **密钥管理**：
>    - 通过非对称加密，客户端和服务器可以动态生成会话密钥，而不是在每次通信时都使用固定的密钥。这增强了安全性。
> 4. **避免密钥泄露**：
>    - 使用非对称加密可以保证即使对称密钥被截获，由于会话密钥是短期生成的，攻击者无法利用它进行长时间的攻击



### TLS握手

> **TLS 第一次握手： TLS 协议版本，客户端生产的随机数，密码套件列表**

首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。在这一步，客户端主要向服务器发送以下信息：

- （1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。
- （2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。
- （3）客户端支持的密码套件列表，如 RSA 加密算法。

> **TLS 第二次握手：服务器生产的随机数，服务器的数字证书**

服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：

- （1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。
- （2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。
- （3）确认的密码套件列表，如 RSA 加密算法。（4）服务器的数字证书。

> **TLS 第三次握手：客户端会从数字证书中取出服务器的公钥，加密报文的随机数**

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

- （1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。
- （2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
- （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

> TLS 第四次握手：

服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：

- （1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
- （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容

# ==数据结构==

## 红黑树

> #### `std::map` 的 `at` 函数使用
>
> - `myMap.at(1)` 访问键为 `1` 的值，不会引发异常。
> - `myMap.at(3)` 访问一个不存在的键，将引发 `std::out_of_range` 异常

**性质**

> 1. **节点颜色**：
>    - 每个节点要么是红色，要么是黑色。
> 2. **根节点**：
>    - 根节点是黑色。
> 3. **红色节点的限制**：
>    - 如果一个节点是红色，则它的两个子节点必须是黑色。换句话说，红色节点不能有红色的子节点（这也意味着红色节点的子节点是黑色或空）。
> 4. **黑色节点的数量**：
>    - 从任何节点到其每个叶子节点的路径上，必须包含相同数量的黑色节点。这个数量称为**黑色高度**。
> 5. **空节点**：
>    - 空节点（NULL 节点）被认为是黑色
>
> ***一棵标准的红黑树最大的高度不会超过最小高度的两倍***

**优势**

> 1. **自平衡性**：
>    - 红黑树是一种自平衡的二叉搜索树。它通过旋转和重新着色来保持树的平衡，从而确保所有操作的时间复杂度为 O(log⁡n)O(\log n)O(logn)，无论数据的分布如何。
> 2. **对数时间复杂度**：
>    - 查找、插入和删除操作的时间复杂度均为 O(log⁡n)O(\log n)O(logn)，保证了在最坏情况下也能提供良好的性能。
> 3. **有序数据**：
>    - 红黑树自然维护了数据的排序，可以方便地进行范围查询和中序遍历==可以进行有序的遍历（中序遍历等）==

**使用场景**

> 1. **集合和映射**：
>    - C++ 标准库中的 `std::set` 和 `std::map` 通常基于红黑树实现，这使得它们能够在对数时间内完成插入、删除和查找操作。
>
>      
>
> 2. 例如，在 `epoll` 的事件管理中，你可以使用 `std::map` 来存储文件描述符与其关联的事件信息。这样可以快速查找、插入和删除事件
>
>    
>
> 3. **优先级队列**：
>    - 在某些情况下，红黑树可以用于实现优先级队列（尽管通常使用堆更为高效）。
>
>      
>
> 4. **符号表**：
>    - 编译器的符号表管理中，红黑树用于高效地存储和检索符号信息。



##  红黑树 vs AVL 树

- **AVL 树**：
  - AVL 树是另一种自平衡二叉搜索树，最主要的特点是每个节点的左右子树的高度差（平衡因子）最多为 1。
  - 由于 AVL 树比红黑树更加严格地保持平衡，所以在搜索性能上，AVL 树通常略优于红黑树（时间复杂度为 O(log n)）。
  - 然而，这种严格的平衡性也使得在插入和删除时需要更多的旋转操作来维持平衡，因此插入和删除操作的开销比红黑树更大。
- **红黑树**：
  - 红黑树相对于 AVL 树来说，平衡条件更加宽松，因此在插入和删除操作时，需要的旋转操作通常比 AVL 树少。
  - 由于旋转操作较少，红黑树在插入和删除大量数据时的总体性能往往优于 AVL 树。

**选择**：

- **插入少量数据后频繁查找**：如果插入操作不频繁，而查找操作比较多，AVL 树可能是更好的选择，因为它在查找操作上的性能稍优。
- **插入大量数据**：如果需要插入大量数据，并且需要数据保持平衡，红黑树通常是更好的选择，因为它在插入时的旋转操作较少，效率更高。





## 堆

**优势**

> 1. **优先级操作**：
>    - 大根堆（或最大堆）可以在 O(log⁡n)时间内进行插入和删除最大元素操作，适合需要==优先级操作==的数据结构。==快速获取最大最小值==
> 2. **堆排序**：
>    - 可以使用大根堆实现堆排序，时间复杂度为 O(nlog⁡n)，是排序算法的一种。
> 3. **部分有序**：
>    - 大根堆的所有父节点都大于其子节点，适合需要部分有序结构的场景。

**使用场景**

> 1. **优先级队列**：
>    - 大根堆常用于实现优先级队列（如任务调度、事件处理等），它允许快速插入和删除具有最高优先级的元素。
> 2. **堆排序**：
>    - 用于排序算法，通过将数据结构调整为大根堆来进行排序。



## 哈希表

**优势**

> 1. **常数时间复杂度**：
>    - 哈希表在理想情况下，==查找、插入和删除操作的平均时间复杂度为 O(1)==，由于哈希函数将数据分布到不同的桶中，避免了排序和比较的开销。==无序==
> 2. **简单的实现**：
>    - 哈希表的实现通常较为简单，主要涉及哈希函数和处理冲突的策略（如链表法或开放地址法）。
> 3. **适合快速查找**：
>    - 哈希表非常适合需要快速查找的场景，特别是在数据量较大时。

**使用场景**

> 1. **数据去重**：
>    - 哈希表可以快速检查元素是否已存在，常用于数据去重的场景。
> 2. **缓存**：
>    - 用于实现缓存系统，通过哈希表实现快速的键值对查找。
> 3. **字典和计数器**：
>    - 在需要对元素进行计数或维护映射关系的场景中，哈希表提供了高效的解决方案，例如词频统计。





## STL底层

![image-20240829151839347](.\img\image-20240829151839347.png)

![image-20240829152117538](.\img\image-20240829152117538.png)

![image-20240829152126368](.\img\image-20240829152126368.png)

`std::deque`（双端队列）并不是简单的基于一个连续的数组实现的，而是采用了一种更复杂的数据结构，可以理解为“分段连续的动态数组”。这种结构结合了数组和链表的优点

# [==select和epoll==](https://zhuanlan.zhihu.com/p/179071801?utm_id=0)

## 原理和介绍

> ### select
>
> `select` 是一种较老的 I/O 多路复用机制，几乎在所有 UNIX 系统上都可用。
>
> **原理**： 
>
> 1、首先需要构建一个储存文件描述符状态的整数数组，整数类型是fd_set，大小是1024个比特位，每个比特位储存的是该文件描述符的状态，0表示不需要检测，1表示需要检测该文件描述符是否有事件发生。
>
>  2、调用select()函数，监听该数组中的文件描述符的状态，如果有一个或多个文件描述符进行了IO操作，那么这个函数将阻塞，文件描述符的检测是有内核来完成的。 
>
> 3、返回后，将告诉进程有几个文件描述符进行了IO操作
>
> 
>
> ### [epoll](https://www.cnblogs.com/Hijack-you/p/13057792.html)
>
> **原理**
>
> `epoll` 是 Linux 特有的 I/O 多路复用机制，设计用于替代 `select` 和 `poll`，在处理大量文件描述符时性能更佳。epoll在创建时调用epoll_create,创建eventpoll结构体，
>
> **这个结构体中包含**
>
> 就绪列表struct list_head rdlist，存放检测到数据发送改变的文件描述符信息（双向链表）
>
> 和需要检测的文件描述符的信息 struct_root rbr（红黑树）
>
> 
>
> epoll_ctrl() 可以向 epoll 对象中添加、删除、修改要监听的文件描述符及事件，epoll_wait用于检测等待队列，并将就绪的事件数组返回。
>
> 
>
> LT：水平触发，当有FD被添加到就绪队列时，就可以对FD进行IO操作，如果没有操作还是会继续通知 
>
> ET：边沿触发，当有FD被添加到就绪队列时，只会对该套接字通知一次，直到该套接字不再为就绪状态了，期间如果没有对该套接字执行IO操作，内核也不会继续通知，这种模式下仅支持非阻塞套接字
>
> 
>
> **优点**：
>
> 1. **高性能**：`epoll` 使用事件驱动机制，可以高效处理大量文件描述符。它避免了线性扫描文件描述符集，使用 O(1) 的复杂度。
> 2. **没有文件描述符限制**：`epoll` 没有像 `select` 那样的文件描述符数量限制，可以处理大规模连接。
> 3. **支持边缘触发和水平触发**：可以配置为只在有新的事件时通知，减少系统调用次数。
>
> 



## select和epoll的缺点

> ### `select` 的瓶颈
>
> 1. **文件描述符限制**：
>    - `select` 在设计时对监视的文件描述符数量有限制，这通常是由系统的 `FD_SETSIZE` 限制的，默认值可能是1024（可以==通过重新编译内核或调整系统参数来改变==）。这意味着 `select` 处理的并发连接数有限，如果超出限制就无法再使用 `select`。
> 2. **性能开销**：
>    - 每次调用 `select` 时，都会将 `fd_set` 结构从用户态复制到内核态，并将其复制回去。这个操作在文件描述符数量非常大的情况下会产生显著的性能开销。
> 3. **线性扫描**：
>    - `select` 需要扫描整个文件描述符集合，检查哪些文件描述符准备好进行读写。这种线性扫描的方式会在文件描述符数量多时显著影响性能
>
> ### `epoll` 的瓶颈
>
> **缺点**：
>
> 1. **仅限于 Linux**：`epoll` 仅在 Linux 系统上可用，降低了程序的可移植性。
> 2. **使用复杂**：相比 `select`，`epoll` 的使用稍微复杂一些。、
> 3. epoll适合连接多活跃的少、
>
> **需要重新注册文件描述符**：‌在epoll模型下，‌为了保证同一个连接的数据始终落到同一个线程上，‌必须在每次处理完数据后重新把文件描述符加入epoll中，‌这增加了额外的操作复杂度

## **epoll为啥用红黑树**

> - ### 
>
>   - **稳定的 O(log N) 时间复杂度**：红黑树在最坏情况下依然能保证 O(log N) 的查找、插入和删除复杂度。对于 `epoll` 来说，稳定的性能比单纯的速度更为重要，特别是在高负载场景下，这种稳定性可以避免性能的突然下降。
>   - **有序性**：虽然 `epoll` 对有序性的需求不高，但在管理文件描述符时，有序的数据结构有时可以简化内部操作逻辑。
>   - **易于删除与修改**：红黑树的平衡特性使得在删除或修改节点时，不会像哈希表一样面临重哈希等复杂操作。这使得 `epoll` 可以高效地管理动态变化的文件描述符集合。
>
> **与哈希表对比**
>
> - 虽然哈希表在平均情况下的插入、删除和查找操作的时间复杂度是 O(1)，当多个文件描述符被映射到同一个哈希桶中时，哈希表的性能可能会退化为 O(N)。虽然哈希冲突可以通过不同的冲突解决机制来缓解（如链表法或开放寻址法），但它仍然无法保证最坏情况下的性能。这对于需要稳定性能的 `epoll` 来说可能是不理想的

## 异步同步阻塞非阻塞

##### 



> ### [异步阻塞IO（IO多路复用](https://blog.csdn.net/leftfist/article/details/105020228)）
>
> 异步阻塞模型使用内核提供的select函数，避免同步非阻塞模型中轮询等待的问题。
>
> 它最大的优势是可以在一个线程内同时处理多个IO请求：用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的，所以又叫IO多路复用模型。
>
> 虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。以下是改良版：
>
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e15c034c7975733d212fd56e814a9119.png)
>
> 配合线程池使用
>
> 
>
> 1. [IO多路复用、同步、异步、阻塞和非阻塞的区别](https://blog.csdn.net/weixin_45905650/article/details/123181040)：**IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。所以一般划分为同步IO。**
>
> 2. [同步异步与阻塞非阻塞](https://www.chanmufeng.com/posts/storage/Redis/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E.html)
>
> ![image-20240920153914765](E:\codenotes\JOB\Interview\img\image-20240920153914765.png)





> ### [epoll反应堆监听写事件为什么要下树](http://www.baidu.com/link?url=LLljGulX5lz7VNrEJ77erUoJ0gMSi0qVGaL58wINe7VhVjG-m4RSNkVjsZdcZuCVFNWm-oUxcNdN0cqvJqzavt9FYUeR5TV4siU-LbFQ95y)
>
> 
>
> (1) **如此频繁的增加删除不是浪费CPU资源吗？**
> 答：**对于同一个socket而言，完成收发至少占用两个树上的位置。**
> **而交替只需要一个**。
>
> 任何一种设计方式都会有浪费CPU资源的时候，关键看你浪费得值不值，此处的耗费能否换来更大的收益才是衡量是否浪费的标准。
>
> 
>
> (2) **为什么要可读以后设置可写，然后一直交替？**
> 答：服务器的基本工作无非数据的收发，epoll反应堆模型准从TCP模式，**一问一答**。
> 服务器收到了数据，再给予回复，是目前绝大多数服务器的情况。
>
> 
>
> (2-1) 服务器能收到数据并不是一定能写数据
>
> 假设一 ：服务器接收到客户端数据，刚好此时客户端的接收滑动窗口满，我们假设不进行可写事件设置，并且**客户端是有意让自己的接收滑动窗口满的情况**(黑客)。那么，当前服务器将随客户端的状态一直阻塞在可写事件，除非你自己在写数据时设置非阻塞+错误处理
>
> 假设二 ：客户端在发送完数据后突然由于异常原因停止，这将导致一个FIN发送至服务器，如果服务器不设置可写事件监听，那么在接收数据后写入数据会引发异常SIGPIPE，最终服务器进程终止。

> [ 监听 fd 数量限制](https://blog.csdn.net/wusuopuBUPT/article/details/35235957)
>
> 
>
> select使用一个固定大小的数组（通常是位图）来表示文件描述符的集合。这个数组的大小是由 `FD_SETSIZE` 决定的，一般为1024（除非你重新编译内核）,通过执行`ulimit -n 2048`命令修改，
>
> 
>
> epoll 也有监听 fd 数量限制，/proc/sys/fs/file-max指，并且可以通过 sysctl 设置，要使更改在系统重启后仍然生效，你可以将新的值添加到 `/etc/sysctl.conf` 文件中
>
> 
>
> `fs.file-max`：整个系统范围内可以同时打开的文件描述符的最大数量。
>
> `ulimit`修改的是单个用户进程在当前shell会话中的文件描述符数量上限



# ==LINUX==

## Linux常用命令

- **used**：==已经使用的内存==。

- **free**：==可用的空闲内存==。

- **available**：可用的内存，这包括了操作系统缓存，这个值更能代表实际可用内存。

- **fconfig/ip** - 配置网络接口或显示网络接口信息

- **ls** - 列出目录内容

  **cd** - 切换当前工作目录

  **cp** - 复制文件或目录

  **mv** - 移动或重命名文件/目录

  **rm** - 删除文件或目录

  **touch** - 创建空文件或更新文件的时间戳

  **mkdir** - 创建新目录

  **cat** - 显示文件内容

  **grep** - 搜索文本中的模式

  **find** - 查找文件或目录

  **chmod** - 修改文件或目录权限

  **df** - ==显示文件系统磁盘使用情况==

  **du** - ==显示目录或文件的磁盘使用情况==

  **ps** - ==显示当前运行的进程==

  **top** - ==实时显示系统资源使用情况==

  **kill** - 终止进程

mv 源地址   目的   

strcpy   目的地址 源地址

## GDB调试

在开发过程中，你是如何调试的？（gdb，vscode插件）

> b某行打断点 r运行程序，断点停 c继续执行 p打印指定值 n单步运行 q终止调试    

## coredump的原因和排查

> **使用 `gdb`（GNU 调试器）**： `coredump` 文件保存了程序崩溃时的整个内存映像。这包括程序的堆、栈、数据段和代码段的内容。这样，调试器可以恢复程序在崩溃时的状态，查看内存中的数据和指针：
>
> ```
> gdb /path/to/executable /path/to/corefile
> ```
>
> - **在程序调试过程中，可以使用 bt 命令查看程序出错的地方**：`bt`（backtrace）命令是 gdb 调试器中的命令，用于查看程序崩溃时的调用栈信息，帮助定位程序出错的位置。
>
>   ```
>    (gdb) bt
>   ```





## 服务器内存不断增加的解决方法

通常表明有内存泄漏或者不当的内存管理

**Valgrind**：内存泄漏检测工具

**检查代码内存泄漏**

**监控工具**：使用系统工具（如 `top`、`htop`）监控内存使用情况，查看是否有内存持续增长的趋势。

**内存使用日志**：在应用程序中加入内存使用日志，以帮助分析内存使用情况。

# 项目



## ==X86-minLinuxKernel==

### 项目介绍  难点

> ### 介绍
>
> 设计并实现的一个针对 x86 架构的迷你 Linux 内核，完成了从引导程序、内核加载、中断异
> 常处理到进程管理等核心功能的开发，实现了一个简洁高效的教学级操作系统原型。
> 主要实现的功能有：
>
> * 实现从实模式切换到保护模式，并对操作系统内核的加载；
>
> * 实现对中断和异常的处理，并通过内联汇编函数实现了对常用汇编指令的封装；
>
> * 实现进程的创建、调度和切换；
>
> * 实现进程间的同步和互斥
>
> * 实现信号量和互斥锁；
>
> * 实现分页机制和虚拟内存管理。
>
> * 实现简单的系统调用
>
> 
>
> ### 难点
>
> 应该涉及到比较底层，所以一开始调试困难，一开始的错误比较难发现，然后又涉及到一些汇编和操作系统，硬件的东西，只能查手册，文档，资料，视频
>
> 比较底层，参考资料较少



### gdb调试

> #### 
>
> ![image-20240719173325831](E:\codenotes\JOB\Interview\img\image-20240719173325831.png)
>
> #### ELF 文件
>
> - **用途**：ELF（Executable and Linkable Format）文件是一种包含了丰富调试信息的格式。它不仅包括代码和数据，还包含符号表、调试符号、段表和地址重定位信息等。
> - **调试场景**：当你需要使用 GDB 进行高层次的调试时，ELF 文件非常重要。通过 ELF 文件，你可以在 GDB 中看到源代码、变量名、函数名，能够设置断点、查看调用栈、检查变量的值等。
> - **典型应用**：在操作系统的开发过程中，通常会使用 ELF 文件来加载和调试内核，因为它提供了调试所需的所有符号信息。
>
> #### BIN 文件
>
> - **用途**：BIN 文件是最简化的二进制文件格式，它仅包含裸机代码和数据，没有任何调试信息、段信息或符号信息。
> - **调试场景**：BIN 文件通常用于加载到目标硬件或模拟器中运行。对于最低层次的调试，特别是在你已经完全掌握了代码的内存布局时，BIN 文件可能会用到。但是，由于缺乏调试符号，这种方式的调试通常是基于地址和汇编指令的，难度较大。
> - **典型应用**：在一些低层次的引导程序（bootloader）或裸机程序的开发中，使用 BIN 文件更为常见。你可以将 BIN 文件直接加载到 QEMU 中运行，但如果需要深入调试，通常还是通过 GDB 连接加载 ELF 文件



### [虚拟内存](https://www.xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)

> 1. 操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射 关系，来转换变成物理地址，然后再通过物理地址访问内存。
>    
> 2. 虚拟内存：操作系统为每一个进程分配一个独立的地址空间，但是虚拟内存。虚拟内存与物理内存
>     存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。
> 
> 3. ==为什么要用虚拟内存==：因为早期的内存分配方法存在以下问题：
>     （1）进程地址空间不隔离。会导致数据被随意修改。
>    （2）内存使用效率低。
>    （3）程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定
>    的。
> 
> 4. 使用虚拟内存的==好处==：
>     （1）扩大地址空间。每个进程独占一个4G空间，虽然真实物理内存没那么多。
>    （2）内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止
>    恶意篡改。
>    （3）可以实现内存共享，方便进程通信。
>    （4）可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。
> 
> 5. 使用虚拟内存的==缺点==：
>     （1）虚拟内存需要额外构建数据结构，占用空间。
>    （2）虚拟地址到物理地址的转换，增加了执行时间。
>    （3）页面换入换出耗时。
>    （4）一页如果只有一部分数据，浪费内存  





### [分页机制](https://www.xiaolincoding.com/os/3_memory/vmem.html#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5)

> ### 分段
>
>
> 在分段机制下，虚拟地址由两部分组成：段选择子和段内偏移量。段选择子是一个索引，用于指定要访问的段的起始地址和长度。段内偏移量则表示在该段内的具体位置。
>
> 操作系统会维护一个段表，其中包含了每个段的起始地址和长度信息。当程序访问一个虚拟地址时，操作系统会通过段选择子从段表中找到对应的段描述符，然后根据段描述符中的信息计算出物理地址。
>
> 
>
> 具体的映射过程如下：
>
> - 程序访问虚拟地址，通过段选择子找到对应的段描述符。
>
> - 根据段描述符中的基址和长度信息，计算出段的起始物理地址。
>
> - 将段的起始物理地址与段内偏移量相加，得到最终的物理地址
>
> 分段机制可能会导致内存碎片的问题
>
> ### 分页
>
> 内存分页是将整个虚拟和物理内存空间划分为固定大小的连续内存块，称为页（Page）。在Linux下，每一页的大小通常为4KB。虚拟地址与物理地址之间通过页表进行映射，页表存储在CPU的内存管理单元（MMU）中，从而CPU可以直接通过MMU找到实际访问的物理内存地址。
>
> 虚拟地址与物理地址之间通过页表来映射，如下图：
>
> 
>
> 由于内存空间事先划分为固定大小的页，不会像分段机制那样产生碎片。当释放内存时，以页为单位进行释放，避免了无法利用的小内存块。
>
> 如果内存空间不足，操作系统会将其他正在运行的进程中的"最近未使用"的内存页面暂时存储到硬盘上，称为换出（Swap Out）。当需要时，再将页面加载回内存，称为换入（Swap In）
>
> ### 多级页表
>
> 在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大 约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射 就需要有 4MB 的内存来存储页表。100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。





> - ### 慵懒分配
>
>   #### 原理
>
> - **延迟页表项的分配**：在慵懒分配中，操作系统不会立即为一个进程的所有虚拟地址分配相应的页表项。相反，页表项的分配会被推迟，直到该虚拟地址第一次被访问为止（通常是发生页面缺失时）。
>
> - **延迟内存的实际分配**：类似地，操作系统也不会立即分配物理内存页。只有在某个虚拟页被访问时，才会分配物理内存并更新相应的页表项。
>
> 
>
> #### 过程
>
> **内存访问**：当一个进程尝试访问某个虚拟地址时，处理器首先通过页表查找对应的物理地址。
>
> **页面缺失（Page Fault）**：如果页表中没有该虚拟地址的映射（即页表项不存在或未初始化），则会触发页面缺失异常。
>
> **处理页面缺失**：
>
> - 操作系统捕获到页面缺失异常后，会根据虚拟地址的请求情况判断是否需要分配一个新的页表项。
>
> 
>
> #### 优点
>
> - **减少不必要的内存开销**：只有在需要时才分配页表项和内存，避免了为未使用的地址空间分配不必要的资源。
> - **提高内存使用效率**：通过推迟内存分配，系统可以更有效地利用物理内存。



### 缺页中断和swap

> **Swap**
>
> Swap 机制指的是当物理内存不够用，内存管理单元（Memory Mangament Unit，MMU）需要提供 调度算法来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。
>
> Swap 机制存在的本质原因是 Linux 系统提供了虚拟内存管理机制，每一个进程认为其独占内存空 间，因此所有进程的内存空间之和远远大于物理内存。所有进程的内存空间之和超过物理内存的部 分就需要交换到磁盘上。

>  **缺页中断**
>
>  操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据 以页的方式加载到内存中。上述过程被称为缺页中断，当操作系统发生缺页中断时，就会通过系统 调用将 page 再次读到内存中。





### load引导程序

> 加载引导程序的主要作用和过程：
>
> #### 1. 初始化硬件
>
> 在现代计算机启动过程中，BIOS（或UEFI）会首先进行硬件初始化（如内存、自检等）。完成硬件初始化后，BIOS会将控制权交给第一阶段的引导程序，通常称为 **主引导记录**（MBR）或 **第一阶段引导程序**。
>
> #### 2. 加载引导程序
>
> - **第一阶段引导程序**：BIOS从引导设备的第一个扇区加载这个小型引导程序（通常大小为512字节）。这个程序主要负责从磁盘的特定位置加载更复杂的第二阶段引导程序或直接加载操作系统的内核。
> - **第二阶段引导程序**：如果第一阶段引导程序只负责加载更复杂的引导程序，这个引导程序通常称为第二阶段引导程序。它具有更多的功能，可以加载文件系统、处理器模式的切换等，并最终加载操作系统内核。例如，常见的 GRUB（GRand Unified Bootloader） 就是一个复杂的第二阶段引导程序。
>
> #### 3. 切换处理器模式（可选）
>
> 在某些操作系统中，加载引导程序需要将处理器从实模式（Real Mode）切换到保护模式（Protected Mode）或更高的长模式（Long Mode），以支持更大的地址空间和更多的内存管理功能。
>
> #### 4. 加载操作系统内核
>
> 加载引导程序会定位并加载操作系统内核文件到内存中。通常，它还会传递一些启动参数或硬件信息给内核，以便内核完成进一步的初始化工作。
>
> #### 5. 交出控制权
>
> 在内核加载到内存并完成基本初始化后，加载引导程序会将控制权交给内核，这时操作系统的启动过程正式开始，加载引导程序的任务也就完成了。
>
> ### 总结
>
> 加载引导程序的作用是：
>
> - **初始化必要的硬件组件**。
> - **加载并启动操作系统的内核**或更高级的引导程序。
> - **切换处理器模式**（如果需要）。
> - **将控制权交给操作系统内核**，完成操作系统启动前的所有准备工作

### 进程调度算法

即决定==哪个进程或线程==在给定时刻执行。进程调度和线程调度是操作系统中的关键概念，涉及到如何分配处理器时间，以及如何协调多个执行单元的工作

> 1、 先来先服务
>
> 2、 短作业优先 
>
> 3、最短剩余时间优先 
>
>  4、时间片轮转 
>
> 5、优先级调度 
>
> 6、多级反馈队列 



## ==负载均衡OJ项目==

https://blog.csdn.net/weixin_61508423/article/details/130799512

https://blog.csdn.net/zhu_pi_xx/article/details/130681826

https://www.nowcoder.com/feed/main/detail/7ac71baeae004c169e30b128e375f210?anchorPoint=comment

### 项目介绍 难点 解决

> #### 介绍
>
> 项目名称： 基于负载均衡的在线 OJ 平台（2024.1-2024.5）
> 项目描述： 该项目是 c++开发的基于负载均衡的在线 OJ， 用户可以在浏览器访问各个题目，在编辑区编写
> 代码提交，后端能够自动分配服务器资源，保持平衡的情况下让代码快速运行和提交。 核心是两个模
> 块： 编译与运行模块负责编译并运行服务， OJ 相关模块完成连接数据库、获取题目列表，查看题目、
> 编写题目界面，负载均衡等后端核心业务逻辑。
> 主要工作和涉及技术：
> ⚫ 一致性哈希环算法的负载均衡设计；
> ⚫ 基于 IO 复用和线程池的了解和使用；
> ⚫ 在后端编译服务采用创建子进程的方式编译代码，从而不影响主执行；
> ⚫ 基于 STL 标准库， Boost， cpp-httplib， Mysql，多进程、多线程的开发  

> ### 你在项目中遇到了什么困难？
>
> #### 1. 怎么进行负载均衡
>
> #### 2. 如何防止恶意代码
>
> 资源限制
>
> **setrlimit**(RLIMIT_CPU,&cpu_rlimit);  其中 cpu_rlimit是struct rlimit
>
> **prctl**限制系统调用
>
> 受限根目录
>
> chroot("/restricted") != 0) 
> chdir("/") != 0
>
> ```c
> public:
>         //提供设置进程占用资源大小的接口
>         static void SetProcLimit(int _cpu_limit,int _mem_limit)
>         {
>             //设置CPU时长
>             struct rlimit cpu_rlimit;
>             cpu_rlimit.rlim_cur = _cpu_limit;
>             cpu_rlimit.rlim_max = RLIM_INFINITY;//无限
>             setrlimit(RLIMIT_CPU,&cpu_rlimit);
> 
>             //设置内存大小
>             struct rlimit mem_rlimit;
>             mem_rlimit.rlim_cur = _mem_limit * 1024;//传过来是以KB为单位，我们这里是以B为单位
>             mem_rlimit.rlim_max = RLIM_INFINITY;//无限
>             setrlimit(RLIMIT_AS,&mem_rlimit);
>         }
> 
> void set_seccomp() {
>     struct sock_filter filter[] = {
>         BPF_STMT(BPF_LD + BPF_B + BPF_ABS, offsetof(struct seccomp_data, nr)),
>         BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_exit, 1, 0),
>         BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_read, 2, 0),
>         BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_write, 3, 0),
>         BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_lseek, 4, 0),
>         BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), // 除了 exit, read, write, lseek 以外的调用将被杀死
>         BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW), // 允许 read, write, lseek
>     };
> 
>     struct sock_fprog prog = {
>         .len = sizeof(filter) / sizeof(filter[0]),
>         .filter = filter,
>     };
> 
>     prctl(PR_SET_NO_NEW_PRIVS, 1);
>     prctl(PR_SET_SECCOMP, SECCOMP_SET_MODE_FILTER, &prog);
> }
> 
>  else if (pid == 0) { // 子进程
>         // 设置资源限制
>         SetProcLimit(cpu_limit, mem_limit);
> 
>         // 先调用 chroot
>         if (chroot("/restricted") != 0) { // 替换为实际的受限根目录
>             perror("chroot failed");
>             exit(1);
>         }
>         // 更改工作目录到新的根目录
>         if (chdir("/") != 0) {
>             perror("chdir failed");
>             exit(1);
>         }
> 
>         // 设置 Seccomp 策略
>         set_seccomp();
> 
>         // 进行重定向
>         dup2(_stdin_fd, 0);
>         dup2(_stdout_fd, 1);
>         dup2(_stderr_fd, 2);
> 
>         // 执行程序
>         execl(_execute.c_str(), _execute.c_str(), nullptr);
>         // 如果 execl 失败
>         exit(1);
>     }
> 
> ```
>
> ### 3. 怎么处理报错 
>
> 重定向运行信息
>
>     // 进行重定向，子进程随便执行，执行结果一定会输出到打开的文件当中
>     dup2(_stdin_fd, 0);
>     dup2(_stdout_fd, 1);
>     dup2(_stderr_fd, 2);
>
> 编译
>
> ```c
> static bool Compile(const std::string &file_name) // 编译
>         {
>             pid_t pid = fork();
>             if (pid < 0)
>             {
>                 LOG(ERROR) << "内部错误，创建子进程失败" <<std::endl;
>                 return false;
>             }
>             else if (pid == 0)
>             {
>                 umask(0);
>                 int _stderr = open(PathUtil::CompilerError(file_name).c_str(),O_CREAT | O_WRONLY,0644);
>                 //打开标准错误临时文件，出错就向其中写入错误信息
>                 if(_stderr<0)
>                 {
>                     LOG(WARNING) << "没有成功形成stderr临时文件" << std::endl;
>                     exit(1);
>                 }
>                 dup2(_stderr,2);//我要把old的文件描述符放到new的文件描述符位置
>                 execlp("g++","g++", "-o", PathUtil::Exe(file_name).c_str(),
>                        PathUtil::Src(file_name).c_str(), "-std=c++11","-D","COMPILER_ONLINE",nullptr);
>                 //未替换成功，直接终止
>                 LOG(ERROR)<<"启动编译器g++失败，可能是参数错误"<<std::endl;
>                 exit(2);
>             }
>             else
>             {   
>                 waitpid(pid,nullptr,0);//进程等待，等pid进程，退出结果，等待方式(这里S是阻塞等待)
>                 //编译是否成功,标准就是可执行文件是否存在
>                 if(FileUtil::IsFileExists(PathUtil::Exe(file_name)))
>                 {
>                     LOG(INFO)<<PathUtil::Src(file_name)<<"编译成功"<<std::endl;
>                     return true;
>                 }
>             }
>             LOG(ERROR)<<"编译失败，没有形成可执行程序"<<std::endl;
>             return false;
>         }
> ```
>
> 运行
>
> ```c
>  else if (pid == 0)
>             { //现在对应的是子进程，我们要对子进程的资源做限制
>                 //我们今天重点关心的是运行时长和资源占用  RLIMIT_AS RLIMIT_CPU
>                 SetProcLimit(cpu_limit,mem_limit);
> 
>                 // 进行重定向，子进程随便执行，执行结果一定会输出到打开的文件当中
>                 dup2(_stdin_fd, 0);
>                 dup2(_stdout_fd, 1);
>                 dup2(_stderr_fd, 2);
> 
>                 // 我们现在有的是路径，而不是像g++那样的环境变量当中有的，所以我们选择使用execl
>                 execl(_execute.c_str() /*路径*/, _execute.c_str(), nullptr /*如何执行的可变参数，以nullptr结尾*/);
>                 exit(1);
>             }
> else
>             {
>                 close(_stdin_fd);
>                 close(_stdout_fd);
>                 close(_stderr_fd);
>                 int status = 0;
>                 waitpid(pid, &status, 0);
>                 LOG(INFO) << "运行完毕, info(退出信号):" << (status & 0x7F) << std::endl;
>                 return status & 0x7F; // 有异常返回值一定是>0的值，没有异常返回值就是0
>             }
> ```
>
> ### 完整代码（获得错误信息和防止恶意代码）
>
> ```c
> #include <unistd.h>
> #include <sys/prctl.h>
> #include <linux/filter.h>
> #include <linux/seccomp.h>
> #include <sys/types.h>
> #include <sys/stat.h>
> #include <fcntl.h>
> #include <stdlib.h>
> #include <string.h>
> #include <stdio.h>
> 
> void set_seccomp() {
>     struct sock_filter filter[] = {
>         BPF_STMT(BPF_LD + BPF_B + BPF_ABS, offsetof(struct seccomp_data, nr)),
>         BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_exit, 1, 0),
>         BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_read, 2, 0),
>         BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_write, 3, 0),
>         BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_lseek, 4, 0),
>         BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), // 除了 exit, read, write, lseek 以外的调用将被杀死
>         BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW), // 允许 read, write, lseek
>     };
> 
>     struct sock_fprog prog = {
>         .len = sizeof(filter) / sizeof(filter[0]),
>         .filter = filter,
>     };
> 
>     prctl(PR_SET_NO_NEW_PRIVS, 1);
>     prctl(PR_SET_SECCOMP, SECCOMP_SET_MODE_FILTER, &prog);
> }
> 
> void SetProcLimit(int cpu_limit, int mem_limit) {
>     // TODO: 实现资源限制代码
> }
> 
> int main() {
>     // 父进程代码...
>     pid_t pid = fork();
> 
>     if (pid < 0) {
>         perror("fork failed");
>         exit(1);
>     } else if (pid == 0) { // 子进程
>         // 设置资源限制
>         SetProcLimit(cpu_limit, mem_limit);
> 
>         // 先调用 chroot
>         if (chroot("/restricted") != 0) { // 替换为实际的受限根目录
>             perror("chroot failed");
>             exit(1);
>         }
>         // 更改工作目录到新的根目录
>         if (chdir("/") != 0) {
>             perror("chdir failed");
>             exit(1);
>         }
> 
>         // 设置 Seccomp 策略
>         set_seccomp();
> 
>         // 进行重定向
>         dup2(_stdin_fd, 0);
>         dup2(_stdout_fd, 1);
>         dup2(_stderr_fd, 2);
> 
>         // 执行程序
>         execl(_execute.c_str(), _execute.c_str(), nullptr);
>         // 如果 execl 失败
>         exit(1);
>     }
> else
>             {
>                 close(_stdin_fd);
>                 close(_stdout_fd);
>                 close(_stderr_fd);
>                 int status = 0;
>                 waitpid(pid, &status, 0);
>                 LOG(INFO) << "运行完毕, info(退出信号):" << (status & 0x7F) << std::endl;
>                 return status & 0x7F; // 有异常返回值一定是>0的值，没有异常返回值就是0
>             }
>     // 父进程代码...
>     return 0;
> }
> ```
>
> 







### 为何分模块

（因为编译运行需要的时间长，便于分离部署等，模块化编程）



### 编译运行模块

运行模块怎么运行多个任务的，和oj_server一样也是一个Server类

> **编译过程实现**
>
> 一个C/C++程序源文件，需要经过gcc/g++工具进行预处理、编译、汇编、链接最终形成可执行文件。平时，我们将一个源文件编译形成可执行文件只需要在bash下键入命令`gcc/g++ -o target main.cpp` 一步到位即可。但是现在我们需要在程序中实现这个功能，就需要用到操作系统的系统调用接口：`exec*` 系列系统调用进行**进程程序替换**。

> **运行的实现**
>
> 本质是创建子进程，让子进程去执行可执行文件：
>
> - 在创建子进程时，使用了 `fork()` 来创建子进程。如果 `fork()` 返回的值大于零，表示这是父进程。
> - 父进程在创建完子进程后，通过waitpid()等待子进程结束，并获取其退出状态。
>   - `waitpid()` 的第二个参数 `status` 会保存子进程的退出状态，
>   - `status & 0x7F` 这个操作可以获得子进程的退出信号，如果这个值不为零，说明子进程异常退出。

>  **编译服务器只编译运行一个请求是不是太浪费了，能不能优化一下？**
>
> 多线程，一个服务器多用几个端口



### OJ_server模块



### 负载选择[一致哈希](https://cloud.tencent.com/developer/article/1401185)

> ### 如何实现的负载均衡？
>
>  一致性哈希算法也是使用取模的方法，但是一般取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：
>
>     步骤一：一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；
>     步骤二：接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置
>     步骤三：最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器
>
> ### 为什么要用一致性哈希？普通哈希不行么？
>
> \1. **分布式缓存管理 ** 在线OJ平台可能需要缓存大量数据（如题目数据、用户提交代码的中间结果、运行结果等）
>
> \2. **编译服务器的分布式负载均衡**
>
> \3. **数据分片（题目、用户信息等）**
>
> \4. **日志存储和分析**
>
> \5. **用户请求的分发**
>
> OJ 平台通常需要保存用户的提交数据、运行结果和执行日志。这些文件可以分布式存储在多个存储节点上。使用一致性哈希可以确保用户提交的文件、运行结果等**均匀存储在多个节点**，并在节点变化时只影响少部分文件的存储位置。
>
> - **问题场景**：用户提交的代码、编译日志和测试运行结果数据较大，需要在多节点上分布存储，节点的增减会带来数据迁移问题。
>
> 
>
> ### 怎么迁移数据呢
>
> #### 1. **通过网络请求进行数据传输**
>
> 最直接的方式是通过网络通信将数据从受影响的节点传输到新节点。每个节点都有自己的 IP 地址和通信端口，受影响的节点可以通过 HTTP、RPC 或其他网络协议来传输数据
>
> #### 2. **通过分布式文件系统进行数据复制**
>
> 如果数据存储在一个分布式文件系统中，如 HDFS、Ceph 或其他类似的分布式存储系统，数据迁移可以通过文件复制的方式完成。受影响的节点可以将文件直接复制到新节点负责的存储区域中，完成数据的转移。





```c
// 一致性哈希
#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <functional>
#include <algorithm>

// Hash函数
unsigned int HashFunction(const std::string &key) {
    std::hash<std::string> hash_fn;
    return static_cast<unsigned int>(hash_fn(key));
}

// 一致性哈希类
class ConsistentHash {
private:
    // 虚拟节点的数量
    int virtualNodeCount;
    // 哈希环（使用有序map实现）key是服务器hash值，value服务器节点名称。
    std::map<unsigned int, std::string> hashRing;

public:
    // 构造函数，指定虚拟节点数量
    ConsistentHash(int virtualNodeCount) : virtualNodeCount(virtualNodeCount) {}

    // 添加服务器节点
    void AddNode(const std::string &node) {
        for (int i = 0; i < virtualNodeCount; ++i) {
            std::string virtualNodeName = node + "#" + std::to_string(i);
            unsigned int hash = HashFunction(virtualNodeName);
            hashRing[hash] = node;
        }
    }

    // 删除服务器节点
    void RemoveNode(const std::string &node) {
        for (int i = 0; i < virtualNodeCount; ++i) {
            std::string virtualNodeName = node + "#" + std::to_string(i);
            unsigned int hash = HashFunction(virtualNodeName);
            hashRing.erase(hash);
        }
    }

    // 查找key对应的节点 查找题目对应的服务器节点
    std::string GetNode(const std::string &key) {
        if (hashRing.empty()) {
            return "";
        }
        unsigned int hash = HashFunction(key);
        // 使用upper_bound查找第一个大于等于hash的节点
        auto it = hashRing.upper_bound(hash);
        if (it == hashRing.end()) {
            // 如果没有找到，回到环的第一个节点
            it = hashRing.begin();
        }
        return it->second;
    }

    // 打印哈希环节点信息
    void PrintHashRing() {
        for (const auto &pair : hashRing) {
            std::cout << "Hash: " << pair.first << " Node: " << pair.second << std::endl;
        }
    }
};

```

```c
// // 1. 随机数法
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
 
// 假设每个服务器的标识是一个整数
int loadBalanceRandom(const std::vector<int>& servers) {
    if (servers.empty()) {
        throw std::runtime_error("No servers available");
    }
    // 随机化种子，只需要在程序开始时调用一次
    srand(static_cast<unsigned int>(time(0)));
    // 从服务器列表中随机选择一个
    int index = rand() % servers.size();
    return servers[index];
}
 
int main() {
    // 假设我们有四个服务器，用一个vector来表示
    std::vector<int> servers = {1, 2, 3, 4};
 
    // 执行负载均衡
    int selectedServer = loadBalanceRandom(servers);
    std::cout << "Selected server: " << selectedServer << std::endl;
 
    return 0;
}
```

```c


// 2. 轮询法
 // 遍历找到负载最小的机器
#include <iostream>
#include <vector>
#include <stdexcept>
 
int loadBalanceRoundRobin(std::vector<int>& servers, int& currentIndex) {
    if (servers.empty()) {
        throw std::runtime_error("No servers available");
    }
    int index = currentIndex;
    currentIndex = (currentIndex + 1) % servers.size();
    return servers[index];
}
 
int main() {
    std::vector<int> servers = {1, 2, 3, 4};
    int currentIndex = 0;  // 初始索引为0
 
    // 执行几次负载均衡选择，以演示轮询方式
    for (int i = 0; i < 5; ++i) {
        int selectedServer = loadBalanceRoundRobin(servers, currentIndex);
        std::cout << "Selected server: " << selectedServer << std::endl;
    }
 
    return 0;
}
```



### 哈希冲突

1. 开放地址法
   概念：开放地址法是指当一个关键字映射的位置已经被占用时，会寻找下一个空闲的位置进行存放。查找时，若原位置没有找到，则按照同样的规则继续查找下一个可能的位置。

优点：实现简单，无需额外的数据结构。

缺点：可能会导致某些区域过于密集，影响性能；删除操作复杂。

代码示例：

```c
#include <iostream>
#include <vector>

class OpenAddressingHashTable {
public:
    explicit OpenAddressingHashTable(size_t size) : table(size, -1), used(size, false) {}

    void insert(int key) {
        size_t index = key % table.size();
        while (used[index]) {
            index = (index + 1) % table.size(); // 线性探测法
        }
        table[index] = key;
        used[index] = true;
    }
     
    bool search(int key) {
        size_t index = key % table.size();
        while (used[index]) {
            if (table[index] == key) return true;
            index = (index + 1) % table.size();
        }
        return false;
    }

private:
    std::vector<int> table;
    std::vector<bool> used;
};
```


2. 链地址法（哈希桶）
概念：链地址法是在每个数组位置上挂接一个链表，所有映射到该位置的元素都存储在这个链表中。

优点：冲突少时效率高，支持动态扩容，删除操作简单。

缺点：链表过长时，查找效率降低。

代码示例（基于之前提供的哈希桶示例）：

```c
#include <iostream>
#include <list>
#include <vector>

class HashBucket {
public:
    explicit HashBucket(size_t size = 10) : buckets(size) {}

    void insert(int key, std::string value) {
        size_t index = hashFunction(key);
        buckets[index].push_back({key, value});
    }
     
    std::string search(int key) {
        size_t index = hashFunction(key);
        for (const auto& pair : buckets[index]) {
            if (pair.first == key) {
                return pair.second;
            }
        }
        return "Not Found";
    }
     
    void remove(int key) {
        size_t index = hashFunction(key);
        auto& bucket = buckets[index];
        bucket.erase(std::remove_if(bucket.begin(), bucket.end(),
                                    [key](const auto& p){ return p.first == key; }),
                     bucket.end());
    }

private:
    std::size_t hashFunction(int key) const {
        return key % buckets.size(); // 简单的取模哈希函数
    }

    std::vector<std::list<std::pair<int, std::string>>> buckets;

};

int main() {
    HashBucket hashTable;

    hashTable.insert(10, "Apple");
    hashTable.insert(25, "Banana");
    hashTable.insert(20, "Cherry");
     
    std::cout << "Search 10: " << hashTable.search(10) << std::endl; // 应输出 Apple
    std::cout << "Search 30: " << hashTable.search(30) << std::endl; // 应输出 Not Found
     
    hashTable.remove(20);
    std::cout << "Search 20 after removal: " << hashTable.search(20) << std::endl; // 应输出 Not Found
     
    return 0;

}

```

### cpp-httplib

默认 短连接 阻塞多线程http库

> ### **服务端**
>
> [server类的工作流程基本如下](https://blog.csdn.net/weixin_44545838/article/details/132800974)：
> 1、 搭建tcp服务，注册资源路径与处理方法，并开启监听。
> 2、 创建工作线程，select循环监听，当收到客户端消息，放入jobs中，通知工作线程处理。
> 3、工作线程从jobs中取出待处理请求。
> 4、 处理请求，包含校验、协议解析、根据请求方式分发，最终调用用户注册方法处理上层业务。
>
> ![img](https://i-blog.csdnimg.cn/blog_migrate/a20170789665ad4f3d3329fbe1461468.png)
>

> ### **客户端**
>
> 作为客户端向运行模块发Post时候阻塞IO？？？？不确定
>



> ### 队列满了怎么处理？
>
> - 如果队列已满，你可以选择直接丢弃新请求或排队请求。这需要你在应用逻辑中实现一个策略，比如：
>   - **拒绝新请求**：当队列满时，立即返回 503 错误。
>   - **阻塞新请求**：等待队列有空闲时再处理新请求，但这可能会导致响应延迟



### 判断服务端是否在线的    

RecoveryMachine 所有离线添加到在线  (没调用)

判题的时候尝试连接，连不上会下线



## ==多传感器工业工件缺陷检测系统==

### 项目介绍 解决

> 整体是使用 c++和 python 开发，整体要实现的就是利用工业相机、 结构光相机、采集卡等传感器监测熔覆时数据以及参数。 获得的图像数据利用 YOLOv8 目标检测模型和 SAM 分割模型检测熔覆时产生的气孔，结构光相机获得工件三维形貌，并通过联合标定获得气孔局部点云结构。
>
> 主要工作和涉及技术：
>
> * 深度学习模型的部署
>
> * 负责项目整体框架的搭建； 及所有传感器基于 SDK 的二次开发；
> * 基于 QT 的前端界面的开发，基于 Mysql 数据的存储， 多进程编程；
> * 用激光雷达和相机标定改进的结构光相机和 RGB 相机的联合标定算法。
>
> 

### 难点

> 一开始尝试用结构光相机图片直接检测，发现结构光相机的缺点，然后加了工业
>
> ==空洞很小既要获得高召回率又要点云结构，局部信息==
>
> 看很多设备的开发文档，进行二次开发
>
> ==遇到过python并行难题==
>
> 并且==甲方一直需求在变动==，出差开会
>
> ==双方对各自的领域都不是很了解==

> #### Q:在这个项目中最大的收获
>
> 因为这个项目主要是==我在负责，包括和对方负责人的沟通，界面开发，功能的开发测试都是我在弄==，也去清华那边出差了好几次去调试。再与对面的组员进行对接、沟通过程中与锻炼了与自己合作的能力。项目中用到的很多需求之前没接触过比如QT,标定，传感器看开发文档，也是边学边开发。也锻炼了自己阅读文档的能力，后面自己也要写一个关于这个项目的文档。项目设计的内容也挺多的，比如==传感器之间的标定算法==，看一些设备的文档进行二次开发，==QT的用户界面开发，也涉及到一些多进程的知识==。

### YOLO 

#### 原理

> ## 原理
>
> [面试问题总结——关于YOLO系列（一）](https://blog.csdn.net/qq_45445740/article/details/120265713)
>
> YOLO是一种==one-stage==的目标检测模型， 的主要思想是将目标检测看作一个==单次回归问题==，通过将图像分成网格，每个网格负责预测物体的类别和位置。YOLO 的最大优势是其高效的检测速度，但同时在定位精度和小目标检测方面有所妥协。
>
> 每个边界框用五个预测值表示：x，y，w，h和confidence（置信度）。其中，(x,y)是边界框的中心坐标，w和h是边界框的宽度和高度，这==四个值都被归一化到[0,1]==区间以便于训练。

> **YOLO的整个流程是这样的**
>
> 1. **输入图像**：
>    - 将输入图像调整为==固定大小（如416x416或608x608）==，以适应YOLO模型的输入。
> 2. **特征提取**：
>    - 使用深度卷积神经网络（如Darknet）==提取图像特征==。
> 3. **网格划分**：
>    - 将提取的特征图==分为SxS的网格==。
> 4. **边界框预测**：
>    - 每个网格预测==固定数量的边界框==（如2个），并为每个边界框输出：
>      - 中心坐标（相对于网格位置）
>      - 宽度和高度
>      - 置信度（每个类别一个置信度，是一个网格的box公用，但是每个box都以额xywh）
> 6. **输出处理**：
>    - 将网络的输出转化为实际的边界框坐标和类别信息。
> 7. **非极大值抑制（NMS）**：
>    - 对预测的边界框进行非极大值抑制，去除重叠度高的框，保留置信度高的框

> ## 优劣
>
> [目标检测算法YOLO的发展史及优势](https://baijiahao.baidu.com/s?id=1783154361828480315&wfr=spider&for=pc)
>
> **优势**
>
> 其一，检测速度非常快。而且每张图像只预测98个边界框。
>
> 其二，背景误判少。以往基于滑动窗口或候选区域提取的目标检测算法只能看到图像的局部信息，因此会把图像背景误认为检测目标。而YOLO在训练和测试时每个格子都可以看到全局信息，因此不容易把图像背景预测为目标。
>
> **劣势**
>
> 其一，YOLO的每个格子只能预测两个边界框和一种目标的分类。YOLO将一张图像均分为49个格子，若在同一单元格内存在多个物体的中心，那么该单元格内只能预测出一个类别的物体，并丢掉其他的物体，从而降低了预测精度
>
> 其二，损失函数的设计过于简单。边界框的坐标和分类表征的内容不同，但YOLO都用其均方误差作为损失函数





#### yolov8

> ## [网络结构](https://blog.csdn.net/Pan_peter/article/details/136247536)
>
> YOLOv8 的网络结构主要包括以下几个部分：
>
> - **Backbone**：特征提取网络，负责从输入图像中提取重要的特征。YOLOv8 使用了一种新的结构（如 CSPNet）来增强特征提取能力，同时减少计算量。
> - **Neck**：连接 Backbone 和 Head 的部分，通常包括 AFPN（Feature Pyramid Network）和 PAN（Path Aggregation Network），用于多尺度特征融合。YOLOv8 在这部分进一步优化了特征融合策略，以提高检测精度。
> - **Head**：负责生成最终的检测结果，包括边界框坐标、置信度和类别概率。==解耦头结构==，将分类任务和回归任务解耦

> ## yolov8比yolov5改进
>
> ![image-20240912164932980](E:\codenotes\JOB\Interview\img\image-20240912164932980.png)
>
> 
>
> - **Backbone**:同样借鉴了==CSP模块==思想，不过将Yolov5中的==C3模块替换成了C2f模块==，实现了进一步轻量化
>   同时沿用Yolov5中的==SPPF模块==，
> - ·**Neck**：移除了 1×1 卷积的降采样层；同时也将原本的 C3 模块换成了 C2f 模块。通常包括 AFPN（Feature Pyramid Network），用于多尺度特征融合
> - **Head**：这部分改动较大，换成了==解耦头结构==，将分类任务和回归任务解耦；也将 ==Anchor-Based 换成Anchor-Free==
> - ·**Loss**：使用 BCE Loss 作为分类损失；使用 DFL Loss + CIOU Loss 作为回归损失。
>
>
> 
> 
>
> **SPPF** 是一种改进的空间金字塔池化（SPP, Spatial Pyramid Pooling）模块
>
> **AFPN**：位于 Neck 中，主要负责特征融合 ，而SPPF 模块位于 Backbone 中，主要负责特征提取。
>
> **解耦头（Decoupled Head）** 是一种将目标检测中的**分类任务**和**回归任务**分开的网络头部结构设计。传统的目标检测头（如 YOLOv5 使用的耦合头）通常会共享分类和边界框回归的特征
>
> 

> ## 问题
>
> ### 数据集不足 样本不均衡 怎么办
>
> - 通过旋转、缩放、裁剪、翻转、改变亮度/对比度等方式增加数据集样本量 
> - 迁移学习 
> - 合成负样本 
> -  重标定样本权重 
> - 调整分类阈值
>
>  ==不能==删除多样本（丢失有用数据）和简单复制正样本的数量（过拟合于正样本）
>
> ### 
>
> ### [YOLOv8n/s/m/l/x不同模型尺寸大小的实验结果对比及结论参考(https://developer.aliyun.com/article/1536820)
>
> YOLOv8x   68.2M参数   A100    3.53ms    130MB
>
> YOLOv8m  25.9M参数   A100   1.83ms    50MB
>
> 通常使用YOLOv8m大小的模型尺寸，即可达到最高精度需求
>
> ### 输入输出处理 
>
> ==32倍数==
>
> 输入固定尺寸640 640，比例不同需要==填充114==
>
> BGR转RGB
>
> 归一化
>
> 
>
> ### 模型过小导致精度不足后处理方法
>
> 3帧确认，避免一两帧的误检
>
> 通过组合多个模型来提升整体性能。这可以通过多个模型的预测结果加权平均或投票机制来实现。
>
> 使用早停技术，在模型在验证集上的性能不再提升时停止训练，以防止过拟合
>
> 阈值调整
>
> 
>
> 
> anchor
>层数
> 
> 



## ==自动驾驶仿真车小车平台==

### 项目介绍解决

设计并制造了用于验证自动驾驶算法的仿真车平台。平台包括仿真车、多传感器 (双目 RGB、双目 DVS，四路鱼眼相机、激光雷达和毫米波雷达)。实现建图、感知、简单避障、和控制等全流程功能， 及小车实时多传感器数据采集和 Rosbag 数据包的录制，并在ROS端进⾏数据时间戳的修正实现Lidar、RGB和DVS相机毫秒级时间同步、亚像素空间标定、自动驾驶全通路软件设计开发，  
我的主要工作和涉及技术：
⚫ 通过 PPS 脉冲信号和 FPGA 产生的硬件触发信号，负责实现所有传感器数据的同步采集；
⚫ 实现不同帧率传感器时间戳和数据获取的同步误差 5ms 以内；
⚫ 开发基于 C++ Qt 的客户端界面，真个是下ROS下使用实时订阅传感器驱动发布的话题，可视化显示9 路图像数据，并以低延迟发布合成的 IPM 图像。

###  难点 

> - ==同步验证方案==
>
> - ==效率，yuv格式转换==
>
> - ==要学习的很多，fpag 软硬件都设计==
>
> - 团队合作和不停开会
>
> - 撰写文档，对软硬件足够和熟悉，==快速排查问题==
>
> - ==因为华为那边对这些都有很严格的审核要求==，所以最开始方案确定的时候提出又否决，包括最后验收华为当场又提出了更严格的验证指标，在压力非常大的情况下，还是比较完美的结束了项目，还是比较考验心态的。
>
> - QT这部分的难点在于如何高帧率显示13路传感数据？如何实时同步显示BEV拼接效果和BEV上的误差计算结果？在这一部分遇到的最主要的问题就是**卡顿和频闪**的问题。
>
>   解决：卡顿（多线程）、频闪（双缓冲区）

### <font style="color:#D22D8D;">YUV与RGB转换</font>

> <font style="color:rgb(36, 41, 47);">YUYV（YUV 4:2:2）是一种常见的视频图像格式，特别是在视频捕捉和传输中广泛使用。它是一种压缩的颜色编码格式，主要用于减少视频数据量，同时保留较高的图像质量。下面是对 YUYV 格式的详细解释：</font>
>
> <font style="color:rgb(36, 41, 47);">YUYV 格式是一种 YUV 4:2:2 子采样格式，其中：</font>
>
> + **<font style="color:rgb(36, 41, 47);">Y</font>**<font style="color:rgb(36, 41, 47);"> </font><font style="color:rgb(36, 41, 47);">表示亮度（Luminance），它决定了图像的亮度信息。</font>
> + **<font style="color:rgb(36, 41, 47);">U</font>**<font style="color:rgb(36, 41, 47);"> 和 </font>**<font style="color:rgb(36, 41, 47);">V</font>**<font style="color:rgb(36, 41, 47);"> 表示色度（Chrominance），它们共同决定了图像的颜色信息。</font>
> + <font style="color:rgb(36, 41, 47);">在 YUYV 格式中，每个像素组包含两个像素的亮度信息和一个共享的色度信息。具体来说，数据排列如下：</font>
>
> ```plain
> Y0 U0 Y1 V0
> ```
>
> <font style="color:rgb(36, 41, 47);">这表示两个像素的亮度值（Y0 和 Y1）和一个共享的色度值（U0 和 V0）</font>
>
> 1. **<font style="color:rgb(36, 41, 47);">压缩效率</font>**<font style="color:rgb(36, 41, 47);">：YUYV 格式通过共享色度信息来减少数据量，相比于 RGB 格式，它的压缩效率更高。</font>
> 2. **<font style="color:rgb(36, 41, 47);">图像质量</font>**<font style="color:rgb(36, 41, 47);">：虽然色度信息被子采样，但由于人眼对亮度变化更敏感，对色度变化不太敏感，因此图像质量仍然较高。</font>
>
> <font style="color:rgb(36, 41, 47);">YUYV 格式的数据通常需要转换为 </font>**<font style="color:rgb(36, 41, 47);">RGB 格式，以便在显示器上显示或进一步处理</font>**<font style="color:rgb(36, 41, 47);">。转换公式如下：</font>
>
> ```bash
> R = Y + 1.402 * (V - 128)
> G = Y - 0.344136 * (U - 128) - 0.714136 * (V - 128)
> B = Y + 1.772 * (U - 128)
> ```
>
> <font style="color:rgb(36, 41, 47);">这些公式将 YUYV 格式的亮度和色度信息转换为 RGB 格式的红、绿、蓝分量。</font>
>
> **RGB24** 每个像素用24位表示，RGB分量各使用8位
>
> 
>
> **YUV422：**
> 同一行的相邻4个像素数据: Y0U0V0 Y1U1V1 Y2U2V2 Y3U3V3
> 存储时: Y0 U0， Y1 V1， Y2 U2， Y3 V3 // 每两个相邻的像素， 一个丢弃V数据，一个丢弃U数据
>
> **YUYV** 是 **YUV422** 格式的一种特殊排列方式。每 4 个字节代表两个像素的信息：
>
> - 第1个字节是第一个像素的亮度（Y1）。
>
> - 第2个字节是 U 分量，表示两个像素共享的色度信息。
>
> - 第3个字节是第二个像素的亮度（Y2）。
>
> - 第4个字节是 V 分量，表示两个像素共享的色度信息。
>
>   因此，一个 YUYV 单元对应两个像素。

### <font style="color:#D22D8D;">ROS相关命令</font>

```bash
cmake ..
make
roscore    # 执行ros master
catkin_make     #编译
source devel/setup.bash   #设置环境变量
roslaunch usb_cam usb_cam-test.launch
rviz
rostopic list
rosrun my_package talker

```





## ==软件精英挑战赛==

> 项目整体分为两个任务，一个是优化调度，一个路径导航（防碰撞，机器人转向控制）。
>
> 任务核心还是在于实现精确导航任务，和任务和合理分配。
>
> 初赛时，没有障碍物，难点集中在避免两个甚至多个机器人碰撞，开始是添加一个相向偏移缓慢调整，后来发现多个碰撞后完全无法碰撞之后再做调整。
>
> 所以为了排除这种多机器人可能出现的碰撞，参考**DWA**设计并实现了机器人路径防撞算法;在算法迭代更新过程中，实现无冲突预调度、非线性转向控制、加入时间边界考虑等优化。
>
> 复赛阶段加入了墙壁障碍的阻挡，由<font style="color:rgb(36, 41, 47);">Dijkstra算法去计算每个机器人的全局路径。
>
> 为解决机器人在狭窄通道中堵塞导致系统瘫痪问题，使用DWA算法进行局部路径规划。它通过实时感知环境中的障碍物和其他机器人，动态调整机器人的运动轨迹，以避免碰撞和死锁。</font>
>
> 最终获得了，西北赛区二等奖。
>
> 西北赛区600左右队

### 用了什么算法和优化策略

贪心，合理控制地图的不同商品的数量，采用大根堆，贪心的策略和结合A*的算法，计算待取物品的价值以及锁定待取货物和优先取紧急的物品。，

> 会先确认送给哪个工作台什么货物？
>
> **卖方确认**： 遍历工作台状态，看合成哪一种货物利润最大，看有没有锁（别的机器人准备送此货物），大致计算机器人到取货台距离+取货台到送货台距离（越小越好），哪一个原材料缺少的比较少，且没有正在生产货物或即将生产完毕，那么当前就搬运这类货物给此工作台。设置锁表示被占。
>
> 然后以此工作台为原点，去寻找生产待购买货物的站台。看取货时间内是否能生产完毕，距离最近。
>
> **具体的策略？**
>
> 1. 顺路原则，要卖出一个工作台上的物品，最好带一个物品过来放入它的材料格再卖出这个物品。
> 2. 顺路原则，**卖完货物当前任务完成，正好有生产好的顺路带走。**
> 3. 当一些工作台上已经集齐了一些原材料，优先考虑塞满这些工作台的原材料格。
> 4. 机器人的每单位移动获得的利润越大越好。
> 5. 7号生产线上，物品4,5,6的生产应该尽可能均衡。
> 6. 避免拥挤，不要让太多的机器人前往相同的工作台。
> 7. 处于7号生产线上的1,2,3,4,5,6物品尽量不要卖给9号工作台

### djstar和A*

*Floyd算法*，多源最短路

> ## djstar
>
> 单源最短路，贪心
>
> 1. 需要**优先队列**加入**已经确定点的周围点**。每次抛出确定最短路径的那个并且确定最短，直到所有点路径确定最短为止。
>
> ![img](https://i-blog.csdnimg.cn/blog_migrate/dea3da4b32fb2c18390ba609e64a7741.png)
>
> 
>
> ![img](https://i-blog.csdnimg.cn/blog_migrate/f11bfabf7818e311c93136ee82c3c6b0.png)
>
> 
>
> ```c
> #include <iostream>
> #include <vector>
> #include <queue>
> #include <limits>
> 
> using namespace std;
> 
> const int INF = numeric_limits<int>::max(); // 定义无穷大
> 
> // Dijkstra 算法
> void dijkstra(const vector<vector<pair<int, int>>>& graph, int start) {
>     int n = graph.size(); // 图的顶点数
>     vector<int> dist(n, INF); // 最短路径数组
>     priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // 优先级队列
> 
>     dist[start] = 0; // 起始节点到自身的距离为0
>     pq.push({0, start}); // 将起始节点加入队列
> 
>     while (!pq.empty()) {
>         int d = pq.top().first; // 当前节点的距离
>         int u = pq.top().second; // 当前节点
>         pq.pop();
> 
>         if (d > dist[u]) continue; // 如果当前距离大于已知最短距离，跳过
> 
>         // 更新邻接节点的距离
>         for (const auto& edge : graph[u]) {
>             int v = edge.first; // 邻接节点
>             int weight = edge.second; // 边的权重
> 
>             // 如果发现更短的路径
>             if (dist[u] + weight < dist[v]) {
>                 dist[v] = dist[u] + weight;
>                 pq.push({dist[v], v}); // 加入队列
>             }
>         }
>     }
> 
>     // 输出结果
>     for (int i = 0; i < n; ++i) {
>         if (dist[i] == INF) {
>             cout << "距离节点 " << i << " 的最短路径是: 无法到达" << endl;
>         } else {
>             cout << "距离节点 " << i << " 的最短路径是: " << dist[i] << endl;
>         }
>     }
> }
> 
> int main() {
>     // 例子: 一个带权图
>     vector<vector<pair<int, int>>> graph = {
>         {{1, 7}, {3, 9}},          // 节点 0 的邻接节点和权重
>         {{0, 7}, {2, 10}},         // 节点 1
>         {{1, 10}, {4, 2}},         // 节点 2
>         {{0, 9}, {4, 6}},          // 节点 3
>         {{2, 2}, {3, 6}, {5, 9}},  // 节点 4
>         {{4, 9}}                   // 节点 5
>     };
> 
>     int start = 0; // 从节点 0 开始
>     dijkstra(graph, start);
> 
>     return 0;
> }
> ```
>

> ## [A*](https://blog.csdn.net/m0_38054145/article/details/81808541)
>
> 1. 将方块添加到open列表中，该列表有最小的和值。且将这个方块称为S吧。
> 2. 将S从open列表移除，然后添加S到closed列表中。
> 3. 对于与S相邻的每一块可通行的方块T：
>
> - 1. 如果T在closed列表中：不管它。
>   2. 如果T不在open列表中：添加它然后计算出它的和值。
>   3. 如果T已经在open列表中：当我们使用当前生成的路径到达那里时，检查F 和值是否更小。如果是，更新它的和值和它的前继。
>
> ![img](https://pic2.zhimg.com/80/v2-ae8e5947b7ce6636874ff0574dd5a781_720w.webp)
>
> ### 算法思想
>
> [A*算法](https://zhida.zhihu.com/search?q=A*算法&zhida_source=entity&is_preview=1)是对A算法的估价函数 **f(n)=g(n)+h(n)** 加上某些限制后得到的一种[启发式搜索算法](https://zhida.zhihu.com/search?q=启发式搜索算法&zhida_source=entity&is_preview=1)（*并不总是保证找到最短路径*）
>
> 假设f*(n)是从初始结点S0出发，约束经过结点n到达目标结点Sg的最小代价，估价函数f(n)是对f*(n)的估计值。记
>
> - f*(n)=g*(n)+h*(n)
>
> 其中， g*(n)是从S0[出发到达](https://zhida.zhihu.com/search?q=出发到达&zhida_source=entity&is_preview=1)n的最小代价,h*(n)是n到Sg的最小代价。
>
> 如果对A算法（全局择优）中的g(n)和h(n)分别提出如下限制：
>
> 1. g(n)是对最小代价g*(n)的估计，且g(n)>0；
> 2. h(n)是最小代价h*(n)的下界，即对任意结点n均有h(n)≤h*(n)。
>
> 则称满足上述两条限制的A算法为A*算法。



### [DWA](https://www.bilibili.com/video/BV1L5411g7Vn/?spm_id_from=333.337.search-card.all.click&vd_source=eef102f4fb053709a57c96d0c876628a)

![image-20240920215820771](E:\codenotes\JOB\Interview\img\image-20240920215820771.png)



# 手撕

##  ==排序==

https://zhuanlan.zhihu.com/p/23480279

![img](https://pic4.zhimg.com/80/v2-206134f7fffacbe3e4753c6af7ecbab7_1440w.webp)

### 冒泡

```
// 1 冒泡排序：‌
// 时间复杂度：‌最好情况为O(n)，‌当数组完全逆序时。‌平均时间复杂度为O(n^2)。‌
// 稳定性：‌稳定。‌
```

### 快速排序

基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于[基准元素](https://zhida.zhihu.com/search?q=基准元素&zhida_source=entity&is_preview=1),此时基准元素在其排好序后的正确位置,然后再用同样的方法[递归](https://zhida.zhihu.com/search?q=递归&zhida_source=entity&is_preview=1)地排序划分的两部分

```c
// 2  快速排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)，‌最好情况为O(nlogn)，‌最坏情况为O(n^2)。‌
// 稳定性：‌不稳定

void quiksort(int l, int r)
{
    if(l>=r) return;
    int i = l-1, j = r+1, mid = (l + r)/2;
    int target = nums[mid];
    while (i < j)
    {
        do i++; while (nums[i] < target);
        do j--; while (nums[j] > target);
            
        if (i < j)
            swap(nums[i], nums[j]);
        //cout << i << " " <<  j << endl;
    }
    quiksort(l, j);
    quiksort(j+1, r);
    return;
}
```

### 插入排序

每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。

希尔就是插入分组来做......

```c
//3  直接插入排序：‌
// 时间复杂度：‌平均时间复杂度为O(n^2)，‌最好情况为O(n)。‌
// 稳定性：‌稳定。‌

void  insert_sort()
{
    vector<int> res(nums.size(),0);
    
    for(int i=0;i<nums.size();i++)
    {
        int idx = i;
        while(idx>0&&res[idx-1]>nums[i])
        {
            res[idx] = res[idx-1];
            idx--;
        }
        res[idx] = nums[i];
    }
    for(int i=0;i<nums.size();i++) nums[i] = res[i];
    return;
}

```

### 归并排序

基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的[有序表](https://zhida.zhihu.com/search?q=有序表&zhida_source=entity&is_preview=1)，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

```c

// 4 归并排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)。‌
//空间复杂度为O(n)
// 稳定性：‌稳定。‌

void merge_sort(int l, int r)
{
    if(l>=r) return;
    int mid = (l+r)/2;
    merge_sort(l,mid);
    merge_sort(mid+1,r);
    vector<int> temp;
    int i=l,j=mid+1;
    while(i<=mid&&j<=r)
    {
        if(nums[i]<=nums[j]) temp.push_back(nums[i++]);
        else temp.push_back(nums[j++]);
    }
    
    while(i<=mid) temp.push_back(nums[i++]);
    while(j<=r) temp.push_back(nums[j++]);
    int idx = 0;
    while(idx<temp.size()) 
    {
        nums[l++]=temp[idx++];
    }
    return;
}
```

### 堆排序

初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。

```c
// 5 堆排序：‌
// 时间复杂度：‌平均时间复杂度为O(nlogn)。‌
// 稳定性：‌不稳定。‌

void heapdown(int i, int max)
{
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < max && nums[left] > nums[largest])
        largest = left;
    if (right < max && nums[right] > nums[largest])
        largest = right;

    if (largest != i)
    {
        swap(nums[i], nums[largest]);
        heapdown(largest, max);
    }
}

void build_heap()
{
    
    for(int i=n/2-1;i>=0;i--)
    {
        heapdown(i, n);
    }
    return;
}


void  heap_sort()
{
    build_heap();
    for(int i=n-1;i>=0;i--)
    {
        swap(nums[0],nums[i]);
        heapdown(0, i);
    }
}

```

### 选择排序

基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。

## ==二分==

两种模版，一个是判断红色的右边界，一种是判断绿色的左边界

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/62fb0656f2b28b3a0ebd16cf3953202e.png)

```c
版本1 绿色的左边界
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}

版本2  红色的右边界
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
} 
```



## ==通用==

### mem函数

![image-20240811194358234](img/image-20240811194358234.png)



```c
void kernel_memcpy (void * dest, void * src, int size) {
    if (!dest || !src || !size) {
        return;
    }

    uint8_t * s = (uint8_t *)src;
    uint8_t * d = (uint8_t *)dest;
    while (size--) {
        *d++ = *s++;
    }
}

void kernel_memset(void * dest, uint8_t v, int size) {
    if (!dest || !size) {
        return;
    }

    uint8_t * d = (uint8_t *)dest;
    while (size--) {
        *d++ = v;
    }
}

int kernel_memcmp (void * d1, void * d2, int size) {
    if (!d1 || !d2) {
        return 1;
    }

	uint8_t * p_d1 = (uint8_t *)d1;
	uint8_t * p_d2 = (uint8_t *)d2;
	while (size--) {
		if (*p_d1++ != *p_d2++) {
			return 1;
		}
	}

	return 0;
}

void kernel_itoa(char * buf, int num, int base) {
    // 转换字符索引[-15, -14, ...-1, 0, 1, ...., 14, 15]
    static const char * num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char * p = buf;
    int old_num = num;

    // 仅支持部分进制
    if ((base != 2) && (base != 8) && (base != 10) && (base != 16)) {
        *p = '\0';
        return;
    }

    // 只支持十进制负数
    int signed_num = 0;
    if ((num < 0) && (base == 10)) {
        *p++ = '-';
        signed_num = 1;
    }

    if (signed_num) {
        do {
            char ch = num2ch[num % base + 15];
            *p++ = ch;
            num /= base;
        } while (num);
    } else {
        uint32_t u_num = (uint32_t)num;
        do {
            char ch = num2ch[u_num % base + 15];
            *p++ = ch;
            u_num /= base;
        } while (u_num);
    }
    *p-- = '\0';

    // 将转换结果逆序，生成最终的结果
    char * start = (!signed_num) ? buf : buf + 1;
    while (start < p) {
        char ch = *start;
        *start = *p;
        *p-- = ch;
        start++;
    }
}

```

### str函数*

```c

//拷贝
char* strcpy(char *dst,const char *src) {// [1]
     assert(dst != NULL && src != NULL); // [2]
     char *ret = dst; // [3]
     while ((*dst++=*src++)!='\0'); // [4]
     return ret;
}

//拷贝**********
void kernel_strcpy (char * dest, const char * src) {
    if (!dest || !src) {
        return;
    }

    while (*dest && *src) {
        *dest++ = *src++;
    }
    *dest = '\0';
}

//拷贝n个
void kernel_strncpy(char * dest, const char * src, int size) {
    if (!dest || !src || !size) {
        return;
    }

    char * d = dest;
    const char * s = src;

    while ((size-- > 0) && (*s)) {
        *d++ = *s++;
    }
    if (size == 0) {
        *(d - 1) = '\0';
    } else {
        *d = '\0';
    }
}
//长度
int kernel_strlen(const char * str) {
    if (str == (const char *)0) {
        return 0;
    }

	const char * c = str;

	int len = 0;
	while (*c++) {
		len++;
	}

	return len;
}

/**
 * 比较两个字符串，最多比较size个字符
 * 如果某一字符串提前比较完成，也算相同
 */
int kernel_strncmp (const char * s1, const char * s2, int size) {
    if (!s1 || !s2) {
        return -1;
    }

    // 2023-3-18 这里size没有用到
    while (*s1 && *s2 && (*s1 == *s2) && size) {
    	s1++;
    	s2++;
    	size--;
    }

    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
}


//删除字符串 str 中的指定字符 c1 和 c2，
char* DeleteChar(char *str, char c1, char c2) {
    if (str == nullptr) return str;  // 检查空指针
    char *src = str;  // 原字符串的指针
    char *dst = str;  // 目标位置的指针
    while (*src != '\0') {
        // 如果当前字符不是c1或c2，就将其复制到目标位置
        if (*src != c1 && *src != c2) {
            *dst++ = *src;
        }
        src++;
    }
    *dst = '\0';  // 终止新的字符串
    return str;
}

```



### atoi

注意异常返回-1 int溢出

```c
int atoi(const char *str) {
    int sign = 1, base = 0, i = 0;

    // 去除前导空白字符
    while (str[i] == ' ') { i++; }
    
    // 处理正负号
    if (str[i] == '+' || str[i] == '-') {
        sign = (str[i++] == '-') ? -1 : 1;
    }
    
    // 转换数字字符
    while (str[i] >= '0' && str[i] <= '9') {
        base = base * 10 + (str[i++] - '0');
    }
    
    return sign * base;
}
```



### 手写字符串

```c++
class String
{
public:
     String(const char *str = NULL);
     String(const String &other);
     ~ String(void);
     String & operate =(const String &other);
    private:
char *m_data;
};


// 构造函数
String::String(const char *str)
{
    if (str == NULL)
    {
        m_data = new char[1]; // 对空字符串⾃动申请存放结束标志'\0'
        *m_data = '\0';
    }
    else
    {
        int length = strlen(str);
        m_data = new char[length + 1];
        strcpy(m_data, str);
    }
}
// 析构函数
String::~String(void)
{
    delete[] m_data; // 或delete m_data;
}
// 拷⻉构造函数
String::String(const String &other)
{
    int length = strlen(other.m_data);
    m_data = new char[length + 1];
    strcpy(m_data, other.m_data);
}
// 赋值函数
String &String::operate = (const String &other)
{
    if (this == &other)
    {
        return *this; // 检查⾃赋值
    }
    delete[] m_data; // 释放原有的内存资源
    int length = strlen(other.m_data);
    m_data = new char[length + 1]; // 对m_data加NULL判断
    strcpy(m_data, other.m_data);
    return *this; // 返回本对象的引⽤
}

```

### 手写Vector

```c++
#include <iostream>
#include <sstream>
using namespace std;
int n;

template <class T>
class vector
{
public:
    vector() : m_data(nullptr), m_size(0), m_capacity(0)
    {
    }
    ~vector()
    {
        if (m_data != nullptr)
        {
            delete[] m_data;
        }
        m_size = 0;
        m_capacity = 0;
    }

    void push_back(T &value)
    {
        if (m_size < m_capacity)
        {
            m_data[m_size] = value;
            m_size++;
            return;
        }
        if (m_capacity == 0)
            m_capacity = 1;
        else
            m_capacity *= 2;

        T *data = new T[m_capacity];
        for (int i = 0; i < m_size; i++)
        {
            data[i] = m_data[i];
        }

        if (m_data != nullptr)
        {
            delete[] m_data;
            m_data = nullptr; // 防止指针悬挂，指向被释放的空间
        }
        m_data = data;
        m_data[m_size++] = value;
    }

    void pop_back()
    {
        if (m_size > 0)
            m_size--;
    }

    // 拷贝构造函数
    vector(const vector<T> &other) : m_data(nullptr), m_size(other.m_size), m_capacity(other.m_capacity)
    {
        if (m_capacity > 0)
        {
            m_data = new T[m_capacity];
            for (int i = 0; i < m_size; ++i)
            {
                m_data[i] = other.m_data[i];
            }
        }
    }

    // 赋值运算符重载
    vector<T> &operator=(const vector<T> &other)
    {
        if (this == &other)
            return *this; // 防止自赋值

        delete[] m_data; // 释放已有资源

        m_size = other.m_size;
        m_capacity = other.m_capacity;
        m_data = nullptr;

        if (m_capacity > 0)
        {
            m_data = new T[m_capacity];
            for (int i = 0; i < m_size; ++i)
            {
                m_data[i] = other.m_data[i];
            }
        }

        return *this;
    }

     // 移动构造函数
    vector(vector<T>&& other) noexcept // 声明一个不会抛出异常的函数
        : m_data(other.m_data), m_size(other.m_size), m_capacity(other.m_capacity)
    {
        other.m_data = nullptr;
        other.m_size = 0;
        other.m_capacity = 0;
    }

    // 访问
    T &at(int index)
    {
        if (index < 0 || index >= m_size)
            throw std::out_of_range("out of range");
        return m_data[index];
    }

    T &front() // 返回第一个
    {
        // if(m_data == nullptr)
        //     throw std::out_of_range("out of range");  可以抛出合适的异常，可能不是outofrange
        return m_data[0];
    }

    T &back() // 返回都是&引用类型，这样就可以直接对数据进行修改
    {
        return m_data[m_size - 1];
    }

    T &operator[](int index) // 使用重载  如果这里放在其他文件进行定义 那么就要加上作用域  比如  template <class T>  然后函数前面加上 vector<T>
    {
        return m_data[index];
    }

    T &operator[](int index) const // 使用重载  如果这里放在其他文件进行定义 那么就要加上作用域  比如  template <class T>  然后函数前面加上 vector<T>
    {
        return m_data[index];
    }

    const int size() const
    {
        return m_size;
    }

private:
    T *m_data; // 指向T类型的指针  这里如果T是 int 就可以理解为什么样的数组，
    int m_size;
    int m_capacity;
};
```

> ****
>
> ```c
>  // 常量版本
> 
>   const T& operator[](int index) const
>   {
> ​    return data[index];
>   }
>   
> `const T&`（返回值类型）**：确保通过这个下标运算符访问的元素不能被修改。
> `const`（成员函数）**：保证这个函数不会修改类的状态，从而可以被`const`对象调用。
> ```

### 手写共享指针的功能

柠檬微趣：需要实现有参无参构造，析构函数，拷贝构造，赋值语句，移动构造，

```c
#include<iostream>
#include "mingw.thread.h"
#include "mingw.mutex.h"
#include "mingw.condition_variable.h"
using namespace std;

template<typename T>
class share_ptr{
public:
   //默认构造函数
   explicit shared_ptr(T* ptr = nullptr):m_ptr(ptr), cnt(new size_t(1)){}
   //拷贝构造函数
   shared_ptr(const shared_ptr<T>& sp):m_ptr(sp.m_ptr), cnt(sp.cnt){
       (*cnt)++;
   }
   //析构函数
   ~shared_ptr(){
       decrease();
   }
   //运算符重载
   //赋值运算符重载
   shared_ptr<T> operator=(const shared_ptr<T>& sp){
       if(this!=sp){
           decrease();
           m_ptr = sp.m_ptr;
           cnt = sp.cnt;
           (*cnt)++;
       }
       return this;
   }
   //解引用运算符重载
   T& operator*() const{
       return *m_ptr;
   }
   //箭头运算符重载
   T* operator->() {
       return m_ptr;
   }

private:
   T* m_ptr;
   std::size_t* cnt;
   void decrease(){  //当实例对象的shared_ptr出作用域的时候进行检查是否需要释放资源
       if(--(*cnt) == 0){
           delete m_ptr;
           delete cnt;
       }
   }
};



```

> [线程安全版本](https://blog.csdn.net/Nothing721/article/details/130344539)    计数操作前后mutex.lock()和unlock()

## ==并发==

### 交替打印

```c
#include <vector>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <iostream>
#include "mingw.thread.h"
#include "mingw.mutex.h"
#include "mingw.condition_variable.h"

using namespace std;
mutex mx;
condition_variable cv;
int flag = 0;

void printA()
{
    unique_lock<mutex> lock(mx);
    int cnt = 10;
    while(cnt--)
    {
        cv.wait(lock,[&](){return flag==0;});
        cout << 'A' <<endl;
        flag = 1;
        cv.notify_all();
    }
}

void printB()
{
    unique_lock<mutex> lock(mx);
    int cnt = 10;
    while(cnt--)
    {
        cv.wait(lock,[&](){return flag==1;});
        cout << 'B' <<endl;
        flag = 2;
        cv.notify_all();
    }
}

void printC()
{
   unique_lock<mutex> lock(mx);
    int cnt = 10;
    while(cnt--)
    {
        cv.wait(lock,[&](){return flag==2;});
        cout << 'C' <<endl;
        flag = 0;
        cv.notify_all();
    }
}

int main()
{
    thread A(printA);
    thread B(printB);
    thread C(printC);
    A.join();
    B.join();
    C.join();
    return 0;
}


```

### [手写线程池](https://zhuanlan.zhihu.com/p/624285893)

[写的有问题](https://blog.csdn.net/qq_58220428/article/details/138797021)

```c
#include <vector>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <iostream>
#include "mingw.thread.h"
#include "mingw.mutex.h"
#include "mingw.condition_variable.h"
/*
定义线程池类：接下来定义线程池类，其中包含了线程池的管理逻辑，
如线程的创建、销毁、任务的添加等。线程池类需要包含一个线程池容器，用于存放线程对象。
*/

class Task
{
public:
    void execute()
    {
        std::cout << "Task is excuting" << std::endl;
    }
};

using namespace std;
class ThreadPool
{
public:
    ThreadPool(size_t numThreads);
    ~ThreadPool();
 
    void addTask(Task* task);
private:
    vector<std::thread> workers;  // 线程池中的线程
    queue<Task*> tasks;           // 任务队列
    mutex queueMutex;             // 保护任务队列的互斥量
    condition_variable condition; // 用于线程间通信的条件变量
    bool stop;                         // 标志线程池是否停止的标志位
};

ThreadPool::ThreadPool(size_t numThreads)
: stop(false)
{
    for(size_t i = 0; i < numThreads; ++i) 
    {
        workers.emplace_back([this] {
            while(true)
            {
                    Task* task = nullptr;
                    // 此线程取任务的时候  别的线程不可以取 所以必须上锁
                    // 其他线程无法同时访问任务队列
                    {
                        //	如果其他线程占有锁，阻塞在这里
                            std::unique_lock<std::mutex> lock(queueMutex);
                       
                            // condition调用wait方法 使线程在条件变量condition上等待 
                            // 当不满足条件时 会释放锁lock 满足条件时(stop为true 或 tasks不为空 满足之一时) 重新获取lock 并向下继续执行
                            // 假如此时没有任务了 线程会阻塞在这里 直到任务队列有新任务到来时 该线程会被再次激活
                            condition.wait(lock, [this] {return stop || !tasks.empty();});
                            // 线程池停止 且 任务队列为空时 直接返回 默认情况下stop为false
                            if(stop && tasks.empty())
                            {
                                cout << "workers out! " <<endl;
                                return;
                            }
                            // 获取并执行任务
                            task = tasks.front();
                            tasks.pop();
                            }
                    task->execute();
                    delete task;
                }
        });
    }
}
 
ThreadPool::~ThreadPool()
{
        {
                std::unique_lock<std::mutex> lock(queueMutex);
                stop = true;

                // 清空任务队列
                while (!tasks.empty())
                {
                    Task* task = tasks.front();
                    tasks.pop();
                    delete task;
                }
        } // 这里结束作用域，lock 会自动释放!!
        condition.notify_all();
        for(std::thread& work : workers)
        {
            if (work.joinable())    work.join();
        }
}

void ThreadPool::addTask(Task* task)
{
    std::unique_lock<std::mutex> lock(queueMutex);
    tasks.push(task);
    // 向等待condition条件变量的一个线程发出通知
    // 告诉它有新的任务可执行 可以取出任务
    condition.notify_one();
}
 

int main()
{
    ThreadPool pool(4);   // 创建一个包含4个线程的线程池
    cout << 1 <<endl;
    // 添加任务到线程池
    for(int i = 0; i < 8; ++i)
    {
        pool.addTask(new Task());
    }
    cout << 1 <<endl;
    return 0;
}


```



### [手写自旋锁](https://zhuanlan.zhihu.com/p/624285893)  

```c
#include <atomic> // 引入原子操作的头文件
#include <thread> // 引入线程的头文件

class spinlock { // 定义一个自旋锁的类
    std::atomic_flag flag = ATOMIC_FLAG_INIT; // 定义一个原子标志，初始为假
public:
    void lock() { // 定义获取锁的方法
        while (flag.test_and_set(std::memory_order_acquire)); // 循环测试并设置标志，如果标志为真，表示锁被占用，继续循环；如果标志为假，表示锁空闲，设置标志为真，并跳出循环。这里使用内存顺序为获取，表示获取锁后，后续的读操作不能被重排到前面。
    }
    void unlock() { // 定义释放锁的方法
        flag.clear(std::memory_order_release); // 清除标志，设置为假，表示锁空闲。这里使用内存顺序为释放，表示释放锁前，前面的写操作不能被重排到后面。
    }
};
```

## ==链表==

### 翻转链表*

柠檬微趣：vscode共享屏幕写，自己写结构体和测试案例

```c
#include<iostream>
using namespace std;


class Node
{
public:
    Node(int x):val(x){};
    Node* next = nullptr;
    int val;
};

Node* reverse(Node* head)
{
    Node* pre = nullptr;
    Node* nd;
    while(head!=nullptr)
    {
        nd = head->next;
        head->next = pre;
        pre = head;
        head = nd;
    }
    return pre;
}

int main()
{
    Node* a = new Node(1);
    Node* a1 = new Node(2);
    Node* a2 = new Node(3);
    Node* a3 = new Node(4);
    Node* a4 = new Node(5);
    a->next = a1;
    a1->next = a2;
    a2->next = a3;
    a3->next = a4;
    a = reverse(a);
    while(a!=nullptr)
    {
        cout << a->val <<endl;
        a = a->next;
    }
    return 0;
}




//翻转第left到right个
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        for (int i = 0; i < left - 1; i++) {
            p0 = p0->next;
        }

        ListNode* pre = nullptr;
        ListNode* cur = p0->next;
        for (int i = 0; i < right - left + 1; i++) {
            ListNode* nxt = cur->next;
            cur->next = pre; // 每次循环只修改一个 next，方便大家理解
            pre = cur;
            cur = nxt;
        }

        // 见视频
        p0->next->next = cur;
        p0->next = pre;
        return dummy.next;
    }
};
```

### 合并链表*

```c
#include <iostream>
using namespace std;

class myList
{
    public:
    int val;
    myList* next;
    myList(int x):val(x){}
};

//我第一次写的复杂的
myList* merge(myList* head1,myList* head2)
{
    myList* res = new myList(1);
    myList* head = res;
    while(head1!= nullptr&&head2!= nullptr)
    {
        if(head1->val<head2->val)
        {
            head ->next  = head1;
            head = head ->next;
            head1 = head1->next;
        }
        else
        {
            head ->next  = head2;
            head = head ->next;
            head2 = head2->next;
        }
    }
    if(head1!= nullptr) head ->next  = head1;
    if(head2!= nullptr) head ->next  = head2;
    return res->next;
}

int main(void) {

    myList* node0 = new myList(0);
    myList* node1 = new myList(1);
    myList* node2 = new myList(2);
    myList* node3 = new myList(3);

    myList* node4 = new myList(1);
    myList* node5 = new myList(4);
    node0->next = node1;
    node1->next = node2;
    node2-> next= node3;
    node3->next = nullptr;
    node4->next = node5;
    node5->next = nullptr;

    auto node = merge(node0, node4);
    while (node != nullptr) {
        cout << node->val << endl;
        node = node->next;
    }

    return 0;
}



//解法二
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    if (l1 == nullptr) {
        return l2;
    } else if (l2 == nullptr) {
        return l1;
    } else if (l1->val < l2->val) {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    } else {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}


//K个链表合并
struct Mycmp{
    bool operator()(ListNode* a,ListNode* b)
    {
        if(b==nullptr) return true;
        return a->val>b->val;
    }
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* t = new ListNode(-1);
        ListNode* res = t;
        priority_queue<ListNode*,vector<ListNode*>,Mycmp> q;
        for (ListNode* list : lists) {
            if (list != nullptr) {
                q.push(list);
            }
        }
        while(!q.empty())
        {
            t->next = q.top();
            q.pop();
            t = t->next;
            if(t->next==nullptr) continue;
            q.push(t->next);
        }
        return res->next;
    }
};
```

### 重排链表

> 请将其重新排列后变为：
>
> ```
> L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
> ```

法一：线性表

```c
class Solution {
public:
    void reorderList(ListNode *head) {
        if (head == nullptr) {
            return;
        }
        vector<ListNode *> vec;
        ListNode *node = head;
        while (node != nullptr) {
            vec.emplace_back(node);
            node = node->next;
        }
        int i = 0, j = vec.size() - 1;
        while (i < j) {
            vec[i]->next = vec[j];
            i++;
            if (i == j) {
                break;
            }
            vec[j]->next = vec[i];
            j--;
        }
        vec[i]->next = nullptr;
    }
};

```



法二：快慢指针 + 链表逆序 + 合并链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* revlist(ListNode* head)
    {
        ListNode* pre = nullptr;
        ListNode* nd;
        while(head!=nullptr)
        {
            nd = head->next;
            head->next = pre;
            pre = head;
            head = nd;
        }
        return pre;
    }
    void mergelist(ListNode* h1,ListNode* h2)
    {
        ListNode* res = new ListNode(-1);
        ListNode* now = res;
        while(h1!=nullptr&&h2!=nullptr)
        {
            ListNode* t = h1->next;
            now->next = h1;
            h1->next = h2;
            h1 = t;
            now = h2;
            h2 = h2->next; 

        }
        if(h1==nullptr&&h2==nullptr) 
        {
            //cout << "xx" <<endl;
            return;
        };
        if(h1!=nullptr) now->next = h1;
        if(h2!=nullptr) now->next = h2;
    }

    void reorderList(ListNode* head) {
        ListNode* head1 = new ListNode(-1);
        ListNode* slow = head1;
        head1->next = head;
        ListNode* head2 = new ListNode(-1);
        head2->next = head;
        ListNode* fast = head2;
        while(fast!=nullptr&&fast->next!=nullptr)
        {
            slow=  slow->next;
            fast=  fast->next->next;
        }
        head2 = slow->next;
        slow->next = nullptr;
        head2 = revlist(head2);
        mergelist(head1->next,head2);
    }
};
```

### 奇偶链表

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head==nullptr||head->next==nullptr) return head;
        ListNode* n1  = head;
        ListNode* n2  = head->next;
        ListNode* head2 = n2;
        ListNode* t;
        while(n2!=nullptr&&n2->next!=nullptr)
        {
            
            n1->next = n1->next->next;
            n2->next = n2->next->next;
            t = n1;
            n1 = n1->next;
            n2 = n2->next;
        }
        n1->next = head2;
        return head;
    }
};
```

### LRU缓存

```c
struct DLinkedNode {
    int key, value;
    DLinkedNode* pre;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), pre(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), pre(nullptr), next(nullptr) {}
};


class LRUCache {
public:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head=nullptr;
    DLinkedNode* tail=nullptr;
    int size=0;
    int capacity=0;

    LRUCache(int capacity) {
        this->capacity = capacity;
        head = new DLinkedNode(-1,-1);
        tail = new DLinkedNode(-1,-1);
        head->next = tail;
        tail->pre = head;
    }

    ~LRUCache() {
        delete head;
        delete tail;
        for(auto &[k,v]:cache)
            delete v;
    }
    
    int get(int key) {
        if(cache.count(key)) 
        {
            DLinkedNode* nd = cache[key];
            delnode(nd);
            pushnode(nd);
            return nd->value;
        }
        return -1;
    }
    
    void put(int key, int value) {
        if(!cache.count(key)) 
        {
            cache[key] = new DLinkedNode(key,value);
            pushnode(cache[key]);
        }
        else
        {
            cache[key]->value = value;
            DLinkedNode* nd = cache[key];
            delnode(nd);
            pushnode(nd);
            return;
        }
        if(++size>capacity)
        {
            size--;
            //cout << key << size << head->next->key <<endl;
            cache.erase(head->next->key);
            DLinkedNode*  temp = head->next;
            head->next = head->next->next;
            delete temp;
            head->next->pre = head;
        }
    }
    void delnode(DLinkedNode* nd)
    {
        nd->pre->next = nd ->next;
        nd->next->pre = nd ->pre;
    }

    void pushnode(DLinkedNode* nd)
    {
        tail->pre->next = nd;
        nd->pre = tail->pre;
        tail->pre = nd;
        nd->next = tail;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



### [最小的K个数](https://www.acwing.com/solution/content/1781/)

![image-20240820014721396](img/image-20240820014721396.png)

```c
class Solution {
public:
    vector<int> getLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> res;
        for(int i = 1;i <= k;i++)
            res.push_back(quick_select(input,0,input.size()-1,i));
        return res;
    }

    int quick_select(vector<int>& q,int l,int r,int k)
    {
        if(l >= r) return q[l];
        int i = l-1,j = r+1,x = q[l+r >> 1];
        while(i < j)
        {
            do i++;while(q[i] < x);
            do j--;while(q[j] > x);
            if(i < j) swap(q[i],q[j]);
        }
        if(k <= j-l+1) return quick_select(q,l,j,k);
        else return quick_select(q,j+1,r,k-(j-l+1));
    }

};

```



```c
class Solution {
public:
    vector<int> getLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> res;
        priority_queue<int> heap;
        for(auto x : input)
        {
            heap.push(x);
            if(heap.size() > k) heap.pop(); 
        }
        while(heap.size())
        {
            res.push_back(heap.top());
            heap.pop();
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

# ==MYSQL==

# 介绍

![查询语句执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

**Server 层负责建立连接、分析和执行 SQL**

**存储引擎层负责数据的存储和提取**

# 基础篇

## 执行语句流程都发生什么



> ### 第一步：连接器
>
> - 连接的过程需要先经过 TCP 三次握手，因为 MySQL 是==基于 TCP 协议进行传输==的，如果 MySQL 服务 并没有启动
>
> - 如果一个用户已经==建立了连接==，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的 权限。
> - MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个, 超过这个值，系统就会拒绝接下来的连接请求

> ### 第二步：查询缓存
>
> - MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的==第一个==字段，看看是什么类型的语句
>
> - 如果 SQL 是查询语句（select 语句），MySQL 就会先去==查询缓存==（ Query Cache ）里查找缓存数据
> - MySQL 8.0 版本直接将查询缓存删掉了

> ### 第三步：解析 SQL
>
> 第一件事情，==词法分析==。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和 from
>
> 第二件事情，==语法分析==。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会==构建出 SQL 语法树==

> ### 第四步：执行SQL
>
> 预处理器，优化器，执行器
>
> * 主键索引查询 
> * 全表扫描 
> * 索引下推



## 一行记录是怎么存储的

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png)



> MySQL 行、页、区、段、表空间什么联系？
>
> - ==行就是一条一条的数据==，并按照行格式，包含一些字段记录头的信息。
>
> - 多个行组合成一个页，页是指存储引擎使用的最小的数据存储单位。
>   64个连续页组成一个区，默认一个区16KB大小，64个区刚好1MB。
>
> - 多个区组成一个段，==段是数据库的分配单位==。
>
> - 多个段组成一个表空间，表空间是逻辑上的存在，表空间又分为系统表空间，用户表空间，撤销表空间和临时表空间。
>
> 
>
> MySQL 行、页、区、段、表空间存在的意义是什么，解决了什么问题？
>
> - 行：就是一条条的数据，专门把数据放表服务于业务，没什么好说的。
> - 页：是指存储引擎使用的最小的数据存储单位，当 MySQL==执行读取或写入操作时，是以页为基本单位来进行操作的==，若引擎对数据读写逐行处理，太细的粒度的读写会增加硬盘 I/O 次数，降低性能。
>
> - 区：区的引入有助于让链表中相邻的页的==物理位置也相邻==，这样就可以使用顺序 I/O 了
>
> - 段：帮助数据库系统更好地优化存储空间的使用和数据访问的效率。
>
> - 表空间：通过表空间的划分和管理，可以实现对数据存储结构的灵活控制和优化

### 行格式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png)

### varchar最大长度和溢出处理

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png)

字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535

# 索引

## 索引分类

> 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。 
>
> 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）。**
>
> 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引。** 
>
> 按「字段个数」分类：**单列索引、联合索引。**



## 回表

二级索引获得主机值，再在主键索引的B+tree找到子节点的一行数据



## 索引的优缺点

![image-20240909162523704](E:\codenotes\JOB\Interview\img\image-20240909162523704.png)

经常使用的查询字段建立索引，而分辨力不强的，大量重复的就不需要建立索引





## 索引的优化

- 使用字符串前缀进行索引
- 如果只需要id  价格  名称  ，并且查询很频繁，可以直接建立一个联合索引
- 主键最好自增
- 索引最好not null，应该可能会影响优化和效率



## 页目录

![图片](https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png)

从图可以看到，页目录就是由多个槽组成的，槽相当于分组记录的索引。然后，因为==记录是按照 「主键值」从小到大排序的==，所以我们通过槽查找记录时，可以使用==二分法快速定位要查询的记录 在哪个槽==（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小 记录开始遍历整个页中的记录链表。



# 数据结构

## B树和B+树

> ### B树
>
> ![image-20240909163135697](E:\codenotes\JOB\Interview\img\image-20240909163135697.png)
>
> - **特点**：B树是一种自平衡的树数据结构，每个节点可以包含多个键和值，保证了数据的有序性和高效性。
> - **应用**：适用于存储索引数据，支持高效的查找、插入和删除操作。
> - **优势**：能够保持平衡，保证了操作的时间复杂度为 O(log⁡n)。
>
> 



> ### B+树
>
> ![image-20240909163223258](E:\codenotes\JOB\Interview\img\image-20240909163223258.png)
>
> - **特点**：B+树是B树的变种，所有实际数据存储在叶子节点中，内部节点只存储索引。
>
> - **应用**：广泛用于数据库索引结构，如MySQL的InnoDB存储引擎。
>
> - ==链表==：
>
>   - **高效遍历**：双向链表连接叶子节点，使得可以在O(1)的时间复杂度内进行顺序遍历。这对于范围查询和区间查找非常有效。
>
>   - **支持范围查询**：通过双向链表，用户可以在找到一个满足条件的记录后，快速访问其后续的记录。例如，查找某个值后，可以轻松访问到所有大于该值的记录。
>
>   - **减少磁盘I/O**：在数据库中，顺序访问通常比随机访问更高效。双向链表允许在叶子节点间快速移动，减少了磁盘I/O的次数，从而提高了性能。







## B vs B+ vs hash

![image-20240909162239005](E:\codenotes\JOB\Interview\img\image-20240909162239005.png)







# 乐观锁和悲观锁

### 区别

>​     乐观锁：认为别人不会同时修改数据，因此乐观锁默认是不会上锁的，只有在执行更新的时候才会去判断在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。
>
>​     悲观锁：认为别人一定会同时修改数据，因此悲观锁在操作数据时是直接把数据上锁，直到操作完成之后才会释放锁，在上锁期间其他人不能操作数据。
>
>
>
>==读取频繁使用乐观锁，写入频繁使用悲观锁==

> 
>
> ### 悲观锁（Pessimistic Locking）
>
> #### 特点
>
> - **锁定策略**：悲观锁假定数据在并发环境下会发生冲突，因此在读写数据之前，都会锁定数据。
> - **锁定范围**：通常包括行锁、表锁，甚至数据库级别的锁。
> - **加锁时间**：在读取数据时就加锁，直到事务结束才释放锁。
>
> #### 优点
>
> - **数据一致性高**：通过加锁保证了在并发操作下的数据一致性和完整性。
> - **适用于高冲突场景**：在高冲突的场景下，能够有效防止数据的并发修改问题。
>
> #### 缺点
>
> - **性能开销大**：由于频繁加锁、解锁，系统的性能开销较大，容易导致死锁问题。
> - **并发性低**：由于锁的存在，会导致较低的并发性能，其他事务需要等待锁释放。
>
> #### 适用场景
>
> - **高冲突场景**：数据冲突较多的场景，如银行转账系统。
> - **关键数据更新**：数据一致性要求极高的场景。
>
> #### 示例
>
> 在关系型数据库中，使用悲观锁可以通过SQL语句实现：
>
> ```
> sql复制代码-- 悲观锁示例，使用SELECT ... FOR UPDATE语句
> BEGIN;
> SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
> -- 对数据进行更新操作
> UPDATE accounts SET balance = balance - 100 WHERE id = 1;
> COMMIT;
> ```
>
> ### 乐观锁（Optimistic Locking）
>
> #### 特点
>
> - **锁定策略**：乐观锁假定数据在并发环境下不会发生冲突，因此在读写数据之前不会加锁，只在提交数据时进行冲突检测。
> - **冲突检测**：通常通过版本号或时间戳来检测数据是否发生变化。
> - **加锁时间**：仅在提交数据时检测并发冲突，如果检测到冲突则回滚事务。
>
> #### 优点
>
> - **性能开销低**：因为不需要频繁加锁和解锁，系统的性能开销较低。
> - **并发性高**：允许更多的事务并发执行，提高系统的并发性能。
>
> #### 缺点
>
> - **数据一致性较低**：在高冲突场景下，可能会频繁回滚事务，导致性能下降。
> - **重试机制复杂**：事务冲突时需要进行重试，增加了实现的复杂度。
>
> #### 适用场景
>
> - **低冲突场景**：数据冲突较少的场景，如用户个人信息更新。
> - **读多写少**：读操作多于写操作的场景。
>
> #### 示例
>
> 在关系型数据库中，使用乐观锁可以通过版本号实现：
>
> ```
> sql复制代码-- 乐观锁示例，使用版本号机制
> -- 假设accounts表中有一个version列
> BEGIN;
> -- 读取数据及其版本号
> SELECT id, balance, version FROM accounts WHERE id = 1;
> -- 更新操作时，检查版本号是否一致
> UPDATE accounts SET balance = balance - 100, version = version + 1 
> WHERE id = 1 AND version = <old_version>;
> COMMIT;
> ```
>
> 



# 事务

![image-20240906120631681](E:\codenotes\JOB\Interview\img\image-20240906120631681.png)

## 事务的特征

> #### 1. 原子性（Atomicity）
>
> 事务必须是一个不可分割的工作单位，其中的所有操作要么全部完成，要么全部不完成。如果事务在进行中遇到错误或其他情况需要中止，那么已经执行的所有操作必须撤销，即回滚。
>
> #### 2. 一致性（Consistency）
>
> 事务必须使数据库从一个一致性状态转变到另一个一致性状态。回滚确保在事务失败时，数据库不会处于不一致的状态。
>
> #### 3. 隔离性（Isolation）
>
> 事务的执行是隔离的，一个事务的操作对其他事务是不可见的，直到事务提交为止。如果在提交前检测到并发冲突，回滚确保不会将未完成的、不一致的数据暴露给其他事务。
>
> #### 4. 持久性（Durability）
>
> 一旦事务提交，修改就会永久保存到数据库中，不会因为系统崩溃或其他原因丢失。回滚操作在事务提交前进行，不影响已经提交的持久化数据。

## 事务回滚

在数据库管理系统中，事务（Transaction）是指一组逻辑操作单元，这些操作要么全部成功，要么全部失败。

> ### 事务回滚的工作机制
>
> 1. **事务开始**：事务开始时，数据库系统记录当前状态，通常使用日志来记录事务的各项操作。
> 2. **操作执行**：事务执行过程中，所有操作的修改不会立即写入持久存储，而是暂时保存在缓存中。
> 3. **冲突检测**：在事务提交前，系统会检测是否存在并发冲突（如版本号不一致）。
> 4. **回滚操作**：如果检测到冲突或遇到其他错误，系统将利用日志中记录的原始状态信息，撤销事务中已执行的操作，将数据恢复到事务开始前的状态。
> 5. **事务结束**：如果事务没有遇到冲突且成功执行所有操作，则进行提交操作，将所有修改永久写入数据库。



> ### 事务回滚的示例
>
> 假设有两个用户同时尝试更新同一个银行账户的余额：
>
> ```
> sql复制代码-- 事务1
> BEGIN;
> SELECT balance FROM accounts WHERE id = 1;
> -- balance = 100
> UPDATE accounts SET balance = balance - 50 WHERE id = 1;
> -- 修改还未提交
> 
> -- 事务2
> BEGIN;
> SELECT balance FROM accounts WHERE id = 1;
> -- balance = 100
> UPDATE accounts SET balance = balance - 30 WHERE id = 1;
> -- 修改还未提交
> 
> -- 事务1提交
> COMMIT;
> -- 提交成功，账户余额更新为50
> 
> -- 事务2提交
> -- 检测到并发冲突，因为事务2读取的balance是旧值100而非最新值50
> -- 事务2回滚，撤销更新操作，账户余额恢复到提交前的状态50
> ROLLBACK;
> ```
>
> ==重点在 COMMIT  ROLLBACK==
>
> 



### 提交COMMIT

```
set autocommit=0; set autocommit=OFF;
```

**MySQL**：在默认的自动提交模式下，`UPDATE`后会立即提交。如果事务已开始（通过`START TRANSACTION`），你需要显式地调用`COMMIT`来保存更改。

### 回滚ROLLBACK

###  悲观锁FOR UPDATE

> 在SQL中，`FOR UPDATE` 子句用于在执行查询时锁定所选记录，==防止其他事务修改==这些记录。这种锁定机制对于实现==悲观锁==非常重要。
>
> 
>
> #### 不加 `FOR UPDATE`
>
> ```
> sql
> 复制代码
> SELECT * FROM accounts WHERE id = 1;
> ```
>
> - **读操作**：直接读取数据，不会对数据进行任何锁定。
> - **并发性**：多个事务可以同时读取相同的数据，不会相互阻塞。
> - **数据一致性**：不能保证在读取数据到更新数据之间，数据不会被其他事务修改。可能会导致“不可重复读”或“幻读”等并发问题。
>
> #### 加 `FOR UPDATE`
>
> ```
> sql
> 复制代码
> SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
> ```
>
> - **读操作**：读取数据并加锁（通常是行锁）。
> - **并发性**：==其他事务在试图读取相同的数据时，如果也使用`FOR UPDATE`，将被阻塞，直到当前事务释放锁。==
> - **数据一致性**：保证在读取到更新数据之间，数据不会被其他事务修改，避免了“不可重复读”和“幻读”问题。
>
> 
>
> 
>
> 
>
> ### 具体应用场景与示例
>
> #### 不加 `FOR UPDATE` 的场景
>
> 1. **只读操作**：当你只需要读取数据，不进行任何修改时，不需要加锁。例如，生成报表或统计数据。
> 2. **低并发要求**：在不需要严格控制并发的应用中，可以避免加锁带来的性能开销。
>
> 
>
> #### 加 `FOR UPDATE` 的场景
>
> 1. **事务完整性**：需要在读取后进行更新操作，并确保数据在读取到更新之间不被其他事务修改时。
> 2. **高并发控制**：在多用户高并发的环境中，需要严格控制数据一致性。
>
> 



# Q:反问环节

几轮面试

工作时长和出差情况

入职培养机制





```
[238]: 好的，嗯，直接离开会议就可以了，再见。

[237]: 嗯，好的，呃，感谢您的参与啊，这样你把你把修改完的代码发一份到聊天框。

[236]: 没有大小。

[235]: 没有打什么时，具体你可以问一下HR。

[234]: 嗯嗯。

[233]: 加班的话，我只能说比那些大厂，比那些大厂好一些。

[232]: 加班出差，嗯，出差的话，我目前没有没有出差，没有出差过。

[231]: 按公司的政策来决定吧。

[230]: 啊，但是但是具体政策我我我我不太清楚啊，因为我来这个公司的时候，我已经不是应届生了，而且这个需要根据。

[229]: 你需要你自己去租房。

[228]: 嗯，据我了解的话，第一年的话是会给你们租一个在公司附近租一个房间的，第二年的话就是正常的。

[227]: 嗯。

[226]: 参与讨论。

[225]: 哦，薪资的话，这这个呃，你还是需要和HR去讨论，然后网上也有一些公布的信息，这个我们是不参与的。

[224]: 被大胆，那你大家可以大胆的问没有就没有的话，我们今天就。

[223]: 你还有其他问题吗？

[222]: 嗯，好的。

[221]: 嗯，好的锁以你是更倾向于做客户端是吗。

[220]: 嗯嗯。

[219]: 嗯嗯，好的。

[218]: 嗯，你你你你哎等我稍微我问一个问题，你是想之后去做服务端客户端，还是说想去做其他的呢。

[217]: 嗯，是。

[216]: 因为我们公司还有一些其他的岗位，之后是可以根据你的意愿进行调整。

[215]: 你你你怎样，还是说你做什么都可以呢？

[214]: 嗯，你是期望做其他的呢，还是说你你。

[213]: 这是第一面技术面试面基础，后面的就是考你的算法以及其他的。

[212]: 技术面的话一共有3个，然后还有一轮HR面。

[211]: 没事儿没事儿，你你你别紧张，你别紧张。

[210]: 嗯，昨天差不多的已经超时了，然后我这边的问题已经问完了，你有什么需要问的吗？

[209]: 嗯，就那你刚才删掉那一行代码的。

[208]: 那就什么法引用技术那个delete删掉。

[207]: 那如果还有人引用，那还有有有人共享他的，你就直接给他删了。

[206]: 你就直接释放呀，你就直接释放。

[205]: 他本来指向的那一份地址以及它的引用技术需要变化吗？

[204]: 那对于operator，等于还有一个U，就是你offer就是你的offer，等于就意味着你你已经是一个创建好的对象了，对不对。

[203]: 那对于你的，嗯。

[202]: 啊啊，是。

[201]: 啊，那他的引用技术。

[200]: 它的引用技术。

[199]: 或者说我想创建两个一模一样的东西，但他们又有一点不一样，那我就需要去做一个拷贝构造。

[198]: 就是在什么场景下会有这种需求呢？就是我想一个做备份，然后去修改另外一个的值。

[197]: 那有没有可能，他不是想指向同一个内存，而是想要把同一个内存里面放的数据复制成两份？

[196]: 拷贝构造就是其实是一个复制的过程，对吧。

[195]: 就是让一个让多，让多个指针指向同一个地址的这个一个共享指针，那我是应该用拷贝多造，而不是用等于什么。

[194]: 嗯。

[193]: 嗯嗯，那如果我想创建一个。

[192]: 布置的过程是吗？

[191]: 就是它是一个是创建一个新的，然后一个只是一个复制。

[190]: 哦，好，那那那如果你觉得你是错的，那么这两者被你修改之后，他们就变成一样了，他俩他两个有区别吗？

[189]: 哦，不是质疑啊，我是和你探讨啊，我不是说你做错了，你可以告诉我为什么这么做，如果你觉得你做的是对的，然后这样对的理由是什么？

[188]: 呃，操作等于的重写有什么区别呢？

[187]: 那它和O等于的区别是什么？

[186]: 拷贝构造，你这里是希望他们两个其实是指向了同一块儿区域还是不同的区域呢？如果是相同的区域，嗯，那你为什么要加加呢？如果是不同的区域，你为什么需要6呢？

[185]: 呃。

[184]: 我没这么大。

[183]: 那我看一下。

[182]: 嗯嗯，关于这个拷贝构造，如果拷贝构造。

[181]: 它是首先它是一个构造函数，那它和有参和无餐对于这个技术值的处理有什么不同吗？

[180]: 并不是node，并不是no的这个。

[179]: Count的值呢，因为T它并不是这个。

[178]: 点击。

[177]: 呃，你的你的第13行，为什么这个other它会有一个。

[176]: 嗯。

[175]: 嗯，好的，你在我有，我有一些疑问。

[174]: 干完了哦，男。

[173]: 嗯，那你现在就是尝试修改一下吧。

[172]: 哎，对对，我们讨论了这么多之后，你是否想要对你的代码进行修改，你有思路吗？

[171]: 析构函数，那么剩下两个是不是就会变成一两个悬挂指针？

[170]: 我其中一个，我给他释放了，他就调用你的。

[169]: 你就是我在虚构的过程中，比如说我现在有3个这样的指针，还是刚才那个。

[168]: 啊，再回来，假设不考虑这个就是你，在你的虚构函数中，我有一个疑问。

[167]: 那那你要修改吗。

[166]: 啊，我没有说不能啊，只是讨论一下你这个用这个int的可能性。

[165]: 233应该说是233。

[164]: 嗯，只不过你这个样子好像是也加，因为你用的是加加对吧？啊，那那那如果再复制第三个呢，那如果再复制第三个的话，那它的数量是不是就变成了223。

[163]: 或者或者或者反过来。

[162]: 那么。

[161]: 那个引用技术。

[160]: 它加，因为它只是一个int对吧，那它第二个的数字是2，那第一个的数字就是1。

[159]: 这个时候你的技术加1了，那么。

[158]: 然后通过operator等于创建了两个指针指向了同一个地址，对吧。

[157]: 第一个是什么？第一个是午参构造，你创建了一个指针。

[156]: 就是比如说他的这个。

[155]: 呃，就是在。

[154]: 嗯，那一样的话，那我们来一起看一下你这个里面的操作吧。

[153]: 我不是，我不是质疑你啊，我就是跟你讨论一下。

[152]: 就是你这个定义。

[151]: 嗯，那你这样实现能一样吗？

[150]: 呃，我有两个指针指向了相同的对象，那么他们的引用技术的值应该是一样的是吗？

[149]: 那就是说。

[148]: 嗯嗯。

[147]: 嗯，是。

[146]: 怎样的需求吧。

[145]: 需求嘛，你可以，你可以再说一次引用技术，它是一个。

[144]: 嗯，如果是一个int的话，它能够实现你用技术的。

[143]: 他们需要。

[142]: 的访问权限需要修改一下吗？

[141]: 呃，就是说相对于做题而言，这算是一个更加正式的代码，你的成员变量。

[140]: 嗯，你的。

[139]: 我们一起来看一下你这样代码。

[138]: 嗯，那你先复制一份发到聊天框。

[137]: 写完了之后你看。

[136]: 对，是。

[135]: 哎。

[134]: 你是需要我给你提示吗？还是你要自己想一想？

[133]: 为什么五三不是行？

[132]: 哎。

[131]: 嗯。

[130]: 我看。

[129]: 嗯嗯，但我这个写的可能。

[128]: 嗯，对，模板内的写法我发到聊天框中，如果你想使用的话，你可以使用一下。

[127]: 呃，模板类的写法。

[126]: 嗯。

[125]: 啊，你不用把它想的很复杂，它就是一个考察你对指针的一个使用。

[124]: 其实就是要你实现一个共享指针，然后它是一个模板。

[123]: 题目的要求就是让你实现一个类，你可以把目前这个代码删掉，或者怎样都行。

[122]: 嗯，聊天框是我发了一个。

[121]: 就在那个一排按钮的当中啊，我收到我收到，嗯，我收到。

[120]: 嗯嗯嗯，好的。

[119]: 呃呃。

[118]: 就是不考虑做题的简便性吗？

[117]: 啊。

[116]: 嗯，那那你那你目前的这个数据结构，你觉得是安全的吗。

[115]: 嗯。

[114]: 那你就讲一下这个访问权限吧，就是public protected.

[113]: 那你就讲一下那个，呃。

[112]: 你先把你的代码复制一份发到聊天框，我们做一下记录。

[111]: 那你have不是就等于free？

[110]: 但是你的，但是你的had不是had next不是已经等于pre了吗？

[109]: 那你先讲一下你的思路吧，先讲下你的思路，再还有什么说出不对吗？

[108]: 哎。

[107]: 嗳。

[106]: 哎。

[105]: 呃呃。

[104]: 嗯。

[103]: 哦。

[102]: 哎。

[101]: 嗯，我就写一个1~5的。

[100]: 就是关于其他的，我暂时不做要求。

[99]: 就是如果是12345，那么反转之后就变成54321。

[98]: 嗯。

[97]: 呃呃，不能修修改啊，对是。

[96]: 呃，要求不能修改链，不能直接修改链表里面的值。

[95]: 不是输出都是头节点的指针。

[94]: 不不不不不不嗯啊是是是是，但是你你你它是一个单，它是一个单向链表，你你你这个写的是双向。

[93]: 嗯。

[92]: 嗯，要求输入输出都是这个链表头节点指针。

[91]: 是。

[90]: 嗯，可以看见。

[89]: 单项链表，然后链表的结构需要你自己写，你没用T就可以了。

[88]: 你可以先把函数写出来之后再看要不要写测试用例。

[87]: 嗯，是。

[86]: 呃，都行，你你做的话，那你就写吧，你做没做我都得写一下，那你就开一下屏幕共享，然后写一个代表反转。

[85]: 那我们做一个，我们做了一个简单的算法题吧，呃，列表反转，你你有做过吗？

[84]: 嗯，那你对。

[83]: 嗯嗯嗯，好的。

[82]: 嗯，可以。

[81]: 比如说，比如说我从头到尾遍历一下我的磁盘，或者说是别的方法。

[80]: 就是肯定有一个规则嘛，对吧，或者说是有一个什么机制。

[79]: 就是他是怎么样在一个内存中寻找这样一块区域的呢。

[78]: 嗯，让他寻找这一块新的八字节的空间，是一个怎样的寻找过程？

[77]: 他的一些操作是一个怎样的步骤？

[76]: 让他扩容，选择那个新的一块内存。

[75]: 那它扩容的。

[74]: 嗯。

[73]: 嗯，好的。

[72]: 就是它的底层。

[71]: 基本的构造什么的。

[70]: 他的一些。

[69]: 就是它的使用，然后它的一些。

[68]: 嗯，你对vector有什么了解吗？

[67]: 好的。

[66]: 嗯，好的，那你对共享指针有什么了解呢？

[65]: 嗯，好的，你刚才提到智能指针，那你对智能指针有什么了解呢？

[64]: 嗯，那你如何避免内存泄露，应该还有其他内存泄露。

[63]: 嗯嗯，好的。

[62]: 嗯，相关的东西，比如说他还可以说和那什么有什么区别，就是你除了知道你有一个对象之外，还有其他的什么方法可以创建一个对象。

[61]: 嗯。

[60]: 比如说你用new去创建一个对象，它会返回给你一个指针，然后你需要对它的空间进行释放，就是这是，这是我希望你回答的，不是说我告诉你，就是你可以把你了解的相关的说出来就是。

[59]: 不是说。

[58]: 你对你有什么了解吗？

[57]: 呃呃，怎样创建一个指针吧，对于指针你有什么了解吗？就比如说用new这种拼音溜出一个指针。

[56]: 啊，就是比如说你可以创建一个。

[55]: 嗯，好的，刚才提到了一个对象的创建，那你一般是怎样创建一个对象。

[54]: 嗯，对。

[53]: 程序还是要了解吗？

[52]: 嗯，那你对。

[51]: 嗯，他这问题是我回答出来的。

[50]: 呃，但是指针它是属于对象的是吧，但是对象并不是在编译的时候创建的，而是在运行的时候调用到创建的这个指针，它才会创建。

[49]: 嗯，对，就是那个表的指针。

[48]: 嗯，他刚才提到的那个指针你还记得吗？就是这个指针，同样的它是在什么时候创建和存储在哪儿呢。

[47]: 嗯嗯，好的。

[46]: 是继就继承一个鸡类，但是这个鸡类的虚函数它没有重写，那么它就没有这个表是吗？

[45]: 嗯嗯，好的，那就是如果我们子类继承了一个。

[44]: 啊，对，是。

[43]: 不，不就是。

[42]: 就是，嗯。

[41]: 当你提到重写的时候，重写是指我们写代码的时候。

[40]: 嗯嗯，那这个表它在什么时候创建呢？它会存储在哪个地方呢。

[39]: 就是它肯定是一个映射关系对吧。

[38]: 嗯，那你总结一下算了，不总结了啊，那你知道这个重写的方法是是存在一个怎样的东西当中呢。

[37]: 那你刚才有。

[36]: 嗯嗯，好的。

[35]: 嗯，不是啊，你对多肽有了解吗？

[34]: 嗯。

[33]: 嗯，好的好的。

[32]: 嗯，那如果是按最大的话，那你其他的答案要修改吗？

[31]: S3了2分。

[30]: 嗯嗯嗯，那那锁以他自己的补齐是怎么补的呢。

[29]: 嗯。

[28]: 嗯，可以可以。

[27]: 刚才给出的答案是12。

[26]: 嗯，你能再分析一下第4个计算过程。

[25]: 不知道自己。

[24]: 嗯。

[23]: 嗯，对，你可以分析一下计算过程，然后再告诉我结果。

[22]: 嗯，可以计算出他们占用的内内存，对其后占用的内存大小嘛，自己。

[21]: 嗯，好的，嗯，聊天框中我发了4个结构题，你可以看到。

[20]: 嗯，内存占用的内存大小是你刚才说到最小嘛，因为你刚才提到要按照最小来对齐。

[19]: 但是刚才提到这个自定义。

[18]: 嗯嗯。

[17]: 嗯，好的，那你刚才提到4字节对齐，它是只能进行4字节对齐。

[16]: 嗯。

[15]: 啊，不是内存对齐的有缺点。

[14]: 嗯，好的，那他的优缺点是什么。

[13]: 嗯，你对内存对企业有了解吗？

[12]: 嗯嗯，好的。

[11]: 嗯，好的，我们今天主要是面一些C加加的基础，还有上马琴这边都OK吗？等下可以共享屏幕携带代码代码吗？

[10]: 你好，我是今天的面试官，你先自我介绍一下。

[9]: 哎呀。

[8]: 嗯，可以的，可以。

[7]: 嗯，声音忽大忽小的。

[6]: 嗯嗯，能不太你你声音可以大一点吗？感觉不是听得很清楚。

[5]: 你好，可以听到吗？

[4]: 风多布里奇。

[3]: 阿夫拉莫维奇，小前锋。

[2]: 哎。

[1]: 嘿嘿。

[0]: 再加上30号空位阿夫拉莫。


```





