

# 介绍

![查询语句执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

**Server 层负责建立连接、分析和执行 SQL**

**存储引擎层负责数据的存储和提取**

# 基础篇

## 执行语句流程都发生什么



> ### 第一步：连接器
>
> - 连接的过程需要先经过 TCP 三次握手，因为 MySQL 是==基于 TCP 协议进行传输==的，如果 MySQL 服务 并没有启动
>
> - 如果一个用户已经==建立了连接==，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的 权限。
> - MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个, 超过这个值，系统就会拒绝接下来的连接请求

> ### 第二步：查询缓存
>
> - MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的==第一个==字段，看看是什么类型的语句
>
> - 如果 SQL 是查询语句（select 语句），MySQL 就会先去==查询缓存==（ Query Cache ）里查找缓存数据
> - MySQL 8.0 版本直接将查询缓存删掉了

> ### 第三步：解析 SQL
>
>  第一件事情，==词法分析==。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和 from
>
>  第二件事情，==语法分析==。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会==构建出 SQL 语法树==

> ### 第四步：执行SQL
>
> 预处理器，优化器，执行器
>
> * 主键索引查询 
> * 全表扫描 
> * 索引下推



## 一行记录是怎么存储的

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png)



> MySQL 行、页、区、段、表空间什么联系？
>
> - ==行就是一条一条的数据==，并按照行格式，包含一些字段记录头的信息。
>
> - 多个行组合成一个页，页是指存储引擎使用的最小的数据存储单位。
>   64个连续页组成一个区，默认一个区16KB大小，64个区刚好1MB。
>
> - 多个区组成一个段，==段是数据库的分配单位==。
>
> - 多个段组成一个表空间，表空间是逻辑上的存在，表空间又分为系统表空间，用户表空间，撤销表空间和临时表空间。
>
>   
>
> MySQL 行、页、区、段、表空间存在的意义是什么，解决了什么问题？
>
> - 行：就是一条条的数据，专门把数据放表服务于业务，没什么好说的。
> - 页：是指存储引擎使用的最小的数据存储单位，当 MySQL==执行读取或写入操作时，是以页为基本单位来进行操作的==，若引擎对数据读写逐行处理，太细的粒度的读写会增加硬盘 I/O 次数，降低性能。
>
> - 区：区的引入有助于让链表中相邻的页的==物理位置也相邻==，这样就可以使用顺序 I/O 了
>
> - 段：帮助数据库系统更好地优化存储空间的使用和数据访问的效率。
>
> - 表空间：通过表空间的划分和管理，可以实现对数据存储结构的灵活控制和优化

### 行格式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png)

### varchar最大长度和溢出处理

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png)

字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535

# 索引

## 索引分类

> 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。 
>
> 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）。**
>
>  按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引。** 
>
> 按「字段个数」分类：**单列索引、联合索引。**



## 回表

二级索引获得主机值，再在主键索引的B+tree找到子节点的一行数据



## 索引的优缺点

![image-20240909162523704](E:\codenotes\JOB\四大件\MYSQL\img\image-20240909162523704.png)

经常使用的查询字段建立索引，而分辨力不强的，大量重复的就不需要建立索引





## 索引的优化

- 使用字符串前缀进行索引
- 如果只需要id  价格  名称  ，并且查询很频繁，可以直接建立一个联合索引
- 主键最好自增
- 索引最好not null，应该可能会影响优化和效率



## 页目录

![图片](https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png)

从图可以看到，页目录就是由多个槽组成的，槽相当于分组记录的索引。然后，因为==记录是按照 「主键值」从小到大排序的==，所以我们通过槽查找记录时，可以使用==二分法快速定位要查询的记录 在哪个槽==（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小 记录开始遍历整个页中的记录链表。



# 数据结构

## B树和B+树

> ### B树
>
> ![image-20240909163135697](E:\codenotes\JOB\四大件\MYSQL\img\image-20240909163135697.png)
>
> - **特点**：B树是一种自平衡的树数据结构，每个节点可以包含多个键和值，保证了数据的有序性和高效性。
> - **应用**：适用于存储索引数据，支持高效的查找、插入和删除操作。
> - **优势**：能够保持平衡，保证了操作的时间复杂度为 O(log⁡n)。
>
> 



> ### B+树
>
> ![image-20240909163223258](E:\codenotes\JOB\四大件\MYSQL\img\image-20240909163223258.png)
>
> - **特点**：B+树是B树的变种，所有实际数据存储在叶子节点中，内部节点只存储索引。
>
> - **应用**：广泛用于数据库索引结构，如MySQL的InnoDB存储引擎。
>
> - ==链表==：
>
>   - **高效遍历**：双向链表连接叶子节点，使得可以在O(1)的时间复杂度内进行顺序遍历。这对于范围查询和区间查找非常有效。
>
>   - **支持范围查询**：通过双向链表，用户可以在找到一个满足条件的记录后，快速访问其后续的记录。例如，查找某个值后，可以轻松访问到所有大于该值的记录。
>
>   - **减少磁盘I/O**：在数据库中，顺序访问通常比随机访问更高效。双向链表允许在叶子节点间快速移动，减少了磁盘I/O的次数，从而提高了性能。







## B vs B+ vs hash

![image-20240909162239005](E:\codenotes\JOB\四大件\MYSQL\img\image-20240909162239005.png)







# 乐观锁和悲观锁

### 区别

>​     乐观锁：认为别人不会同时修改数据，因此乐观锁默认是不会上锁的，只有在执行更新的时候才会去判断在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。
>
>​     悲观锁：认为别人一定会同时修改数据，因此悲观锁在操作数据时是直接把数据上锁，直到操作完成之后才会释放锁，在上锁期间其他人不能操作数据。
>
>
>
>==读取频繁使用乐观锁，写入频繁使用悲观锁==

> 
>
> ### 悲观锁（Pessimistic Locking）
>
> #### 特点
>
> - **锁定策略**：悲观锁假定数据在并发环境下会发生冲突，因此在读写数据之前，都会锁定数据。
> - **锁定范围**：通常包括行锁、表锁，甚至数据库级别的锁。
> - **加锁时间**：在读取数据时就加锁，直到事务结束才释放锁。
>
> #### 优点
>
> - **数据一致性高**：通过加锁保证了在并发操作下的数据一致性和完整性。
> - **适用于高冲突场景**：在高冲突的场景下，能够有效防止数据的并发修改问题。
>
> #### 缺点
>
> - **性能开销大**：由于频繁加锁、解锁，系统的性能开销较大，容易导致死锁问题。
> - **并发性低**：由于锁的存在，会导致较低的并发性能，其他事务需要等待锁释放。
>
> #### 适用场景
>
> - **高冲突场景**：数据冲突较多的场景，如银行转账系统。
> - **关键数据更新**：数据一致性要求极高的场景。
>
> #### 示例
>
> 在关系型数据库中，使用悲观锁可以通过SQL语句实现：
>
> ```
> sql复制代码-- 悲观锁示例，使用SELECT ... FOR UPDATE语句
> BEGIN;
> SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
> -- 对数据进行更新操作
> UPDATE accounts SET balance = balance - 100 WHERE id = 1;
> COMMIT;
> ```
>
> ### 乐观锁（Optimistic Locking）
>
> #### 特点
>
> - **锁定策略**：乐观锁假定数据在并发环境下不会发生冲突，因此在读写数据之前不会加锁，只在提交数据时进行冲突检测。
> - **冲突检测**：通常通过版本号或时间戳来检测数据是否发生变化。
> - **加锁时间**：仅在提交数据时检测并发冲突，如果检测到冲突则回滚事务。
>
> #### 优点
>
> - **性能开销低**：因为不需要频繁加锁和解锁，系统的性能开销较低。
> - **并发性高**：允许更多的事务并发执行，提高系统的并发性能。
>
> #### 缺点
>
> - **数据一致性较低**：在高冲突场景下，可能会频繁回滚事务，导致性能下降。
> - **重试机制复杂**：事务冲突时需要进行重试，增加了实现的复杂度。
>
> #### 适用场景
>
> - **低冲突场景**：数据冲突较少的场景，如用户个人信息更新。
> - **读多写少**：读操作多于写操作的场景。
>
> #### 示例
>
> 在关系型数据库中，使用乐观锁可以通过版本号实现：
>
> ```
> sql复制代码-- 乐观锁示例，使用版本号机制
> -- 假设accounts表中有一个version列
> BEGIN;
> -- 读取数据及其版本号
> SELECT id, balance, version FROM accounts WHERE id = 1;
> -- 更新操作时，检查版本号是否一致
> UPDATE accounts SET balance = balance - 100, version = version + 1 
> WHERE id = 1 AND version = <old_version>;
> COMMIT;
> ```
>
> 



# 事务

![image-20240906120631681](E:\codenotes\JOB\四大件\MYSQL\img\image-20240906120631681.png)

## 事务的特征

> #### 1. 原子性（Atomicity）
>
> 事务必须是一个不可分割的工作单位，其中的所有操作要么全部完成，要么全部不完成。如果事务在进行中遇到错误或其他情况需要中止，那么已经执行的所有操作必须撤销，即回滚。
>
> #### 2. 一致性（Consistency）
>
> 事务必须使数据库从一个一致性状态转变到另一个一致性状态。回滚确保在事务失败时，数据库不会处于不一致的状态。
>
> #### 3. 隔离性（Isolation）
>
> 事务的执行是隔离的，一个事务的操作对其他事务是不可见的，直到事务提交为止。如果在提交前检测到并发冲突，回滚确保不会将未完成的、不一致的数据暴露给其他事务。
>
> #### 4. 持久性（Durability）
>
> 一旦事务提交，修改就会永久保存到数据库中，不会因为系统崩溃或其他原因丢失。回滚操作在事务提交前进行，不影响已经提交的持久化数据。

## 事务回滚

在数据库管理系统中，事务（Transaction）是指一组逻辑操作单元，这些操作要么全部成功，要么全部失败。

> ### 事务回滚的工作机制
>
> 1. **事务开始**：事务开始时，数据库系统记录当前状态，通常使用日志来记录事务的各项操作。
> 2. **操作执行**：事务执行过程中，所有操作的修改不会立即写入持久存储，而是暂时保存在缓存中。
> 3. **冲突检测**：在事务提交前，系统会检测是否存在并发冲突（如版本号不一致）。
> 4. **回滚操作**：如果检测到冲突或遇到其他错误，系统将利用日志中记录的原始状态信息，撤销事务中已执行的操作，将数据恢复到事务开始前的状态。
> 5. **事务结束**：如果事务没有遇到冲突且成功执行所有操作，则进行提交操作，将所有修改永久写入数据库。
>



> ### 事务回滚的示例
>
> 假设有两个用户同时尝试更新同一个银行账户的余额：
>
> ```
> sql复制代码-- 事务1
> BEGIN;
> SELECT balance FROM accounts WHERE id = 1;
> -- balance = 100
> UPDATE accounts SET balance = balance - 50 WHERE id = 1;
> -- 修改还未提交
> 
> -- 事务2
> BEGIN;
> SELECT balance FROM accounts WHERE id = 1;
> -- balance = 100
> UPDATE accounts SET balance = balance - 30 WHERE id = 1;
> -- 修改还未提交
> 
> -- 事务1提交
> COMMIT;
> -- 提交成功，账户余额更新为50
> 
> -- 事务2提交
> -- 检测到并发冲突，因为事务2读取的balance是旧值100而非最新值50
> -- 事务2回滚，撤销更新操作，账户余额恢复到提交前的状态50
> ROLLBACK;
> ```
>
> ==重点在 COMMIT  ROLLBACK==
>
> 



### 提交COMMIT

```
set autocommit=0; set autocommit=OFF;
```

**MySQL**：在默认的自动提交模式下，`UPDATE`后会立即提交。如果事务已开始（通过`START TRANSACTION`），你需要显式地调用`COMMIT`来保存更改。

### 回滚ROLLBACK

###  悲观锁FOR UPDATE

> 在SQL中，`FOR UPDATE` 子句用于在执行查询时锁定所选记录，==防止其他事务修改==这些记录。这种锁定机制对于实现==悲观锁==非常重要。
>
> 
>
> #### 不加 `FOR UPDATE`
>
> ```
> sql
> 复制代码
> SELECT * FROM accounts WHERE id = 1;
> ```
>
> - **读操作**：直接读取数据，不会对数据进行任何锁定。
> - **并发性**：多个事务可以同时读取相同的数据，不会相互阻塞。
> - **数据一致性**：不能保证在读取数据到更新数据之间，数据不会被其他事务修改。可能会导致“不可重复读”或“幻读”等并发问题。
>
> #### 加 `FOR UPDATE`
>
> ```
> sql
> 复制代码
> SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
> ```
>
> - **读操作**：读取数据并加锁（通常是行锁）。
> - **并发性**：==其他事务在试图读取相同的数据时，如果也使用`FOR UPDATE`，将被阻塞，直到当前事务释放锁。==
> - **数据一致性**：保证在读取到更新数据之间，数据不会被其他事务修改，避免了“不可重复读”和“幻读”问题。
>
> 
>
> 
>
> 
>
> ### 具体应用场景与示例
>
> #### 不加 `FOR UPDATE` 的场景
>
> 1. **只读操作**：当你只需要读取数据，不进行任何修改时，不需要加锁。例如，生成报表或统计数据。
> 2. **低并发要求**：在不需要严格控制并发的应用中，可以避免加锁带来的性能开销。
>
> 
>
> #### 加 `FOR UPDATE` 的场景
>
> 1. **事务完整性**：需要在读取后进行更新操作，并确保数据在读取到更新之间不被其他事务修改时。
> 2. **高并发控制**：在多用户高并发的环境中，需要严格控制数据一致性。
>
> 

