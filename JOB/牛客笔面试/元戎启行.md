## 自动驾驶小车平台介绍一下



## 时间同步能不能展开说一下



## 那激光雷达是怎么做同步的呢



## 这个OJ平台也介绍一下吧



## 负载均衡是怎么设计和计算的



## 哈希环比其他的算法好在哪里



## epoll了解多少



## 说一下线程池的设计原理

线程池是一种用于管理和复用线程的模式，主要用于提高多线程程序的效率、减少线程创建和销毁的开销，并确保系统资源得到合理利用。

### 1. **线程池的基本概念**

线程池是一组预先创建的线程集合，这些线程可以用来执行一系列任务。当有任务需要执行时，线程池会将任务分配给空闲的线程处理，而不是每次都创建新的线程。线程处理完任务后会回到线程池中，等待下一个任务。

### 2. **线程池的设计要素**

线程池的设计通常包括以下几个核心要素：

1. **线程队列**：存放线程的集合，通常由一个容器（如队列或列表）来管理线程。这些线程在任务完成后回到队列中等待新的任务。
2. **任务队列**：存放待处理任务的队列。当线程空闲时，会从任务队列中获取任务并执行。
3. **工作线程（Worker Threads）**：线程池中的线程，这些线程不断地从任务队列中取出任务并执行。
4. **线程池管理器**：负责管理线程池的生命周期、分配任务、处理线程的创建与销毁。线程池管理器通常包含线程池的初始化、线程的创建和销毁、任务的调度等功能。

### 3. **线程池的工作流程**

线程池的基本工作流程如下：

1. **初始化线程池**：在程序启动时，线程池会创建一组线程（通常称为工作线程），这些线程在创建后进入空闲状态，等待任务的到来。
2. **提交任务**：当有任务需要执行时，程序将任务提交给线程池。任务通常会被放入任务队列中，等待线程池中的线程来处理。
3. **任务调度**：线程池中的空闲线程会从任务队列中取出一个任务并执行。任务的执行可以是函数调用、对象方法执行等。线程在执行任务时，不会再处理其他任务。
4. **线程回收**：任务执行完成后，线程不会销毁，而是返回到线程池中，继续等待新的任务。这种线程复用机制减少了频繁创建和销毁线程的开销。
5. **动态调整**（可选）：根据系统负载情况，线程池可以动态调整线程的数量。例如，当任务量大时，线程池可以增加线程数，而当任务量减少时，可以减少线程数。

## 队列怎么包装一个任务

### 1. **使用 `std::function` 包装任务**

C++ 标准库提供了 `std::function` 类型，它可以存储任意可调用对象，包括普通函数、lambda 表达式、函数对象、成员函数等。使用 `std::function<void()>` 可以将任何类型的任务包装为一个统一的类型，并存储在任务队列中。

### 2. 类

在你的代码中，任务是通过 `Task` 类表示的，每个任务包含一个 `execute()` 方法，用于执行具体的操作。在向线程池添加任务时，使用的是指向 `Task` 对象的指针（`Task*`），然后线程池中的线程从任务队列中取出任务并调用 `execute()` 方法来执行任务

## 工作线程怎么取这些任务

比如多线程从一个队列里面拿，比如一些同步机制？



### 1. **任务队列和线程同步机制**：

- **互斥锁（Mutex）**：用于保护任务队列确保同一时间只有一个线程能够对任务队列进行操作
- **条件变量（Condition Variable）**：当任务队列为空时，工作线程会等待条件变量的通知；当有新任务加入队列时，条件变量通知等待的线程。

### 2. **线程安全地取任务的流程**

1. **锁定互斥量**：工作线程在访问任务队列之前，需要首先锁定互斥量，以确保其他线程无法同时访问任务队列。
2. **检查任务队列**：工作线程在持有互斥锁的情况下，检查任务队列是否为空。
   - 如果任务队列为空，工作线程会调用条件变量的 `wait` 方法，进入等待状态，同时释放互斥锁，允许其他线程继续工作。
   - 如果任务队列不为空，工作线程会从队列中取出一个任务，并解锁互斥锁。
3. **条件变量通知**：当有新的任务被添加到任务队列时，添加任务的线程会通知等待中的工作线程，唤醒它们去获取新的任务。

## 新特性了解多少



## lambda函数的方括号里面可以写什么，有什么不同



## **`NULL` 和 `nullptr` 在比较时的区别**

`NULL` 被视为整数 `0`，然后进行指针比较。在大多数情况下，它可以正常工作，因为编译器会将 `0` 转换为适当的指针类型。

- 但是，如果你在使用函数重载或模板时，这种比较可能会导致编译器无法正确推导类型，导致潜在的问题。例如，在函数重载中，如果有一个接受整数和另一个接受指针的重载，使用 `NULL` 可能会导致调用错误的重载。

- 当你使用 `ptr == nullptr` 进行比较时，`nullptr` 明确表示为一个空指针，编译器可以清楚地知道你在进行指针比较。它不会与整数混淆，因此更加类型安全



## 如果写Null==nullptr会发生什么

### 比较 `NULL == nullptr`：

1. 隐式转换
   - 编译器会将 `NULL`（即 `0`）隐式转换为 `nullptr` 可以比较的空指针类型。被转换为一个空指针，与 `nullptr` 进行比较时，它们都表示同样的空指针状态。

## 智能指针了解多少，可以在多线程环境使用么

### `unique_ptr`

需要在一个线程中创建一个对象并将其所有权传递给另一个线程。若不使用move编译报错，原因是 `std::unique_ptr` 的复制构造函数被删除（`delete`），它只允许通过移动语义来转移所有权。

###  `std::shared_ptr`

每次传递 `ptr` 给 `threadFunction`，都会创建一个新的 `std::shared_ptr` 副本，这个副本会增加引用计数。



## unique_ptr怎么实现不可拷贝的



## 引用是啥

引用是变量的别名，它在语法上提供了一种更简洁、安全的方式来访问和修改变量。虽然在底层实现中。本质就是一个指针常量引用一旦初始化后,就不可以发生改变 引用相当于指针常量,指针指向不可以修改,数值可以修改

## unique_ptr可以引用么

不可以

## 如果不行是运行错误还是编译错误

如果尝试对 `std::unique_ptr` 进行引用的代码是非法的，编译器会产生编译错误。

## share_ptr引用的话计数值怎么变

+1

## 右值左值的概念

**左值（Lvalue）**‌是指能够出现在赋值表达式左边的表达式。左值具有两个关键特性：它们可以取地址（即具有内存地址），并且可以被赋值。

**右值（Rvalue）**‌是指只能出现在赋值表达式右边的数值。右值通常指的是引用了一个存储在某个内存地址里的数据值。右值可以是常量、字面量、临时变量等，它们提供了要赋给左值的数据。右值相当于数据值本身，不具有左值的内存地址特性，因此不能被赋值或取地址。

## move原理是什么

那么我们能看出move就是将参数原来的修饰符全部都删掉，在强转为右值引用输出，就是这么简单，move没有干任何移动的过程

## 多态在c++怎么体现的

==静态多态==：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错  



==动态多态==：其实要实现动态多态，需要几个条件——即动态绑定条件：
\1. 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
\2. 通过基类类型的指针或引用来调用虚函数  



## 模板是啥

函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。使用任意类型(泛型)[描述函数](https://zhida.zhihu.com/search?q=描述函数&zhida_source=entity&is_preview=1)，在**编译时由编译器根据实参类型自动推导，实例化出该类型的函数定义**。



## 模板是怎么实现不同参数调用不同函数的，函数重载呢

**模板**

在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。编译器并不是把函数模板处理成能够处理任意类的函数；是根据函数模板调用时的具体类型产生不同的函数；

比如：**当用int类型使用函数模板时，编译器通过对实参类型的推演，将T确定为int类型，然后产生一份专门处理int类型的代码**，对于其他类型也是如此

**函数重载**

在上面的代码中，`print`函数被重载了三次，每次的参数类型不同。编译器在编译时会为每个重载版本生成独特的名字，以便于在链接时能够区分它们。



