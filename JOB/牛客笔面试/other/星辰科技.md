## `volatile` 的作用：

1. 防止编译器优化

   ：

   - 通常，编译器为了优化性能，可能会将变量的值存储在寄存器中而不是每次从内存中读取。如果某个变量在硬件或其他线程中发生了变化，而编译器没有重新从内存读取这个值，程序可能会得到错误的结果。
   - 使用 `volatile` 修饰的变量，编译器会保证每次使用该变量时都直接从内存中读取值，而不是使用缓存的值

## linux 内核了解



## 动态链接和静态区别

![image-20240926110055973](E:\codenotes\JOB\牛客笔面试\other\img\image-20240926110055973.png)

## 域名转换ip过程

dns

### 1. 用户输入域名

用户在浏览器中输入一个域名，例如 `www.example.com`。

### 2. 检查缓存

浏览器首先检查本地 DNS 缓存，看是否之前已经解析过该域名。如果有缓存，直接使用缓存中的 IP 地址。

### 3. 查询本地 DNS 服务器

如果本地没有缓存，浏览器会向配置的本地 DNS 服务器（通常是互联网服务提供商的 DNS 服务器）发送一个 DNS 查询请求。

### 4. 本地 DNS 服务器查询

本地 DNS 服务器也会检查自身的缓存。如果找到相应的记录，返回 IP 地址。如果没有，它会进行以下步骤：

#### 4.1 查询根 DNS 服务器

本地 DNS 服务器会向根 DNS 服务器发送请求。根服务器会返回一个指向负责该域名的顶级域名服务器（如 `.com` 或 `.org`）的地址。

#### 4.2 查询顶级域名服务器

本地 DNS 服务器接着向顶级域名服务器发送请求。顶级域名服务器会返回一个负责该域名的权威 DNS 服务器的地址。

#### 4.3 查询权威 DNS 服务器

最后，本地 DNS 服务器向权威 DNS 服务器发送请求。权威 DNS 服务器会返回相应的 IP 地址。

### 5. 返回 IP 地址

一旦本地 DNS 服务器获得 IP 地址，它会将其返回给用户的设备（浏览器）。

### 6. 进行连接

浏览器接收到 IP 地址后，会使用该 IP 地址与目标服务器建立连接，这通常是通过 TCP 或 UDP 协议进行。

### 7. 缓存结果

为了提高效率，浏览器和本地 DNS 服务器会将这个 IP 地址缓存一段时间（TTL，Time to Live）以便下次快速访问。

## 缓存命中率

什么是命中和未命中

> **定义：** 缓存命中是指请求的数据在缓存中找到了对应的条目。如果数据在缓存中存在，系统可以直接从缓存中读取数据，而不必去更慢的存储层（如主存、硬盘或远程服务器）。



怎么提高缓存命中率

> 1.1 **保持数据连续性**
>
> 1.2 **结构体对齐**
>
> 1.3 **矩阵按行优先遍历**
>
> 

代码局部性是什么

> 缓存是根据“**局部性原理**”来工作的，这包括**时间局部性**和**空间局部性**：
>
> - **时间局部性（Temporal Locality）**：如果某个数据最近被访问过，那么很有可能它在不久的将来会再次被访问。
> - **空间局部性（Spatial Locality）**：如果某个数据被访问过，那么它附近的数据很可能也会被访问。

## 函数怎么传递参数的

压栈入栈

存到寄存器里

## 虚拟地址和物理地址

怎么转换的

> ### 转换过程
>
> 1. **获取虚拟地址**：
>
>    - 虚拟地址通常由两部分组成：虚拟页号（VPN）和页内偏移（offset）。
>
>    - 例如，一个虚拟地址
>
>       
>
>      ```
>      0x00400000
>      ```
>
>       
>
>      可以分解为：
>    
>      - **虚拟页号 (VPN)**：根据系统的页大小计算。
>      - **页内偏移 (offset)**：虚拟地址在其页内的位置。
>
> 2. **查找页表**：
>
>    - 每个进程都有一个页表，页表存储了虚拟页号到物理页框号（PFN）的映射。
>    - MMU 使用虚拟页号去查找对应的物理页框号。
>
> 3. **页表查找**：
>
>    - 页表是一个数据结构，通常在内存中存放。页表的每一项包含：
>      - 虚拟页号对应的物理页框号。
>      - 其他控制信息，如权限位、存在位等。
>    - MMU 会查找该虚拟页号对应的条目，获取其对应的物理页框号。
>
> 4. **组装物理地址**：
>
>    - 获取到物理页框号后，将其与页内偏移结合，形成完整的物理地址。
>    - 物理地址的构成方式通常是：
>      - 物理地址 = 物理页框号 << 页大小位数 + 页内偏移

## 多级页表

为什么多级页表可以减少页表占用大小



页表结构

> ### 页表的基本结构
>
> 1. **虚拟页号（VPN）**：
>    - 页表的每一项通常包含一个虚拟页号，表示该条目对应的虚拟内存页。
> 2. **物理页框号（PFN）**：
>    - 每一项还包含一个物理页框号，表示该虚拟页对应的物理内存位置。
> 3. **控制位**：
>    - 除了基本的地址映射信息外，页表项通常还包含一些控制位，如：
>      - **存在位（Present Bit）**：指示该虚拟页是否在物理内存中。如果该位为 0，表示该页不在内存中，访问该页会导致缺页异常。
>      - **读/写位（Read/Write Bit）**：指示该页是否可写。
>      - **用户/内核位（User/Supervisor Bit）**：指示该页是用户空间还是内核空间。
>      - **访问位（Access Bit）**：指示该页是否被访问过，有助于实现页面置换算法。
>      - **脏位（Dirty Bit）**：指示该页是否被修改过，通常用于页面替换时决定是否将页面写回磁盘。
>      - **缓存位（Cacheable Bit）**：指示页面是否可以被缓存



## 内存分配碎片怎么产生的,为什么一次分更多内存

> ### 1. 内部碎片
>
> 内部碎片是指在分配的内存块中，由于分配的内存块大小大于实际需要的内存大小而造成的浪费
>
> ### 2. 外部碎片
>
> 外部碎片是指在内存中存在许多未分配的内存块，但这些块的大小不足以满足当前的分配请求



> 为什么一次分更多内存
>
> ### 1. 减少系统调用开销
>
> - **系统调用开销**：每次请求内存都需要执行系统调用，这会涉及上下文切换和内核态与用户态的切换。通过一次性分配更多内存，可以减少系统调用的次数，从而降低开销。
>
> ### 2. 减少内存碎片
>
> - **内部碎片**：如果程序频繁请求小块内存，可能会导致内部碎片（即分配的内存大于实际需要的内存）。通过一次性分配较大的内存块，可以减少这种内部碎片。
> - **外部碎片**：频繁的内存分配和释放可能会导致外部碎片的产生。一次性分配大块内存，能够在一定程度上避免小块内存的分散，从而降低外部碎片的概率。
>
> ### 3. 提高内存使用效率
>
> - **批量处理**：在某些情况下，程序会在一段时间内需要多次内存分配。一次分配更多内存可以使得后续的内存请求都在已分配的内存块内进行，避免不断请求新的内存。
>
> ### 4. 提高性能
>
> - **局部性原理**：现代处理器利用缓存来提高性能，当程序在内存中工作时，它们往往会使用相邻的内存区域。一次性分配更多内存并把相关数据放在一起，可以提高数据的局部性，从而提升缓存的使用效率。

## 什么是内存泄漏



## 变量声明和定义

声明是告诉编译器某个变量、函数或类型的名称和类型，但不为其分配内存或提供具体实现。

定义不仅指明一个标识符的名称和类型，还为其分配内存（对于变量）或提供具体的实现



## 引导程序存在哪里

Flash  ROM

## 嵌入式启动流程

> ### 1. 上电（Power On）
>
> - **供电**：设备通电，电源管理模块初始化供电。
> - **电源稳定**：电源电压稳定后，系统开始启动过程。
>
> ### 2. 复位（Reset）
>
> - **复位信号**：复位信号会将所有硬件和寄存器复位到初始状态，确保系统在已知状态下开始运行。
> - **初始化硬件**：复位后，硬件（如 CPU、外设等）被初始化。
>
> ### 3. 启动引导（Bootloader）
>
> - **引导加载程序**：系统启动后，处理器从预定义的引导地址（通常是 ROM 或 Flash 中的特定地址）开始执行启动引导程序。
> - **自检与硬件初始化**：引导程序会进行初始化检查，确保必要的硬件正常工作（例如，内存和外设）。
> - **加载操作系统或应用**：引导程序会从存储设备（如 Flash 或 SD 卡）加载操作系统、固件或应用程序到内存中。
>
> ### 4. 操作系统初始化
>
> - **内核启动**：如果嵌入式系统使用操作系统，启动引导程序完成后，控制权移交给操作系统内核。
> - **内存管理**：内核初始化内存管理子系统，准备系统资源。
> - **驱动加载**：内核加载并初始化各个外设驱动，确保硬件功能可用。
>
> ### 5. 用户空间初始化
>
> - **初始化系统服务**：内核启动后，用户空间的服务和应用程序会被初始化。
> - **启动应用程序**：最后，系统会启动用户应用程序或任务，开始实际的功能执行。
>
> ### 6. 运行时阶段
>
> - **事件处理**：系统进入主循环，处理输入、执行逻辑和管理外设。
> - **状态监控**：系统持续运行，监控状态、处理错误和进行必要的通信。
>
> ### 7. 关机流程（可选）
>
> - **安全关机**：一些嵌入式系统在关机前会进行安全关机流程，保存状态和关闭外设。
> - **断电**：完成关机流程后，切断电源。

## arm架构了解



## stack overflow

**无限递归**：

**过大的局部变量**：

## 哪些数据在rom flash

RAM 内存

ROM 机械硬盘 

**Flash** 固态硬盘

是一种非易失性存储器，能够在断电后保留数据，并且比传统的 ROM 具有更快的读写速度和更大的存储容量

## 控制权交换操作系统

听过把控制权交换给操作系统，为什么不能拿回来



### 控制权交给操作系统的意义

现代操作系统将硬件控制权集中管理，这种设计带来了以下好处：

1. **安全性**：用户程序无法直接访问硬件，必须通过操作系统提供的接口（如系统调用）。这可以防止恶意程序或错误程序直接操作硬件，避免安全问题和系统崩溃。
2. **多任务处理**：操作系统可以公平地调度多个进程或线程运行，使它们共享 CPU 时间和硬件资源。如果每个程序都可以直接控制硬件，系统可能会因为资源冲突而失效。



在大多数现代操作系统中，一旦硬件的控制权交给操作系统，用户程序通常**不能直接收回控制权**。原因包括以下几点：

1. **用户态和内核态的分离**：
   - 现代操作系统将程序的执行分为**用户态**和**内核态**