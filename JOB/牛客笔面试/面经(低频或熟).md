[【游戏开发面经汇总】- 计算机基础篇](https://zhuanlan.zhihu.com/p/417640759)

https://mp.weixin.qq.com/s/p_EP1JTSkx2xwuDF5CfN0w

https://mp.weixin.qq.com/s/B44lyGuz446Ly_m92uQ_ag



https://docs.qq.com/smartsheet/DTlJheU1xWVdrdFVO?tab=ss_187wbk&viewId=vQXOWN&_t=1723430020305



https://www.nowcoder.com/exam/interview/82614358/test?paperId=50270072&order=0

# c++

## 新特性

![image-20240706150753137](./img/image-20240706150753137.png)

## 前置++与后置++

```c
//前置
self &operator++() {
    node = (linktype)((node).next);
    return *this;
}
//后置
const self operator++(int) {
    self tmp = *this;
    ++*this;
    return tmp;
}
```

为了区分前后置，重载函数是以参数类型来区分，在调⽤的时候，编译器默默给int指定为⼀个0

> 1、==为什么后置返回对象，⽽不是引⽤==
> 因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，如果返回引⽤，那么我请问
> 你？你的对象对象都被销毁了，你引⽤啥呢？

> 2、==为什么后置前⾯也要加const==
> 其实也可以不加，但是为了防⽌你使⽤i++++,连续两次的调⽤后置++重载符，为什么呢?
> 原因：
> 它与内置类型⾏为不⼀致；你⽆法活得你所期望的结果，因为第⼀次返回的是旧值，⽽不是原对象，你调⽤两次后
> 置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const  

> ```
> int a =1;
> int * p = &a;
> p++；  指针++h会增加类型的size值
> ```

## 基本数据类型长度

> **无符号整数类型**：`size_t` 是一个无符号整数类型，也就是说它只能表示非负整数。
>
> **与平台相关**：`size_t` 的大小取决于平台的位数。在 32 位系统上，`size_t` 通常是 32 位宽；在 64 位系统上，`size_t` 通常是 64 位宽。

![img](https://img2.baidu.com/it/u=844834421,2336424125&fm=253&fmt=auto&app=138&f=PNG?w=661&h=500)



## 创建对象的过程

> 复习一下创建对象的三步：==分配内存、创建对象、返回指针==。但是这只是代码层面的步骤，**实际上，在编译成为指令之后，编译器有自己的想法（例如编译器优化），而指令就会发生reorder的情况**，将创建对象的三步变成为：分配内存、返回指针、创建对象。而返回指针之后，指针不为空，但实际上之后内存没有构造过程；对于线程B而言，得到了不为空的指针，却返回了错误的结果，所以即便是加锁，代码依然有问题风险。
>
> 
>
> 构造 父子   析构 子父





## 虚函数表



继承后会添加在第一个子类的虚表条目后面

![在这里插入图片描述](https://img.jbzj.com/file_images/article/202105/202105130917247.png)



基类和子类使用各自的虚函数表，互不干扰，即使子类中没有改写基类的虚函数，也没有新增虚函数，编译器也会为子类新建一个虚函数表，内容从基类中拷贝过来（只要继承），内容和基类完全一样。



### [虚函数指针的地址](https://blog.csdn.net/weixin_43519984/article/details/134294468)

```c
#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;
class A    //定义一个类A，类中有3个虚函数
{
public:
	int x;
	int y;
	virtual void f(){ cout << "f() called !" << endl; };
	virtual void f1(){ cout << "f1() called !" << endl; };
	virtual void f2(){ cout << "f2() called !" << endl; };
};


int main()
{
    A a;
	cout << hex ;
	cout << "类的首地址：" << &a << endl;
	//对于类的每个对象，编译器都会为其生成一个虚函数表指针，位于该对象内存中的开头，并指向了虚函数表的位置。
	//&a得到对象a的首地址，强制转换为(int *)，意为将从&a开始的4个字节看作一个整体，而&a就是这个4字节整体的首地址，也就是虚表指针。
	cout << "虚函数表指针: " << (int *)(&a) << endl;
	//虚函数表指针只想虚函数表，所以解引用就是虚函数表的地址
    cout << "虚函数表地址: " << *(int *)(&a) << endl;  
    
    
    /*
        下面获取虚函数地址（通过增加偏移量）
        两种做法：（首先获取虚函数表地址addr）
            1. 在虚函数表地址上 加字节偏移4*x(x从0开始)，然后转换成指针，然后获取：
                *(int *)(addr + 4*x);
                
            2. 虚函数表地址 转换成指针，然后通过增加指针的偏移量x(x从0开始) 获取：
                *((int *)addr + x);
    */
 
    int addr = *(int *)(&a);    //虚函数表地址
    
    //f()地址
    int f_addr_1 = *(int *)(addr + 0);  //第1种
 	int f_addr_2 = *((int *)addr + 0);  //第2种
 	cout<<"f()的地址："<<f_addr_1<<' '<<f_addr_2<<'\n';

 	//f1()地址
    int f1_addr_1 = *(int *)(addr + 4); //第1种
 	int f1_addr_2 = *((int *)addr + 1); //第2种 
    cout<<"f1()的地址："<<f1_addr_1<<' '<<f1_addr_2<<'\n';
 	
	//f2()地址
    int f2_addr_1 = *(int *)(addr + 8); //第1种
 	int f2_addr_2 = *((int *)addr + 2); //第2种
    cout<<"f2()的地址："<<f2_addr_1<<' '<<f2_addr_2<<'\n';

    return 0;    
}

```

### [多次单继承虚函数指针](https://blog.csdn.net/qq_36359022/article/details/81870219)

![这里写图片描述](https://img-blog.csdn.net/20180821103628852?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

单继承只有一个

在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类



### [多继承虚函数指针](https://blog.csdn.net/originalHSL/article/details/134151342)

```c
class Base1 {
public:
    virtual void func1() { cout << "Base1::func1" << endl; }
    virtual void func2() { cout << "Base1::func2" << endl; }
private:
    int b1;
};

class Base2 {
public:
    virtual void func1() { cout << "Base2::func1" << endl; }
    virtual void func2() { cout << "Base2::func2" << endl; }
private:
    int b2;
};

class Derive : public Base1, public Base2 {
public:
    virtual void func1() { cout << "Derive::func1" << endl; }
    virtual void func3() { cout << "Derive::func3" << endl; }
private:
    int d1;
};
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d01de086de68bea216663909d08eac24.png)

![image-20240903131616441](E:\codenotes\JOB\牛客笔面试\img\image-20240903131616441.png)





## 写时候拷贝

子进程

## [虚继承](https://blog.csdn.net/weixin_61857742/article/details/127344922)

![img](https://i-blog.csdnimg.cn/blog_migrate/aec3cd0b0ed4ee473933154b47151019.png)



在[虚继承](https://www.baidu.com/s?sa=re_dqa_generate&wd=虚继承&rsv_pq=b3f7d3cc000ce393&oq=虚继承的虚函数表&rsv_t=4ccbGPRGOi1GyDOmcLVL3eS47oxga1CGuNannU/VfZUF5Y/7ehDTpeUUbmE&tn=baidu&ie=utf-8)的情况下，虽然基类被视为虚拟基类，但==虚函数表的行为==并不因此而改变。

### 虚基表存在哪里

虚基表也是由编译器生成的，并且存储在只读数据段(.rodata)中。

# 操作系统

## 孤儿 僵尸进程

孤儿进程指的是 一个进程他的父进程已经被释放 但子进程没有结束或被释放 僵尸进程值得是一个进程结束并退出 但父进程没有收回其占有的资源 可以用wait 或者waitpid或者发送信号收回其现有的资源（杀死僵尸进程



## 进程状态

创建态，就绪态，运行态，阻塞态，终止态

创建态，就绪态，运行态，阻塞态，终止态。进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源，初始化PCB，当进程创建完成后，就进入“就绪态”，处于就绪态的进程已经具备运行的条件，由于没有空闲CPU，暂时无法运行，当CPU空闲时选择一个处于就绪态的进程上CPU运行，则处于“运行态”，在运行过程中如果需要请求等待某个事件的发生（如：请求某种系统资源或等待其他进程的响应），则下CPU进入“阻塞态”，当等待的事件发生了，再进入“就绪态”；处于运行态的进程，时间片已到或者处理机被抢占，则转入“就绪态”。进程运行结束或者发生不可修复的错误，进行就进入“终止态”，系统会回收该进程拥有的资源并撤销PCB



## 进程 线程 协程

1.进程是操作系统进行资源调度和分配的基本单位,线程是操作系统可执行的最小调度和分配单位

 2.一个线程属于一个进程,一个进程可以有多个线程 

3.一个进程崩溃不影响其他进程,但是一个线程崩溃会让进程崩溃 

4.进程在执行过程中有独立的存储单元,而线程之间共享进程的内存 

5.进程之间切换系统开销大,而线程之间切换开销比进程小



协程可以靠编译语言实现，因此称为用户态线程，量级更轻 线程并行，协程并发 线程同步，协程异步 线程抢占式，协程非抢占式，需要手动切换 线程上千，协程上万

# 项目

## 网络服务器





# 手撕代码

### [atoi (ascii to int )](https://blog.csdn.net/qq_57425280/article/details/133438479)            

```c
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
int my_atoi(const char* str)
{
	assert(str);
	//用isspace函数向后过滤空白字符
	//isspace返回值不为0，代表是空格
	while (isspace(*str))
	{
		str++;
	}//走到这里str一定不是空格了
	if (*str == '\0')//空字符串问题
	{
		return 0;
	}
	//+-号问题
	int flg = 1;
	if (*str == '+')
	{
		flg = 1;
		str++;
	}//注意这里要用else if，不能用else
	else if(*str == '-')
	{
		flg = -1;
		str++;
	}
	long long n = 0;
	while (*str != "\0")
	{
		if (isdigit(*str))
		{//是数字字符==>返回值不为0
			n = n * 10 + (*str - '\0') * flg;
		}
		else//不是数字字符
		{
			return (int)n;
		}
		str++;
	}
	return (int)n;
}
int main()
{
	int ret = my_atoi("123");
	printf("&d\n", ret);
	return 0;
}
```



