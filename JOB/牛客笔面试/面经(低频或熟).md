[【游戏开发面经汇总】- 计算机基础篇](https://zhuanlan.zhihu.com/p/417640759)

https://mp.weixin.qq.com/s/p_EP1JTSkx2xwuDF5CfN0w

https://mp.weixin.qq.com/s/B44lyGuz446Ly_m92uQ_ag

https://docs.qq.com/smartsheet/DTlJheU1xWVdrdFVO?tab=ss_187wbk&viewId=vQXOWN&_t=1723430020305

# c++

### 新特性

![image-20240706150753137](./img/image-20240706150753137.png)

### 前置++与后置++

```c
//前置
self &operator++() {
    node = (linktype)((node).next);
    return *this;
}
//后置
const self operator++(int) {
    self tmp = *this;
    ++*this;
    return tmp;
}
```

为了区分前后置，重载函数是以参数类型来区分，在调⽤的时候，编译器默默给int指定为⼀个0

> 1、==为什么后置返回对象，⽽不是引⽤==
> 因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，如果返回引⽤，那么我请问
> 你？你的对象对象都被销毁了，你引⽤啥呢？

> 2、==为什么后置前⾯也要加const==
> 其实也可以不加，但是为了防⽌你使⽤i++++,连续两次的调⽤后置++重载符，为什么呢?
> 原因：
> 它与内置类型⾏为不⼀致；你⽆法活得你所期望的结果，因为第⼀次返回的是旧值，⽽不是原对象，你调⽤两次后
> 置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const  



### 基本数据类型长度

> **无符号整数类型**：`size_t` 是一个无符号整数类型，也就是说它只能表示非负整数。
>
> **与平台相关**：`size_t` 的大小取决于平台的位数。在 32 位系统上，`size_t` 通常是 32 位宽；在 64 位系统上，`size_t` 通常是 64 位宽。

![img](https://img2.baidu.com/it/u=844834421,2336424125&fm=253&fmt=auto&app=138&f=PNG?w=661&h=500)



# 操作系统

## 中断

### 中断和轮询

中断是一种被动等待的机制，当设备需要处理时，它主动发出信号（中断请求）通知CPU处理

轮询是一种主动等待的机制，CPU定期检查某个设备或条件是否需要处理。这通常通过在主循环中反复检查设备状态寄存器来实现



### 硬中断和软中断

**硬中断** ：硬中断是由外部硬件设备触发的中断信号，通知CPU有外部事件需要处理。这种中断通常由物理设备

**软中断：**软中断是由软件触发的中断，通常用于内核内部调度任务、处理延迟的工作或模拟硬中断。它通常通过CPU指令或操作系统内核触发，并不是由硬件设备直接引发。

**内部中断**：*内部中断又分为软中断和异常*，是指由CPU内部事件或异常引发的中断，不属于软中断或硬中断的分类。它们是从不同角度对中断进行的分类，没有直接的从属关系。

## 进程

### CPU调度算法

> **先来先服务（FCFS）调度算法**
>
> **短作业优先（SJF）调度算法** 
>
> **优先级调度算法**
>
> **时间片轮转调度算法** 
>
> **多级反馈队列调度算法** 
>
> 是一种根据先来先服务原则给就绪队列排序，为就绪队列赋予不同的优先级数，不同的时间片，按照优先级抢占CPU的调度算法。算法的实施过程如下：
>
> 按照先来先服务原则排序，设置N个就绪队列为Q1，Q2…QN，每个队列中都可以放很多作业；
>
> 为这N个就绪队列赋予不同的优先级，第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低；
>
> 设置每个就绪队列的时间片，优先权越高，算法赋予队列的时间片越小。时间片大小的设定按照实际作业（进程）的需要调整；
>
> 进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。
>
> 首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程

### 进程的通信方式

```
 进程间通信主要包括：
 管道：本质上是内核中维护的一块内存缓冲区
 
信号：一种异步通信方式，信号可以让一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
 
消息队列：是一个消息链表且随内核持续，具有特定的格式和特定的优先级，由具有写权限的进程添加消息，由具有读权限的进程读走消息
 
共享内存：共享内存：允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）

内存映射：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件

信号量：主要用来解决进程和线程间并发执行时的同步问题

套接字：一般用于网络中不同主机上的进程之间的通信
```

### 线程通信方式

信号，互斥锁，读写锁，自旋锁，条件变量，信号量
线程间无需特别的手段进行通信

#### 锁

> **互斥锁**在获取不到锁的时候将线程挂起，本质是一个获取锁的系统调用，从用户区切换到内核区，系统调用失败线程休眠。
>
> 
>
> **自旋锁**获取不到锁的时候进入忙等待，不会主动切换线程，程序始终运行在用户区
>
> 
>
> **死锁**：由于两个或两个以上的进程由于竞争资源而导致进程都无法执行的情况； 
>
> 产生的条件：互斥、不可抢占、请求与保持、循环等待 
>
> 如何避免：破坏不可抢占条件（可以让优先级高的进程抢占优先级低的进程的资源）、破坏请求与保持条件（当进程申请不到自己所需要的的资源时，必须释放掉自己所持有的资源）、破坏循环等待条件（进程只能往前申请资源，不能往后申请资源）
>
>  如何预防：有序资源分配法、银行家算法
>
> 

### 孤儿进程和僵尸进程

```
孤儿进程指的是 一个进程他的父进程已经被释放 但子进程没有结束或被释放 
僵尸进程值得是一个进程结束并退出 但父进程没有收回其占有的资源 可以用wait 或者waitpid或者发送信号收回其现有的资源
```

### 进程状态

创建态，就绪态，运行态，阻塞态，终止态

> *1 就绪队列。2 等待队列。3 运行队列*

## 大小端

 大端字节序：是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处 

小端字节序（Linux）：是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处 

==记住小段是 一样的，高存在高，低存在低==

## 编译过程

预处理：预处理阶段处理所有的预处理指令

编译 ：编译阶段将预处理后的代码（`.i` 文件）转换为汇编代码（`.s` 文件）。这一阶段主要进行语法分析、语义分析、优化等

汇编：汇编阶段将汇编代码（`.s` 文件）转换为机器代码

链接：链接阶段将所有目标文件（`.o` 文件）和库文件链接在一起，生成最终的可执行文件

## 动态库和静态库

区别 -

> **静态库**
>
>  gcc 进行链接时，会把静态库中代码打包到可执行程序中，编译时加载；
>
> ```
> gcc -c xxx -o  xxx.o  //这里的 -c 选项告诉 GCC 只进行编译而不链接，-o 选项指定输出文件名。
> ar rcs xxx.a xxx.o   //静态库是 .a 文件，使用 ar 工具将目标文件打包成一个静态库
> ```
>
> 优点：
>
> 发布程序时无需提供静态库，移植方便；
>
> 静态库被打包到应用程序中加载速度快
>
> 缺点：
>
> 消耗内存，更新部署发布麻烦。 - 
>
> 
>
> **动态库**
>
> ```
> gcc -c xxx -o  xxx.o  //这里的 -c 选项告诉 GCC 只进行编译而不链接，-o 选项指定输出文件名。
> gcc -fPIC -shared xxx -o xxx.so //动态库是 .so 文件，可以直接用 gcc 编译生成
> gcc -o myprogram main.c -L. -lmylib
> ```
>
>  gcc 进行链接时，动态库的代码不会被打包到可执行程序中，运行时加载；
>
> 优点：
>
> 内存占用小，更新部署发布简单。
>
> 缺点：
>
> 发布程序时需要提供动态库；



## gbd使用

> b某行打断点 r运行程序，断点停 c继续执行 p打印指定值 n单步运行 q终止调试



## 分段和分页

> 分段式：段与段之间内存隔离，这里理解为像是编程语言中的 定义域 “{  }”，定义域与定义域之间内存隔离。有利于内存的共享和保护。 
>
> 分页式：将页表中的每一页与实际的物理内存地址映射起来，有利于增加资源率。
>
>  段页式：结合两种方式的优点，主要根据段表，找到具体的页表，从而生成物理地址。这种方式既解决了内存隔离，也提高了资源利用率
>
> 



**分页机制**：解决了内存碎片化、高效内存管理、内存保护和地址转换的问题。分页通过将虚拟内存分割成固定大小的页并映射到物理内存中的页框，优化了内存的利用率和管理效率，同时确保了系统的稳定性和安全性。



## 虚拟内存

**虚拟内存**：解决了物理内存不足、进程地址空间独立和程序大小限制的问题。

虚拟内存可以使得进程对运行内存超过物理内存大小，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域

虚拟内存为每个进程提供独立的虚拟地址空间。





# select和epoll



# 手撕代码

### atoi (ascii to int )

```c
#include <stdio.h>
#include <stdlib.h>﻿
#include <assert.h>

int isempty(char* str)
{
    if (str == ' ' ||
        str == '\t' ||
        str == '\n' ||
        str == '\f' ||
        str == '\v' ||
        str == '\r')
    {
        return 1;
    }
    return 0;
}

int isnumber(char* str)
{
    if (str >= '0' && str <= '9')
    {
        return 1;
    }
    return 0;
}

int  my_atoi(char* str)
{
    assert(str != NULL);
    char sign;
    int flag = 0;
    while (isempty(*str)==1)//判断是否为空
    {
        str++;
    }
    sign = *str;
    if (sign == '-' || sign == '+')
    {
        str++;
    }
    while (isnumber(*str) == 1)//判断是否为数字
    {
        flag = 10 * flag + (*str - '0');//在循环过程中，每次处理一个数字字符时，我们需要将其转换成对应的整数值，并将其累加到已经转换好的部分上。
                                        //乘以10的目的是为了将已经转换好的部分向左移动一位，为新的数字字符腾出位置。
        str++;
    }
    return sign == '-' ? -flag : flag;
}


int main()
{
    const char* str1 = "123";
    const char* str2 = "-123abc12";
    const char* str3 = "abc";
    int value1 = my_atoi(str1);
    int value2 = my_atoi(str2);
    int value3 = my_atoi(str3); 
    printf("Value of str1: %d\n", value1);//123
    printf("Value of str2: %d\n", value2);//-123
    printf("Value of str3: %d\n", value3); //0
    return 0;
}
                        
原文链接：https://blog.csdn.net/qq_57425280/article/details/133438479
```

```c
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
int my_atoi(const char* str)
{
	assert(str);
	//用isspace函数向后过滤空白字符
	//isspace返回值不为0，代表是空格
	while (isspace(*str))
	{
		str++;
	}//走到这里str一定不是空格了
	if (*str == '\0')//空字符串问题
	{
		return 0;
	}
	//+-号问题
	int flg = 1;
	if (*str == '+')
	{
		flg = 1;
		str++;
	}//注意这里要用else if，不能用else
	else if(*str == '-')
	{
		flg = -1;
		str++;
	}
	long long n = 0;
	while (*str != "\0")
	{
		if (isdigit(*str))
		{//是数字字符==>返回值不为0
			n = n * 10 + (*str - '\0') * flg;
		}
		else//不是数字字符
		{
			return (int)n;
		}
		str++;
	}
	return (int)n;
}
int main()
{
	int ret = my_atoi("123");
	printf("&d\n", ret);
	return 0;
}
```



### iota下标绑定排序

```c
iota(id.begin(), id.end(), 0);
sort(id.begin(), id.end(), [&](int i, int j)  {return indices[i] > indices[j];});
```

