[【游戏开发面经汇总】- 计算机基础篇](https://zhuanlan.zhihu.com/p/417640759)

https://mp.weixin.qq.com/s/p_EP1JTSkx2xwuDF5CfN0w

https://mp.weixin.qq.com/s/B44lyGuz446Ly_m92uQ_ag



https://docs.qq.com/smartsheet/DTlJheU1xWVdrdFVO?tab=ss_187wbk&viewId=vQXOWN&_t=1723430020305



https://www.nowcoder.com/exam/interview/82614358/test?paperId=50270072&order=0

# ==c++==

## 新特性

![image-20240706150753137](./img/image-20240706150753137.png)

## 前置++与后置++

```c
//前置
self &operator++() {
    node = (linktype)((node).next);
    return *this;
}
//后置
const self operator++(int) {
    self tmp = *this;
    ++*this;
    return tmp;
}
```

为了区分前后置，重载函数是以参数类型来区分，在调⽤的时候，编译器默默给int指定为⼀个0

> 1、==为什么后置返回对象，⽽不是引⽤==
> 因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，如果返回引⽤，那么我请问
> 你？你的对象对象都被销毁了，你引⽤啥呢？

> 2、==为什么后置前⾯也要加const==
> 其实也可以不加，但是为了防⽌你使⽤i++++,连续两次的调⽤后置++重载符，为什么呢?
> 原因：
> 它与内置类型⾏为不⼀致；你⽆法活得你所期望的结果，因为第⼀次返回的是旧值，⽽不是原对象，你调⽤两次后
> 置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const  

> ```
> int a =1;
> int * p = &a;
> p++；  指针++h会增加类型的size值
> ```

## 基本数据类型长度

> **无符号整数类型**：`size_t` 是一个无符号整数类型，也就是说它只能表示非负整数。
>
> **与平台相关**：`size_t` 的大小取决于平台的位数。在 32 位系统上，`size_t` 通常是 32 位宽；在 64 位系统上，`size_t` 通常是 64 位宽。

![img](https://img2.baidu.com/it/u=844834421,2336424125&fm=253&fmt=auto&app=138&f=PNG?w=661&h=500)



## 创建对象的过程

> 复习一下创建对象的三步：==分配内存、创建对象、返回指针==。但是这只是代码层面的步骤，**实际上，在编译成为指令之后，编译器有自己的想法（例如编译器优化），而指令就会发生reorder的情况**，将创建对象的三步变成为：分配内存、返回指针、创建对象。而返回指针之后，指针不为空，但实际上之后内存没有构造过程；对于线程B而言，得到了不为空的指针，却返回了错误的结果，所以即便是加锁，代码依然有问题风险。
>
> 
>
> 构造 父子   析构 子父





## 虚函数表



继承后会添加在第一个子类的虚表条目后面

![在这里插入图片描述](https://img.jbzj.com/file_images/article/202105/202105130917247.png)



基类和子类使用各自的虚函数表，互不干扰，即使子类中没有改写基类的虚函数，也没有新增虚函数，编译器也会为子类新建一个虚函数表，内容从基类中拷贝过来（只要继承），内容和基类完全一样。



### [虚函数指针的地址](https://blog.csdn.net/weixin_43519984/article/details/134294468)

```c
#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;
class A    //定义一个类A，类中有3个虚函数
{
public:
	int x;
	int y;
	virtual void f(){ cout << "f() called !" << endl; };
	virtual void f1(){ cout << "f1() called !" << endl; };
	virtual void f2(){ cout << "f2() called !" << endl; };
};


int main()
{
    A a;
	cout << hex ;
	cout << "类的首地址：" << &a << endl;
	//对于类的每个对象，编译器都会为其生成一个虚函数表指针，位于该对象内存中的开头，并指向了虚函数表的位置。
	//&a得到对象a的首地址，强制转换为(int *)，意为将从&a开始的4个字节看作一个整体，而&a就是这个4字节整体的首地址，也就是虚表指针。
	cout << "虚函数表指针: " << (int *)(&a) << endl;
	//虚函数表指针只想虚函数表，所以解引用就是虚函数表的地址
    cout << "虚函数表地址: " << *(int *)(&a) << endl;  
    
    
    /*
        下面获取虚函数地址（通过增加偏移量）
        两种做法：（首先获取虚函数表地址addr）
            1. 在虚函数表地址上 加字节偏移4*x(x从0开始)，然后转换成指针，然后获取：
                *(int *)(addr + 4*x);
                
            2. 虚函数表地址 转换成指针，然后通过增加指针的偏移量x(x从0开始) 获取：
                *((int *)addr + x);
    */
 
    int addr = *(int *)(&a);    //虚函数表地址
    
    //f()地址
    int f_addr_1 = *(int *)(addr + 0);  //第1种
 	int f_addr_2 = *((int *)addr + 0);  //第2种
 	cout<<"f()的地址："<<f_addr_1<<' '<<f_addr_2<<'\n';

 	//f1()地址
    int f1_addr_1 = *(int *)(addr + 4); //第1种
 	int f1_addr_2 = *((int *)addr + 1); //第2种 
    cout<<"f1()的地址："<<f1_addr_1<<' '<<f1_addr_2<<'\n';
 	
	//f2()地址
    int f2_addr_1 = *(int *)(addr + 8); //第1种
 	int f2_addr_2 = *((int *)addr + 2); //第2种
    cout<<"f2()的地址："<<f2_addr_1<<' '<<f2_addr_2<<'\n';

    return 0;    
}

```

### [多次单继承虚函数指针](https://blog.csdn.net/qq_36359022/article/details/81870219)

![这里写图片描述](https://img-blog.csdn.net/20180821103628852?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

单继承只有一个

在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类



### [多继承虚函数指针](https://blog.csdn.net/originalHSL/article/details/134151342)

```c
class Base1 {
public:
    virtual void func1() { cout << "Base1::func1" << endl; }
    virtual void func2() { cout << "Base1::func2" << endl; }
private:
    int b1;
};

class Base2 {
public:
    virtual void func1() { cout << "Base2::func1" << endl; }
    virtual void func2() { cout << "Base2::func2" << endl; }
private:
    int b2;
};

class Derive : public Base1, public Base2 {
public:
    virtual void func1() { cout << "Derive::func1" << endl; }
    virtual void func3() { cout << "Derive::func3" << endl; }
private:
    int d1;
};
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d01de086de68bea216663909d08eac24.png)

![image-20240903131616441](E:\codenotes\JOB\牛客笔面试\img\image-20240903131616441.png)



### 多继承偏移计算

> ```
> [C]
>   - [A part]
>     - vptr_A   // 指向 A 的虚函数表
>     - A 的成员
>   - [B part]
>     - vptr_B   // 指向 B 的虚函数表
>     - B 的成员
>   - vptr_C     // 指向 C 的虚函数表
>   - C 的成员
> ```
>
> ```c
> #include <iostream>
> 
> class A {
> public:
>     virtual void foo() { std::cout << "A::foo\n"; }
>     virtual ~A() {}
> };
> 
> class B {
> public:
>     virtual void bar() { std::cout << "B::bar\n"; }
>     virtual ~B() {}
> };
> 
> class C : public A, public B {
> public:
>     virtual void foo() override { std::cout << "C::foo\n"; }
>     virtual void bar() override { std::cout << "C::bar\n"; }
>     virtual ~C() {}
> };
> 
> int main() {
>     C obj;
>     A* a_ptr = &obj;
>     B* b_ptr = &obj;
>     
>     // A's vptr is at the start of obj
>     std::cout << "Address of A's vptr: " << (void*)*(long*)(&obj) << std::endl;
> 
>     // B's vptr is at an offset in obj (after A's part)
>     std::cout << "Address of B's vptr: " << (void*)*(long*)((char*)&obj + sizeof(A)) << std::endl;
> 
>     return 0;
> }
> 
> ```

## 写时候拷贝

子进程

## [虚继承](https://blog.csdn.net/weixin_61857742/article/details/127344922)

![img](https://i-blog.csdnimg.cn/blog_migrate/aec3cd0b0ed4ee473933154b47151019.png)



在[虚继承](https://www.baidu.com/s?sa=re_dqa_generate&wd=虚继承&rsv_pq=b3f7d3cc000ce393&oq=虚继承的虚函数表&rsv_t=4ccbGPRGOi1GyDOmcLVL3eS47oxga1CGuNannU/VfZUF5Y/7ehDTpeUUbmE&tn=baidu&ie=utf-8)的情况下，虽然基类被视为虚拟基类，但==虚函数表的行为==并不因此而改变

### 虚基表存在哪里

虚基表也是由编译器生成的，并且存储在只读数据段(.rodata)中



1. **vbptr**：
   - 只有在虚继承的情况下才会存在。
   - `vbptr` 可能在对象内存中的位置取决于编译器的实现，通常它会在对象的其他数据成员之后，而不是在开头。





## c++stirng怎么转 c

```
// 使用 c_str()
    const char* cString = cppString.c_str();

// 使用 data()
    const char* cString = cppString.data();
    
    //手动复制到字符数组
    char cString[50]; 
    std::strcpy(cString, cppString.c_str());
```



# ==操作系统==

## 孤儿 僵尸进程

孤儿进程指的是 一个进程他的父进程已经被释放 但子进程没有结束或被释放 僵尸进程值得是一个进程结束并退出 但父进程没有收回其占有的资源 可以用wait 或者waitpid或者发送信号收回其现有的资源（杀死僵尸进程



## 进程状态

创建态，就绪态，运行态，阻塞态，终止态

创建态，就绪态，运行态，阻塞态，终止态。进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源，初始化PCB，当进程创建完成后，就进入“就绪态”，处于就绪态的进程已经具备运行的条件，由于没有空闲CPU，暂时无法运行，当CPU空闲时选择一个处于就绪态的进程上CPU运行，则处于“运行态”，在运行过程中如果需要请求等待某个事件的发生（如：请求某种系统资源或等待其他进程的响应），则下CPU进入“阻塞态”，当等待的事件发生了，再进入“就绪态”；处于运行态的进程，时间片已到或者处理机被抢占，则转入“就绪态”。进程运行结束或者发生不可修复的错误，进行就进入“终止态”，系统会回收该进程拥有的资源并撤销PCB



## 进程 线程 协程

1.进程是操作系统进行资源调度和分配的基本单位,线程是操作系统可执行的最小调度和分配单位

 2.一个线程属于一个进程,一个进程可以有多个线程 

3.一个进程崩溃不影响其他进程,但是一个线程崩溃会让进程崩溃 

4.进程在执行过程中有独立的存储单元,而线程之间共享进程的内存 

5.进程之间切换系统开销大,而线程之间切换开销比进程小



协程可以靠编译语言实现，因此称为用户态线程，量级更轻 线程并行，协程并发 线程同步，协程异步 线程抢占式，协程非抢占式，需要手动切换 线程上千，协程上万

## 软硬链接

 在Linux系统中，多个文件名指向同一索引节点(Inode)是正常且允许的。一般这种链接就称为[**硬链接**](https://www.cnblogs.com/songgj/p/9115954.html)。硬链接的作用之一是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要的文件，以防止“误删”源数据，删除一个硬链接文件并不影响其他有相同 inode 号的文件  



软链接（也叫符号链接），类似于windows系统中的快捷方式，与硬链接不同，软链接就是一个普通文件，只是数据块内容有点特殊，文件用户数据块中存放的内容是另一文件的路径名的指向，通过这个方式可以快速定位到软连接所指向的源文件实体。软链接可对文件或目录创建。

## 静态库和动态库

动态库 .so -shared -fpic    装载慢，体积小，运行时加载

静态库  .a     装载快，体积大，不好维护

## [C++如何排查并发编程死锁问题？](https://mp.weixin.qq.com/s/Rr4TEdku6qTWDyT1CRLhiQ)



## CPU 内存 交换空间 缓存命中 为什么  排查 优化

> ## 内存
>
> - ### 一、造成内存占用过高的情况
>
>   1. **内存泄漏**：
>   2. **对象过多**：
>   3. **数据结构选择不当**：
>      - 使用了占用内存较大的数据结构（如 `std::vector` 或 `std::map`）而非更合适的结构。
>   4. **重复数据**：
>   5. **全局变量和静态变量**：
>      - 全局和静态变量在整个程序生命周期内存在，占用的内存无法被释放。
>   6. **未释放的资源**：
>   7. **过大的缓存**：
>
>   ### 二、排查方法
>
>   1. **使用内存分析工具**：
>      - **Valgrind**：用于检测内存泄漏、访问越界等问题。
>      - 一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等  
>   2. **日志和监控**：
>      - 在程序中添加内存使用日志，定期输出当前内存占用情况，观察内存变化趋势。
>   3. **代码审查**：
>
>   ### 三、优化策略
>
>   1. **减少内存分配和释放**：
>      - 使用对象池来管理频繁创建和销毁的对象，降低分配和释放的频率。
>      - 良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉
>   2. **选择合适的数据结构**：
>      - 根据实际需求选择内存占用更小的数据结构。例如，如果只需存储小数量的元素，可以考虑使用 `std::array`。
>   3. **使用智能指针**：
>      - 在 C++ 中使用 `std::unique_ptr` 和 `std::shared_ptr` 代替原始指针，自动管理内存释放，降低内存泄漏风险。
>   4. **避免全局和静态变量**：
>      - 尽量减少使用全局变量和静态变量，优先使用局部变量，必要时考虑传递参数。
>   5. **定期清理无用数据**：
>   6. **分析算法的复杂性**：
>   7. **按需加载**：
>   8. **控制并发使用**：
>      - 在多线程程序中，避免过多的共享数据，减少同步开销。
>
>   

> ## CPU
>
> ### 一 排查
>
> - 使用 `htop` 或 `top` 查看哪个进程占用了最多CPU
>
> - 使用 `pidstat` 分析单个进程的CPU使用情况
>
> ```
> ps aux --sort=-%cpu | head -n 10
> ```
>
> 
>
> - 通过 `strace` 检查该进程的系统调用情况，分析是否存在无效的频繁系统调用。
>
> - 火焰图（是一种可视化工具，主要用于分析程序的性能，特别是CPU的使用情况。它通过图形化方式展示函数调用的栈帧，帮助开发者识别性能瓶颈。每个“火焰”代表一个函数，火焰的宽度表示该函数在CPU使用中的占比，堆叠的结构显示了调用关系。
>
> ### 主要用途：
>
> 1. **识别热点**：
>    - 找出CPU使用率高的函数，帮助定位性能瓶颈
>
> ### 二 优化
>
> **优化代码中的计算逻辑或数据结构，减少重复计算或不必要的资源占用**。
>
> **优化线程模型，使用线程池或异步IO机制来减轻CPU压力**
>
> 
>



- ### 要定位到哪一段代码怎么办？

> **valgrind**：特别适合内存泄漏和异常检测，可以分析程序的函数调用情况，帮助识别性能瓶颈。
>
> **火焰图**
>
> 日志
>
> gdb调试 core dump 文件可以帮助你排查程序崩溃或异常的问题

### 

## 一个进程运行时候被杀死，你觉得有哪些情况？

> 进程在运行时被杀死的情况有多种可能，以下是一些常见的原因：
>
> 1. **内存溢出**：
>    - 进程消耗了超过系统或用户限制的内存，导致操作系统强制终止该进程。
> 2. **超出资源限制**：
>    - 进程可能超出了设定的资源限制（如CPU时间、文件句柄数等），操作系统会根据配置杀死该进程。
> 3. **手动终止**：
>    - 用户或管理员通过命令（如 `kill`、`pkill` 或 `killall`）手动终止了该进程。
> 4. **父进程终止**：
>    - 如果进程是一个子进程，父进程终止时，子进程可能也会被终止，尤其是在未设置“孤儿”处理的情况下。
> 5. **系统负载过高**：
>    - 当系统负载过高，操作系统可能会通过 OOM Killer（Out Of Memory Killer）终止一些进程，以释放资源。
> 6. **信号处理**：
>    - 进程可能接收到某个信号（如 SIGTERM、SIGKILL），导致其被终止。某些程序可能在特定情况下自动捕获和响应信号。
> 7. **崩溃或异常**：
>    - 程序代码中存在未处理的异常或崩溃，导致进程意外终止。
> 8. **系统重启或关闭**：
>    - 系统重启或关闭时，所有进程会被强制终止。
> 9. **安全机制**：
>    - 安全工具或机制（如 SELinux、AppArmor 等）可能因某些违规操作而杀死进程。
> 10. **资源饥饿**：
>     - 如果进程长时间无法获得所需的资源（如CPU或I/O），可能会被系统视为不健康进程，从而被终止。
>
> ### 排查步骤
>
> - **查看日志**：检查系统日志（如 `/var/log/syslog` 或 `dmesg`）以获取进程被杀死的原因。
> - **监控资源使用**：使用工具（如 `top`、`htop`、`vmstat`）监控资源使用情况，识别内存或CPU负载问题。
> - **分析核心转储**：如果程序崩溃生成核心转储（core dump），可以使用调试工具（如 `gdb`）分析崩溃原因

# ==网络==

## [常见八股](https://developer.aliyun.com/article/1532246)



## [字节流与数据报](https://blog.csdn.net/qq_37037348/article/details/138288754)

> ### **应用层协议来解决消息边界问题**
>
> 为了让接收端能够正确解析从 TCP 接收到的字节流，应用层协议通常会使用一些方法来明确标识消息的边界或长度。常见的应用层协议的设计方案包括
>
> 
>
> 或 数据包末尾加上\r\n标记

## TCP和UDP区别



> ### 1、数据可靠性
>
> TCP提供可靠的数据传输服务，数据以不丢失，无差错、不重复，通过校验和、重传控制等方式，来保证传输数据的可靠性，例如网页浏览、文件下载等，使用的是此类协议；
>
> UDP的传输不保证可靠性，即有丢包的可能，也不保证交付可靠的数据。例如聊天软件使用的就是UDP的协议；
>
> ### 2、连接方式
>
> TCD是面向连接的传输层协议，在传输数据的时候，需要首先建立连接，例如输入一个网址，可以接收到服务器返回的数据；
>
> UDP是不需要建立连接，例如你给一位好友发送消息，使用的就是UDP协议；
>
> ### 3、传输效率
>
> TCP传输效率比UDP的传输效率要低（慢）。UDP是一种简单、快捷、高效的传输协议，而TCP保证可靠性，允许对丢失的数据重传；
>
> ### 4、连接数量
>
> UDP支持一对一，一对多和多对一的交互式通信方式；
>
> 而TCP只支持点对点，对一对一的通信方式。
>
> ### 5、报文大小
>
> UDP的报文只有8个字节大小，而TCP的报文首部有20个字节。
>
> ### 6、流量控制
>
> TCP拥有流量控制和拥塞控制机制，UDP面向报文，没有阻塞控制。



## 网络劫持

> 网络劫持是指攻击者通过各种方法控制用户的网络流量，可能导致数据泄露、隐私侵害或恶意软件传播。常见的网络劫持类型及其预防措施如下：
>
> ### 常见类型：
>
> 1. **DNS 劫持**：
>    - 攻击者篡改 DNS 请求，将用户重定向到恶意网站。
> 2. **HTTP 劫持**：
>    - 在用户和网站之间篡改 HTTP 请求或响应，插入广告或恶意内容。
> 3. **Wi-Fi 劫持**：
>    - 通过伪装成公共 Wi-Fi 热点，捕获用户数据。
> 4. **路由器劫持**：
>    - 攻击者访问用户路由器设置，修改 DNS 和其他网络配置。
> 5. **中间人攻击（MITM）**：
>    - 攻击者在通信双方之间插入自己，获取敏感信息。
>
> ### 预防措施：
>
> 1. **使用 HTTPS**：
>    - 确保访问的网站使用 HTTPS 加密，保护数据传输安全。
> 2. **DNS 安全扩展（DNSSEC）**：
>    - 使用 DNSSEC 增强 DNS 查询的安全性，防止 DNS 劫持。
> 3. **定期更新路由器固件**：
>    - 确保路由器使用最新的固件，修复潜在的安全漏洞。
> 4. **使用 VPN**：
>    - 在公共 Wi-Fi 网络中使用 VPN 隧道加密数据传输，保护隐私。
> 5. **强密码和双因素认证**：
>    - 为路由器和在线账户设置强密码，并启用双因素认证（2FA）。
> 6. **避免访问未知网络**：
>    - 尽量避免连接未知或不安全的 Wi-Fi 热点。
> 7. **监控网络流量**：
>    - 使用网络监控工具检测异常流量，及时发现潜在攻击。

## 网络的 MTU（最大传输单元）限制

> **TCP** 的数据包大小同样受到 **MTU**（最大传输单元）的限制，但 TCP 和 UDP 处理 MTU 的方式有所不同。
>
> ### 1. **TCP 与 MTU 的关系**
>
> #### **MTU 的作用**：
>
> - MTU 是在网络层（IP 层）定义的，决定了可以在链路上传输的最大 IP 数据包的大小。
> - 对于典型的以太网，MTU 通常是 **1500 字节**。这意味着 IP 层的数据包（包括 IP 和 TCP 头部）不能超过 1500 字节。
>
> #### **MSS（Maximum Segment Size）**：
>
> - **TCP** 使用 **MSS（最大段大小）** 来决定每次传输的最大数据量。MSS 是 TCP 段中**仅包含数据部分**的最大大小，不包括 TCP 和 IP 头部。
> - **MSS** 的值通常是根据 **MTU** 减去 TCP 和 IP 头部的大小来确定的。通常，IP 头部是 **20 字节**，TCP 头部也是 **20 字节**，因此典型的 MSS 是 **1460 字节**（1500 - 40 = 1460）。
>
> ### 2. **TCP 数据包划分和传输**
>
> - 在 TCP 连接建立时（通过 **三次握手**），通信双方会协商 **MSS**。MSS 值决定了单个 TCP 段的最大数据大小。
> - 当 TCP 传输数据时，它会根据协商的 MSS 来划分段。如果 TCP 段大小超过网络路径中的 **MTU**，IP 层会进行 **IP 分片（IP fragmentation）**。
> - **IP 分片**：如果 TCP 段超过了 MTU 的大小，IP 层会将其分片为更小的包，以便适应链路的 MTU。分片后的 IP 包在接收端会重新组合成原始数据包。然而，IP 分片会降低网络传输效率，并且分片丢失时整个包都需要重传。
>
> ### 3. **TCP 如何避免分片**
>
> 为了避免 IP 分片带来的低效问题，TCP 使用 **MSS** 来限制单个 TCP 段的大小，从而确保每个段都不会超过 MTU 限制，避免 IP 层的分片：
>
> - **MSS 和 MTU 的关系**：MSS 的值通常设置为 MTU 减去 IP 和 TCP 头部的大小，确保 TCP 段不超过 MTU 大小，从而避免在 IP 层进行分片。
> - 例如，在典型的以太网 MTU 为 1500 字节的情况下，MSS 通常设置为 1460 字节。

# ==项目==

## 网络服务器



## 工件缺陷检测



# ==嵌入式==

## 引导程序存在哪里

Flash  ROM

## 嵌入式启动流程

> ### 1. 上电（Power On）
>
> - **供电**：设备通电，电源管理模块初始化供电。
> - **电源稳定**：电源电压稳定后，系统开始启动过程。
>
> ### 2. 复位（Reset）
>
> - **复位信号**：复位信号会将所有硬件和寄存器复位到初始状态，确保系统在已知状态下开始运行。
> - **初始化硬件**：复位后，硬件（如 CPU、外设等）被初始化。
>
> ### 3. 启动引导（Bootloader）
>
> - **引导加载程序**：系统启动后，处理器从预定义的引导地址（通常是 ROM 或 Flash 中的特定地址）开始执行启动引导程序。
> - **自检与硬件初始化**：引导程序会进行初始化检查，确保必要的硬件正常工作（例如，内存和外设）。
> - **加载操作系统或应用**：引导程序会从存储设备（如 Flash 或 SD 卡）加载操作系统、固件或应用程序到内存中。
>
> ### 4. 操作系统初始化
>
> - **内核启动**：如果嵌入式系统使用操作系统，启动引导程序完成后，控制权移交给操作系统内核。
> - **内存管理**：内核初始化内存管理子系统，准备系统资源。
> - **驱动加载**：内核加载并初始化各个外设驱动，确保硬件功能可用。
>
> ### 5. 用户空间初始化
>
> - **初始化系统服务**：内核启动后，用户空间的服务和应用程序会被初始化。
> - **启动应用程序**：最后，系统会启动用户应用程序或任务，开始实际的功能执行。
>
> ### 6. 运行时阶段
>
> - **事件处理**：系统进入主循环，处理输入、执行逻辑和管理外设。
> - **状态监控**：系统持续运行，监控状态、处理错误和进行必要的通信。
>
> ### 7. 关机流程（可选）
>
> - **安全关机**：一些嵌入式系统在关机前会进行安全关机流程，保存状态和关闭外设。
> - **断电**：完成关机流程后，切断电源。

## arm架构了解



## stack overflow

**无限递归**：

**过大的局部变量**：

## 哪些数据在rom flash

RAM 内存

ROM 机械硬盘 

**Flash** 固态硬盘

是一种非易失性存储器，能够在断电后保留数据，并且比传统的 ROM 具有更快的读写速度和更大的存储容量

## 控制权交换操作系统

听过把控制权交换给操作系统，为什么不能拿回来



### 控制权交给操作系统的意义

现代操作系统将硬件控制权集中管理，这种设计带来了以下好处：

1. **安全性**：用户程序无法直接访问硬件，必须通过操作系统提供的接口（如系统调用）。这可以防止恶意程序或错误程序直接操作硬件，避免安全问题和系统崩溃。
2. **多任务处理**：操作系统可以公平地调度多个进程或线程运行，使它们共享 CPU 时间和硬件资源。如果每个程序都可以直接控制硬件，系统可能会因为资源冲突而失效。



在大多数现代操作系统中，一旦硬件的控制权交给操作系统，用户程序通常**不能直接收回控制权**。原因包括以下几点：

1. **用户态和内核态的分离**：
   - 现代操作系统将程序的执行分为**用户态**和**内核态**



## 实时操作系统和LINUX区别



## [通信协议](https://www.cnblogs.com/Goforyouqp/p/17606906.html)

# 算法

## 音视频编码

> ### 视频编码格式：
>
> 1. **H.264 (MPEG-4 AVC)**：
>    - 最常用的视频编码格式之一，具有良好的压缩效率和广泛的兼容性。
>    - 用于在线视频、视频会议、移动设备等。
> 2. **H.265 (HEVC)**：
>    - 高效视频编码，比H.264压缩效率更高，适合4K、8K视频传输。
>    - 常见于高分辨率视频的播放和流媒体服务。
> 3. **VP8/VP9**：
>    - Google开发的开源视频编码格式，VP8常用于WebRTC，VP9在YouTube等平台广泛应用。
>    - VP9压缩效率与H.265相当，兼容性较好。
> 4. **AV1**：
>    - 开源的下一代视频编码格式，压缩效率比H.265和VP9更高。
>    - 逐渐被流媒体平台采用，如Netflix、YouTube等。
> 5. **MPEG-2**：
>    - 较老的视频编码标准，仍然应用于DVD和一些电视广播。
> 6. **MPEG-4 Part 2**：
>    - MPEG-4标准的一个子集，早期用于视频流媒体和移动视频播放。
>
> ### 音频编码格式：
>
> 1. **AAC (Advanced Audio Coding)**：
>    - 高效的音频压缩格式，常用于流媒体和视频的音频部分，如YouTube、Apple Music等。
>    - 比MP3音质更好，压缩率更高。
> 2. **MP3**：
>    - 广泛使用的音频编码格式，虽然老旧但仍然应用于许多音频设备。
>    - 兼容性好，文件较小。
> 3. **Opus**：
>    - 开源音频编码格式，支持宽频带和多种比特率。
>    - 常用于VoIP、视频会议和实时通信中，如WebRTC。
> 4. **FLAC (Free Lossless Audio Codec)**：
>    - 无损音频编码格式，音质高但文件较大。
>    - 适用于高保真音频存储。
> 5. **Vorbis**：
>    - 开源音频编码格式，常用于OGG容器中。
>    - 在一些游戏和视频平台中使用，类似于MP3和AAC。
> 6. **PCM (Pulse Code Modulation)**：
>    - 一种无压缩的音频编码格式，音质好，但文件大。
>    - 常用于音频录制和编辑。
> 7. **WAV**：
>    - 一种容器格式，通常包含PCM编码的音频，常用于高质量音频存储。
>
> 在音视频领域，了解这些编码格式的特点和适用场景有助于应对面试问题。



# 手撕代码

### [atoi (ascii to int )](https://blog.csdn.net/qq_57425280/article/details/133438479)            

```c
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
int my_atoi(const char* str)
{
	assert(str);
	//用isspace函数向后过滤空白字符
	//isspace返回值不为0，代表是空格
	while (isspace(*str))
	{
		str++;
	}//走到这里str一定不是空格了
	if (*str == '\0')//空字符串问题
	{
		return 0;
	}
	//+-号问题
	int flg = 1;
	if (*str == '+')
	{
		flg = 1;
		str++;
	}//注意这里要用else if，不能用else
	else if(*str == '-')
	{
		flg = -1;
		str++;
	}
	long long n = 0;
	while (*str != "\0")
	{
		if (isdigit(*str))
		{//是数字字符==>返回值不为0
			n = n * 10 + (*str - '\0') * flg;
		}
		else//不是数字字符
		{
			return (int)n;
		}
		str++;
	}
	return (int)n;
}
int main()
{
	int ret = my_atoi("123");
	printf("&d\n", ret);
	return 0;
}
```



