# 廖

## 一面

咸的C:
一面我看基本都是，课程中遇到的困难有哪些，然后问了问项目

咸的C:
再就是几个八股

咸的C:
很快

咸的C:
课程用遇到的困难，然后科研中遇到的困难，然后就是

### c cpp内存分配区别

> ### 1. 动态内存分配方法：
>
> - **C语言：**
>   - 在C中，使用库函数 `malloc()` 和 `free()` 进行动态内存分配和释放。
>   - `malloc()` 会在堆中分配指定大小的内存，返回 `void*` 指针，需要显式地进行类型转换。
>   - 内存分配后，需要手动调用 `free()` 来释放分配的内存，防止内存泄漏。
> - **C++语言：**
>   - 在C++中，使用 `new` 和 `delete` 进行动态内存分配和释放。
>   - `new` 自动返回分配对象的类型，无需进行显式的类型转换。
>   - 对于动态分配的数组，应该使用 `delete[]` 来释放内存。
>   - C++中也可以使用 C 的 `malloc()` 和 `free()`，但推荐使用 `new` 和 `delete`。

### c和cpp的封装区别

> **C语言：**
>
> - 封装在 C 语言中是通过 **结构体（struct）** 和 **函数** 的结合来实现的，但它并没有严格意义上的封装概念。C 语言中没有直接的访问权限控制（如 `private`, `protected` 等），所有结构体成员默认是 **公开的**，无法直接限制对某些成员变量的访问。
> - 封装在 C 语言中更多是一种“约定”，通过设计接口函数，程序员可以自觉地遵循某种封装原则，但编译器不会对封装进行强制检查。
>
> **C++语言：**
>
> - C++ 是一种面向对象编程语言，封装是其核心特性之一。C++ 通过 **类（class）** 和 **访问控制修饰符** (`public`, `private`, `protected`) 来实现封装。类的成员变量可以被定义为 `private`，只能通过类内的公共接口函数（`public`）进行访问和修改，这种机制被编译器严格检查和执行。

### 还有内存泄漏，怎么避免

> ### **动态内存分配与释放匹配**
>
> - **规则：每次动态分配内存时，一定要确保有相应的内存释放。**
> - 在 C 中，使用 `malloc()` 或 `calloc()` 分配的内存必须对应使用 `free()` 来释放。
>
> ### 智能指针（C++）
>
> - 在 C++ 中，使用 **智能指针**（如 `std::unique_ptr`, `std::shared_ptr`）可以自动管理内存。智能指针会在指针超出作用域时自动释放内存，减少手动管理内存的风险
>
>  **养成良好的内存管理习惯**，并结合工具和语言提供的特性（如 C++ 的 RAII 和智能指针）。在编写代码时，要时刻记住匹配的内存分配与释放操作，减少复杂的指针操作，尽量使用标准库提供的自动管理内存的工具和容器。通过这些手段，可以有效避免内存泄漏问题的发生。

还有一个举个生活中多态的例子

咸的C:

### 在函数外部定义一个指针，然后传到这个函数里面分配内存，在函数外面可以访问这个内存吗

> 不可以要引用



## 二面

今天就是一上来就是，自我介绍，深度学习的项目，问了一下预处理的方法是什么，我答得人工筛选然后降噪然后我自己加了一个子区域对比度拉伸提高亮度，再就是进行网络的一个提取。然后就是问了操作系统的项目，先是问了为什么中断不能加入睡眠，还有一个问题就是死锁的，怎么查死锁，然后说如果查到了资源中死锁的状态是怎么样的，这个我不太答得上来，我就是通过看进程等待的时间啥的来判断的，还有就是问我有没有检查过死锁，我说我主要是在完成项目中完成一部分就进行调试检查，没有检查过整个大工程的死锁。

咸的C:
包括降噪用了什么方法，能有什么改进

咸的C:
我也是瞎扯的

咸的C:
然后后面的死锁就是把你之前发我的那个里面答了7788，细问的没太答上来

咸的C:
为什么有睡眠，我也不太记得了，没答上来感觉，但是扯出来了一些意思

咸的C:
后面去查感觉是答错了

# 牛客

### 类要放进vector需要什么要求

实现构造析构赋值拷贝


\1. 谈谈构造函数和析构函数

### 虚函数的定义用途？

> 虚函数（Virtual Function）是一个可以在基类中声明并在派生类中重新定义（覆盖）的成员函数。虚函数允许通过基类的指针或引用来调用派生类中的函数，从而实现多态

### 使用虚函数可能面临哪些问题

> ### **性能开销**
>
> - **虚函数的调用会引入额外的性能开销**，因为虚函数的调用需要通过虚函数表（vtable）来实现动态绑定，而不是直接通过函数地址进行调用。
>
> ### **内存开销**
>
> - **虚函数会增加类的内存开销**。每个包含虚函数的类对象都会携带一个指向虚函数表的指针（vptr），这会增加每个对象的内存使用量。虽然这个额外的开销通常很小（通常是一个指针的大小），但在某些内存敏感的场景下，可能会带来影响。
>
> ###  **无法在构造函数和析构函数中调用虚函数**
>
> - **在构造函数或析构函数中调用虚函数不会产生预期的多态行为**。这是因为在构造函数和析构函数执行时，派生类对象还没有完全构造好或已经开始销毁，因此调用的虚函数将是基类的版本，而不是派生类的版本。
> - 这可能导致意想不到的行为。如果程序设计需要在对象构造期间实现多态，那么需要谨慎处理。

### Public, Private,Protced之间的关系

> **定义**：`protected` 成员可以在类的内部和派生类中访问，但不能在类的外部直接访问。它介于 `private` 和 `public` 之间，允许派生类访问基类的受保护成员，但不允许外部直接访问。
>
> **作用**：`protected` 常用于继承中，允许派生类访问基类的某些内部实现细节，同时保持对外部的隐藏。

### 友元

> 在 C++ 中，**友元（friend）** 是一个可以访问类中 `private` 和 `protected` 成员的非成员函数或类。友元打破了类的封装性，使得某些特定函数或类可以访问类的私有和保护成员。友元主要有三种类型：**友元函数、友元类** 和 **友元成员函数**。
>
> ### 1. **友元函数**
>
> 友元函数是类外的普通函数，但它被声明为该类的友元，可以访问类的所有成员（包括 `private` 和 `protected` 的成员）。
>
> - 友元函数本质上不是类的成员函数，但它可以访问类的私有数据。
> - 友元函数可以在类中进行声明，并在类外进行定义

作者：Misayo
链接：https://www.nowcoder.com/feed/main/detail/393687ea8245415f95c625c4b05bf933?sourceSSR=search
来源：牛客网

