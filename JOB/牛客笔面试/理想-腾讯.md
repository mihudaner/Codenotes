# 理想一面



### [线程优先级反转](https://blog.csdn.net/hankyt/article/details/119156154)

[](https://blog.csdn.net/hankyt/article/details/119156154)

### 隐式类型转换规则

> C++中的隐式类型转换规则如下：
>
> 1. 标准的内置类型之间可以进行隐式类型转换，如整型之间的转换，浮点型之间的转换等。
> 2. ==派生类对象可以隐式转换为基类对象==。
> 3. 数组可以隐式转换为指针，指向数组的首元素的指针。
> 4. ==可以将指针类型隐式转换为void指针类型==。
> 5. const修饰的对象可以隐式转换为非const修饰的对象，但反过来不行。
> 6. 枚举类型可以隐式转换为整型。
> 7. 如果有多个用户定义的类型转换函数可用时，编译器根据转换的最少次数来选择转换函数。
> 8. 如果存在二义性的隐式类型转换，编译器会报错

> ### . **基本类型之间的转换**
>
> - **整型提升**：小的整型（如 `char`, `short`）会被提升到 `int` 或 `unsigned int` 类型。
> - **浮点转换**：`float` 可以隐式转换为 `double`，但是反向转换（`double` 转 `float`）需要显式转换以避免精度损失。
> - **整型与浮点型转换**：整型可以隐式转换为浮点型，而浮点型转换为整型时会丢失小数部分，需要显式转换。

### 怎么提高资源命中率

说的是++i i++的区别

但是这个好像是执行效率的区别

应该说二位数组的遍历，尽量按顺序遍历连续的内存空间可能会提高命中率



### 一个auto给另一个auto变量赋值吗





# 腾讯电话 廖

### sizeof string问题

他问一个结构体有

```
struct A
{
int
double
string多大
}


```

string 8
vector<int> 24
vector<bool> 40

[和编译器有关](https://bbs.csdn.net/topics/310210540)



### 这个结构体能否就是用malloc来存

> `std::string` 是一个复杂类型，它内部管理自己的内存。通常，`sizeof(A)` 会返回 `int` 和 `double` 的大小加上 `std::string` 的固定部分。
>
> 
>
>  ==malloc 分配 struct A  会不会造成string没有分配?==
>
> 是的，使用 `malloc` 分配 `struct A` 时，`std::string` 成员不会被正确初始化。`malloc` 只是分配了原始内存，不会调用 `std::string` 的构造函数，因此可能导致未定义行为。为了确保 `std::string` 正确分配和初始化，建议使用 `new`：

### 说如果就是我在听音乐的时候发现CPU占用率只有3%

### ![image-20240926010106957](E:\codenotes\JOB\牛客笔面试\img\image-20240926010106957.png)



