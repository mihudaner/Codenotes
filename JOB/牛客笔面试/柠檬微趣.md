#### 内存对齐了解么？内存对齐优缺点

> 优点：需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据  
>
> 缺点：浪费空间

#### 是只能四字节对其么？对齐的规则

> 1. 对齐原则： 
>
> 【原则1】数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为 0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较 小的那个进行。 
>
> 
>
> 【原则2】结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
>
> 
>
>  【原则3】结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素 大小的整数倍地址开始存储。

#### 发了四个结构体，求sizeof

https://blog.51cto.com/u_4018548/6486412



#### 了解多态么？

> 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，静态多态和动态多态
>
> 
>
> 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错  
>
> 
>
> 动态多态：其实要实现动态多态，需要几个条件——即动态绑定条件：
> \1. 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
> \2. 通过基类类型的指针或引用来调用虚函数  



#### 重写的方法是存在一个什么东西里？

虚函数表



#### [虚函数表存在哪？](https://blog.csdn.net/qq_57328462/article/details/125894247)

> 1. 虚函数表：若一个类中包含虚函数，则**在编译期，就会生成一个虚函数表**，这个**虚函数表存放**的是所有虚函数的**函数地址**
>
> 注意：[虚函数表](https://so.csdn.net/so/search?q=虚函数表&spm=1001.2101.3001.7020)**属于类**，所有**相同类的对象共享一个虚函数表**不同的类有不同的虚函数表。
>
> 
>
> 虚函数表位于*只读数据段*(.rodata)



#### 如果不重写是不是就没有这个表？

> 如果基类有虚函数，即使派生类没有重写虚函数，派生类仍然会有一个 `vptr`，并且它会指向一个虚函数表。



#### 指针什么时候创建存在哪？

> **创建时机**：虚函数表指针在对象的构造函数中初始化。每当一个对象被创建时，构造函数负责将该对象的虚指针 `vptr` 初始化为指向该类的虚函数表。



#### 什么是纯虚函数

> 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0  
>
> 
>
> 同时含有纯虚拟函数的类称为抽象类，它不能生成对象  



#### 对new的了解？

我就说了会调用构造函数，返回一个对象指针，她说希望我回答的是new和malloc的区别

![image-20240814110147847](E:\codenotes\JOB\牛客笔面试\img\image-20240814110147847.png)





#### 什么是内存泄漏

> 简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用
> 后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数 



#### 如何避免内存泄漏

> 将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；使⽤智能指针  
>
>  



#### 智能指针的了解

> 2. 常见的智能指针有shared_ptr、unique_ptr和weak_ptr等。它们各有不同的使用场景和特点:
>    - shared_ptr允许多个智能指针共享同一个对象,引用计数机制确保对象在最后一个指针释放时被删除。
>    - unique_ptr独占对象的所有权,不允许拷贝,只能移动。
>    - weak_ptr不会增加引用计数,用于打破shared_ptr之间的循环引用。



#### vector的了解和底层，基本的结构什么的

> **动态数组**：`std::vector` 提供了类似数组的功能，但支持动态调整大小，可以在运行时根据需要添加或删除元素。
>
> **随机访问**：`std::vector` 支持 O(1) 时间复杂度的随机访问，即通过索引直接访问元素。
>
> **自动内存管理**：`std::vector` 会自动管理其内部的内存分配和释放，避免了手动管理内存的复杂性。
>
> **自动扩容**：当 `vector` 的容量不足以容纳新元素时，它会自动扩展内存以容纳更多元素。
>
> **插入和删除**：`std::vector` 支持在任意位置插入和删除元素，但这些操作的时间复杂度通常为 O(n)，因为可能需要移动其他元素
>
> 
>
> `std::vector` 的底层实现通常包含一个指向元素存储区域的指针（`pointer`）、当前元素个数（`size`）、和当前容量（`capacity`）





#### 扩容是怎么寻找新的内存的过程，什么机制或者说规则？是遍历么？

不知道她想问什么，时候感觉像问虚拟内存和分页机制

> **内存分配器的工作原理**：`std::allocator` 会调用底层的内存分配函数（例如 `malloc` 或 `operator new`），这些函数从操作系统获取内存。这些内存分配函数并不会遍历磁盘，而是通过操作系统的内存管理机制从物理内存中分配内存
>
> 
>
> **虚拟内存**：应用程序运行在虚拟地址空间上，操作系统负责将虚拟地址映射到物理内存。这种机制允许应用程序请求的内存块是连续的，而不必关心物理内存的实际布局。
>
> **分页系统**：物理内存被划分为固定大小的页（通常是 4KB），操作系统根据需要将虚拟内存页映射到物理内存页。
>
> **堆管理**：当 `vector` 请求新的内存块时，操作系统会从进程的堆区域分配内存

### 手撕

#### 翻转链表

柠檬微趣：vscode共享屏幕写，自己写结构体和测试案例

```c
#include<iostream>
using namespace std;


class Node
{
public:
    Node(int x):val(x){};
    Node* next = nullptr;
    int val;
};

Node* reverse(Node* head)
{
    Node* pre = nullptr;
    Node* nd;
    while(head!=nullptr)
    {
        nd = head->next;
        head->next = pre;
        pre = head;
        head = nd;
    }
    return pre;
}

int main()
{
    Node* a = new Node(1);
    Node* a1 = new Node(2);
    Node* a2 = new Node(3);
    Node* a3 = new Node(4);
    Node* a4 = new Node(5);
    a->next = a1;
    a1->next = a2;
    a2->next = a3;
    a3->next = a4;
    a = reverse(a);
    while(a!=nullptr)
    {
        cout << a->val <<endl;
        a = a->next;
    }
    return 0;
}
```

#### 实现类似共享指针的功能

柠檬微趣：需要实现有参无参构造，析构函数，拷贝构造，赋值语句，移动构造，

```c
#include<iostream>
using namespace std;

template<class T>
class Shareptr
{
public:
    Shareptr(){
        cnt = new int(1);
    };
    Shareptr(T other):{
        ptr = new T(other)
        cnt = new int(1);
    };
    Shareptr(const Shareptr& other){
        ptr = new T(*other.ptr);
        cnt = new int(1);
    };
    ~Shareptr(){
        if(--(*cnt)==0)
        {
            delete ptr;
            delete cnt;
        }
    };
    Shareptr(const Shareptr&& other){
        ptr = other.ptr;
        delete other.ptr;
        other.ptr = nullptr;
        cnt = *(other.cnt);
    };
    operator=(const Shareptr& other)
    {
        if(--(*cnt)==0)
        {
            delete ptr;
            delete cnt;
        }
        ptr = other.ptr;
        cnt = ++*(other->cnt);
    };
private:
    T* ptr;
    int* cnt;
};

```

### 