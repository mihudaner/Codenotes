语法

function

```c
 function<long long(int, int)> dfs = [&](int x, int fa) -> long long 
  {
  }

   auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {}；
```

数组初始化需要长度，vector可有可无

```c
vector<vector<int>>nums(3,vector<int>(5,0));//创建三行五列的数组,初始值为0

array<int, 26>& arr   

```

排序

```c
        sort(id.begin(), id.end(), [&](int i, int j) { return spells[i] < spells[j]; });

```

```c

struct cmp1{
	    bool  operator ()  ( PII  a , PII  b  ){
	   	      return a.second > b.second;
	   } 
}; 
struct cmp2{
	    bool  operator ()  ( PII  a , PII  b  ){
	   	      return a.second < b.second;
	   } 
}; 

class StockPrice {
public:

    priority_queue<PII,vector<PII>,cmp1>  q_greater;
    priority_queue<PII,vector<PII>,cmp2>  q_less;
```

循环

```
int j = 0;
while(++j<5) cout <<j <<endl;
1
2
3
4

j = 0;
while(j++<5) cout <<j <<endl;
1
2
3
4
5

j = 0;
for(j;j<5;j++) cout <<j <<endl;
0
1
2
3
4

j = 0;
for(j;j<5;++j) cout <<j <<endl;
0
1
2
3
4

j = 0;
for(j=0;j<5;++j) cout <<j <<endl;
0
1
2
3
4

while是先执行条件
for是先执行循环体
```

&*

```
int *&a 指向 int 类型的指针 的引用
int &*a 可以解释为，int类型引用 的指针（C++不允许声明 指向引用的指针）。
```



# 热题100

## 哈希



### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

> 已解答
>
> 
>
> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
> ```

```c
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n=nums.size();
        for(int i=0;i<n;i++)
            for(int j=i+1;j<n;j++)
                if(nums[i]+nums[j]==target)
                    return {i,j};
        return {};
    }   
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。
>
> **字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。
>
>  
>
> **示例 1:**
>
> ```
> 输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
> 输出: [["bat"],["nat","tan"],["ate","eat","tea"]]=
> ```

法1：==优==

由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

```c
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        map<string,vector<string>> cm;
        vector<vector<string>> result;
        for(auto word:strs)
        {
            string tp = word;
            sort(tp.begin(),tp.end());
            cm[tp].push_back(word);
        }
        for(auto &[k,v]:cm)
            result.push_back(v);
        return result;

    }
};
```

法2：

可以使用长度为 26 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。

==c++貌似hash的键支持vector和数组，但是这里自定义的是异位词是相同的key==

```c
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 自定义对 array<int, 26> 类型的哈希函数
        auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {
            return accumulate(arr.begin(), arr.end(), 0u, [&](size_t acc, int num) {
                return (acc << 1) ^ fn(num);
            });
        };

        unordered_map<array<int, 26>, vector<string>, decltype(arrayHash)> mp(0, arrayHash);
        for (string& str: strs) {
            array<int, 26> counts{};
            int length = str.length();
            for (int i = 0; i < length; ++i) {
                counts[str[i] - 'a'] ++;
            }
            mp[counts].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};

```

> 
>
> 这段代码是用C++编写的，主要功能是定义了一个哈希函数 `arrayHash`，用于将 `array<int, 26>` 类型的数组映射到哈希值，并创建了一个使用该哈希函数的无序映射 `unordered_map`。
>
> 让我们一行一行来解释：
>
> 1. `// 自定义对 array<int, 26> 类型的哈希函数`：这是一行注释，说明了下面的代码段是用来自定义对 `array<int, 26>` 类型的数组进行哈希的函数。
>
> 2. `auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t { ... };`：这行代码定义了一个 lambda 函数 `arrayHash`，该 lambda 函数接受一个 `array<int, 26>` 类型的数组 `arr` 作为参数，并返回一个 `size_t` 类型的哈希值。`fn = hash<int>{}` 这部分是初始化一个哈希函数对象，用于将数组中的每个 `int` 元素进行哈希。
>
> 3. `return accumulate(arr.begin(), arr.end(), 0u, [&](size_t acc, int num) { return (acc << 1) ^ fn(num); });`：这行代码使用 `accumulate` 算法对数组中的元素进行累加，同时对每个元素应用哈希函数，并使用位运算对结果进行混合，最终得到数组的哈希值。
>
> 4. `unordered_map<array<int, 26>, vector<string>, decltype(arrayHash)> mp(0, arrayHash);`：这行代码定义了一个无序映射 `unordered_map`，其键类型为 `array<int, 26>`，值类型为 `vector<string>`，并指定了自定义的哈希函数 `arrayHash` 用于计算键的哈希值。`mp` 是这个无序映射对象的名称，`0` 是初始桶数，`arrayHash` 是用于哈希的函数对象。



### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
> 请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [100,4,200,1,3,2]
> 输出：4
> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,3,7,2,5,8,4,6,0,1]
> 输出：9
> ```

```c
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if(nums.size()==0) return 0;
        sort(nums.begin(),nums.end());
        int last=nums[0],cnt=1,mx=0;
        for(auto num:nums)
        {
            cout << num << endl;
            if(num == last+1) cnt++;
            else if(num == last) continue;
            else
            {
                mx = max(mx,cnt);
                cnt =1;
               
            } 
            last = num;
        }
        mx = max(mx,cnt);
        return mx;
    }
};
```

## 双指针

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```

类似冒泡

```c
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        for(int i=0;i<n;i++)
            for(int j=1;j<n;j++)
                if(nums[j-1]==0&&nums[j])
                {
                    //cout << i << j << endl;
                    int temp = nums[j];
                    nums[j] = nums[j-1];
                    nums[j-1] = temp;
                }
        return;
    }
};


```

双指针

```c
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int i,j;
        for(i=0;i<n-1;i++)
        {
            if(nums[i]!=0) continue;
            for(j=i+1;j<n;j++)
                if(nums[j]!=0)
                {
                    cout << i << j <<endl;
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = temp;
                    break;
                };
           
        }
        return;
    }
};
```



### [11.盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)



> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。
>
> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> **说明：**你不能倾斜容器。
>
>  
>
> **示例 1：**
>
> ![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)
>
> ```
> 输入：[1,8,6,2,5,4,8,3,7]
> 输出：49 
> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
> ```
>
> **示例 2：**
>
> ```
> 输入：height = [1,1]
> 输出：1
> ```

> 在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 −1-1−1 变短：
>
> 若向内 移动短板 ，水槽的短板 min(h[i],h[j])min(h[i], h[j])min(h[i],h[j]) 可能变大，因此下个水槽的面积 可能增大 。
> ==若向内 移动长板== ，水槽的短板 min(h[i],h[j])min(h[i], h[j])min(h[i],h[j]) 不变或变小，==因此下个水槽的面积 一定变小==。
> 因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积

```c

class Solution {
public:
    int maxArea(vector<int>& height) {
        
        int res=0,l=0;
        for(int i=0;i<height.size()-1;i++)
        {
            if(height[i]<height[l]) continue;
            for(int j=height.size()-1;j>i;j--)
            {
                int t = min(height[i],height[j])*(j-i);
                if(t>res)
                {
                    l = i;
                    res =t;
                }
              
            }  
        }
        return res;
    }
};


```

或者正反遍历一遍获得左侧最高点和右侧最高点

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

> 
> 相关标签
>
> 相关企业
>
> 
>
> 提示
>
> 
>
> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请
>
> 你返回所有和为 `0` 且不重复的三元组。
>
> **注意：**答案中不可以包含重复的三元组。
>
>  
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> 解释：
> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
> 注意，输出的顺序和三元组的顺序并不重要。
> ```

```c
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int n = nums.size();
        vector<vector<int>> res;
        for(int i=0;i<n-2;i++)
        {
            if(i>0&&nums[i]==nums[i-1]) continue;
            //if(nums[i]>0) break;
            if(nums[i] + nums[n-2] + nums[n-1] < 0) continue;
            if(nums[i] + nums[i+1] + nums[i+2]>0) break;
            for(int j=i+1;j<n-1;j++)
            {
                if(nums[i]+nums[j]>0) break;
                int k = n-1;
                while(k>j&&-nums[k]<nums[i]+nums[j]) k--;
                if(k==j) break;
                if(-nums[k]==nums[i]+nums[j])
                {
                    res.push_back({nums[i],nums[j],nums[k]});   
                }
                while(j<n-1&&nums[j]==nums[j+1]) j++;
            }  
        }
       
        return res;
    }
};

//难点在于，答案不能重复，第一个第二个数字需要去重
//第一个第二个数字确定，和为0第三个数字值只有一个确定的值，不需要每次都算和
//第三个数字迭代从右向左，这样如果迭代完j=k,j后面也不需要算了，直接算下一个i
//if(nums[i] + nums[n-2] + nums[n-1] < 0) continue;
//if(nums[i] + nums[i+1] + nums[i+2]>0) break;
```



### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

> ==困难==
>
> 滑动窗口
>
> 
>
> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
>
> ```
> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出：6
> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
> ```
>
> **示例 2：**
>
> ```
> 输入：height = [4,2,0,3,2,5]
> 输出：9
> ```



```c
class Solution {
public:
    
    int trap(vector<int>& height) {
        
        int n = height.size(),l = 0, r = 1;
        if(n<3) return 0;
        int res=0;
        //计算左侧第一个下降
        while(height[l]<height[r])
        {
            r++;
            l++;
        }
        function<int(int,int)> acula = [&](int le,int r) ->int{
            int re = 0;
            int mi = min(height[le],height[r]);
            for(int i =le+1;i<r;i++) re+= max(mi - height[i],0);
            return re;
        };

        for(int i=2;i<n;i++)
        {
            if(height[r]<=height[i])
            {
                
                if(height[i]>=height[l])
                {
                    res+=acula(l,i);
                    cout << res << " " << i<< " " << l << " " << r << " "<< endl;
                    l = i;
                    r = i+1;
                }
                else 
                {
                    r = i;
                }
            }
            else if(height[r]>height[i])
            {
                r = i;
            }
        }
        
        int last_h = n-1;
        //计算右侧第一个下降
        while(last_h>0&&height[last_h]<height[last_h-1]) last_h--;
        res += acula(l,last_h);

        cout << res << " " << l<< " " << last_h << " "<< endl;


        return res;
    }
};

```

> 思路是新的数字大于左侧数字就累加，大于右侧数字就移动右侧
>
> 但是==有问题==：
>
> 如果左侧
>
> ```
> [9,6,8,8,5,6,3]
> 标准输出
> 1 0 5 
> 输出
> 1
> 预期结果
> 3
> ```
>
> 如果左侧始终，中间的8不是递减就会出错
>
> 这其实是一个只有底和顶的栈，错的

==法一==：左遍历一遍求左侧最高点，右遍历一遍求右最高点，取最小值，累加

==法二：==改下思路,需要用单调栈：

> 所以应该保持递减，数字大于右侧数字就累加 高出右侧的部分
>
> 
>
> ![image-20240223160610294](/home/wangkai/codenotes_ubuntu/Leecode/img/image-20240223160610294.png)

```c
class Solution {
public:
    
    int trap(vector<int>& height) {
        vector<int> st;
        int n = height.size(),res=0;
        if(n<3) return 0;
        st.push_back(0);
        int mx =0;
        for(int i = 1;i<n;i++)
        {
            while(st.size()>0&&height[st.back()]<height[i])
            {
                int top = st.back();
                st.pop_back();
                if(st.empty())
                {
                    break;
                } 
                int left = st.back();
                //关键在于算的时候，高度是和栈顶的,但是算宽度是栈顶的第二个
                //[0,1,0,2,1,0,1,3,2,1,2,1]
                //高度是min(height[7],height[3]) - height[6],宽度是 7 - 3 -1
                int currWidth = i - left - 1;
                int currHeight = min(height[left], height[i]) - height[top];
                res += currWidth * currHeight;
                //cout << i << " " << st.back() << " " << currWidth << currHeight <<  res<< endl;
                
            }
            st.push_back(i);
        }
        return res;
    }
};
```

==法三：== 

> ![image-20240223195026113](/home/wangkai/codenotes_ubuntu/Leecode/img/image-20240223195026113.png)



## 滑动窗口

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
>  
>
> **示例 1:**
>
> ```
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> ```



```c
lass Solution {
public:
    int lengthOfLongestSubstring(string s) {
        
        int hs[500], n = s.size();
        if(!n) return 0;
        memset(hs,-1,sizeof hs);
        int res=0,f = 0,l=-1;
        for(int i=0;i<n;i++)
        {
            int id = s[i];
            if(hs[id]!=-1)
            {
                if(f==0)
                {
                    f = 1;
                    res = i;
                }
                // res = max(res,  i - max(l,hs[id]));!!!
                //cout << res <<  i << hs[id] << endl;
                l =  max(l,hs[id]);
            } 
            res = max(res,  i - max(l,hs[id]));//这里卡好久，不能放在循环里面
            hs[id] = i;

        }
        res = max(res,  n - l -1);
        if(f!=1) return n;
        return res;
    }
};

```

标准解

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(!s.size()) return 0;
        unordered_map<int,int> h;
        int p=1,res = 1;
        h[s[0]] = 1;
        for(int i=1;i<s.size();i++)
        {
            int x = s[i];
            if(h[x]>=p) p = h[x]+1;
            h[x] = i+1;
            //cout << p << s[i]<<endl;
            res = max(res,i-p+2);
        }

        return res;
    }
};
//hashmap+双指针
```



### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)



> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>
> **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。
>
>  
>
> **示例 1:**
>
> ```
> 输入: s = "cbaebabacd", p = "abc"
> 输出: [0,6]
> 解释:
> 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
> 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
> ```
>
>  **示例 2:**
>
> ```
> 输入: s = "abab", p = "ab"
> 输出: [0,1,2]
> 解释:
> 起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
> 起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
> 起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
> ```

```c
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int l = -1;
        unordered_map<char,int> ha;
        unordered_map<char,int> hb;
        vector<int>res;
        for(int i=0;i<p.size();i++)
        {
            char cc = p[i];
            ha[cc] ++;
        }

        for(int i=0;i<s.size();i++)
        {
            char c = s[i];
            hb[c]++;
            //cout << hb[c]<<ha[c] << endl;
            if(hb[c]>ha[c])
            {
                while((s[l+1]!=c))
                {
                    l++;
                    hb[s[l]]--;
                }
                l++;
                hb[s[l]]--;
            }
            //cout << i << l <<  hb['a'] << hb['b'] <<  hb['c'] << endl;
            if(i-l==p.size()) res.push_back(l+1);
        }
        return res;

    }
};

//窗右边添加一个，如果超了哈希表个数 就要左边一直找到该元素，期间左指针一直右移
```

## 子串

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。
>
> 子数组是数组中元素的连续非空序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,1], k = 2
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,3], k = 3
> 输出：2
> ```

```c
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        vector<int> su;
        int n=nums.size(),res=0,sum=0;
        for(int i=0;i<n;i++)
        {
            sum+=nums[i];
            su.push_back(sum);
        }
        for(int i=0;i<n;i++)
        {
            if(su[i]==k) res++;
            for(int j=0;j<i;j++)
            {
                if(su[i]- su[j]==k) res++;
            }
        }
        return res;
    }
};


//关键在于没有想到 前缀和 ！！
//看答案
```

### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

> 困难
>
> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回 *滑动窗口中的最大值* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
> ---------------               -----
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1], k = 1
> 输出：[1]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`
> - `1 <= k <= nums.length`

```c
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q;
        int n = nums.size();
        if(k==1) return nums;
        q.push_back(0);
        vector<int> res;
        for(int i=1;i<n;i++)
        {
            int x = nums[i];
            while(!q.empty()&&(nums[q.back()]<x))
            {
                //cout << q.size() << " ";
                //cout <<endl;
                q.pop_back();
            }
            q.push_back(i);
            if(i- q.front()>k-1) q.pop_front();
            //cout << q.size() << " ";
            //cout <<endl;
            if(i>=k-1) res.push_back(nums[q.front()]);
        }
        return res;
    }
};
//单调队列，
/*
list 的数据插入和删除操作主要在中间位置，当需要在两端插入或删除数据时，其时间复杂度为 O(n)。
deque 是一种双向链表，提供了在两端插入和删除的操作，因此在两端插入或删除数据时，其时间复杂度为 O(1)。
*/
```





### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)==难==

> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。
>
>  
>
> **注意：**
>
> - 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
> - 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "ADOBECODEBANC", t = "ABC"
> 输出："BANC"
> 解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "a", t = "a"
> 输出："a"
> 解释：整个字符串 s 是最小覆盖子串。
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "a", t = "aa"
> 输出: ""
> 解释: t 中两个字符 'a' 均应包含在 s 的子串中，
> 因此没有符合条件的子字符串，返回空字符串。
> ```

```
class Solution {
public:
//还有一个要注意的地方是hash.count(s[l])==0则不能cout访问hash,不然直接等于0了
    string minWindow(string s, string t) {
        unordered_map<char,int> hash;
        int n = s.size(),m  = t.size(),l=0;
        int dis = m;
        pair<int,int> res;
        int size = INT_MAX;
        for(int i =0;i<m;i++)
        {
            hash[t[i]]++;
        }
        for(int i =0;i<n;i++)
        {
            if(hash.count(s[i])==0) continue;
            else
            {
              
                if(--hash[s[i]]>=0) dis--;
                //cout << s[i] <<dis << endl;
                if(dis==0)
                {
                    while((dis==0||hash.count(s[l])==0)&&l<=i)
                    {
                        if(dis==0&&i-l+1<size)
                        {
                            res = {l,i-l+1};
                            size = i-l+1;
                            //cout << "res" << l << i << endl;
                        }
                        if(hash.count(s[l])!=0) hash[s[l]]++;
                        //cout<< l << i <<endl;
                        if(hash.count(s[l])!=0&&hash[s[l]]>0) dis++;
                        l++;
                    } 
                }
              
            }
          
        }
        return s.substr(res.first,res.second);
    }
};
```

https://www.cnblogs.com/grandyang/p/8684817.html

### 最小窗口子序列

https://www.cnblogs.com/lightwindy/p/8486724.html

## 普通数组

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 
>
> **子数组**
>
> 是数组中的一个连续部分。
>
> 
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [5,4,-1,7,8]
> 输出：23
> ```
>
>  

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //f[i] 表示i结尾最大连续子数组和
        const int N = 1e5+10;
        int f[N];
        f[0] = nums[0];
        for(int i=1;i<nums.size();i++)
        {
            f[i] = max(f[i-1]+nums[i],nums[i]);
            cout << f[i] << endl;
        }
        int res = -(1e8);
        for(int i=0;i<nums.size();i++) res = max(res,f[i]);
        return res;
    }
};

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int l = 0, r = 0,n = nums.size(),sum=0; 
        int mx=-99999;
        for(int i=0;i<n;i++)
        {
            sum+=nums[r];
            mx = max(mx,sum); 
            if(sum<0)
            {
                sum=0;
                l =r+1; 
            }
            r++;
        }
        //cout << l << r << endl;
        return mx;
    }
};
```



```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
         """
        for i in range(1, len(nums)):
            nums[i]= nums[i] + max(nums[i-1], 0)
        return max(nums)
```



### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出：[[1,6],[8,10],[15,18]]
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> ```
>
> **示例 2：**
>
> ```
> 输入：intervals = [[1,4],[4,5]]
> 输出：[[1,5]]
> 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
> ```

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
      
        sort(intervals.begin(),intervals.end());
        int n= intervals.size(),l=intervals[0][0],r=intervals[0][1];
        vector<vector<int>> res;
        for(int i=1;i<n;i++)
        {
            //cout << l << r <<endl;
            if(r<intervals[i][0])
            {
                res.push_back({l,r});
                l = intervals[i][0];
                r = intervals[i][1];
            }
            else if (intervals[i][1]>r)
            {
                r = intervals[i][1];
            }
        }
        res.push_back({l,r});
        return res;
    }
};
```



### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

> 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,4,5,6,7], k = 3
> 输出: [5,6,7,1,2,3,4]
> 解释:
> 向右轮转 1 步: [7,1,2,3,4,5,6]
> 向右轮转 2 步: [6,7,1,2,3,4,5]
> 向右轮转 3 步: [5,6,7,1,2,3,4]
> ```
>
> **示例 2:**
>
> ```
> 输入：nums = [-1,-100,3,99], k = 2
> 输出：[3,99,-1,-100]
> 解释: 
> 向右轮转 1 步: [99,-1,-100,3]
> 向右轮转 2 步: [3,99,-1,-100]
> ```

```c
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        vector<int> temp;
        int n = nums.size();
        int x;
        k = k%n;
        std::rotate(nums.begin(), nums.begin() + n- k, nums.end());
        return;
    }
};
```



### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

> 给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。
>
> 题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。
>
> 请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [1,2,3,4]
> 输出: [24,12,8,6]
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [-1,1,0,-3,3]
> 输出: [0,0,9,0,0]
> ```
>
>  
>
> **提示：**
>
> - `2 <= nums.length <= 105`
> - `-30 <= nums[i] <= 30`
> - **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内
>
>  
>
> **进阶：**你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> L;
        vector<int> res;
        int l=1,r=1; 
        for(int i = 0;i<nums.size();i++)
        {
            L.push_back(l);
            l*= nums[i];
        }
        for(int i = nums.size()-1;i>=0;i--)
        {
            res.push_back(L[i]*r);
            r*= nums[i];
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)==难==

困难在常数空间

答案是原数组的空间标记

> 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
>
> 请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,0]
> 输出：3
> 解释：范围 [1,2] 中的数字都在数组中。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,4,-1,1]
> 输出：2
> 解释：1 在数组中，但 2 没有。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [7,8,9,11,12]
> 输出：1
> 解释：最小的正数 1 没有出现。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-231 <= nums[i] <= 231 - 1`

```c
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for(int i=0;i<n;i++)
        {
            if(nums[i]<=0) nums[i] = n+1;
           
        }
        for(int i=0;i<n;i++)
        {
            int x =abs(nums[i]);
            if(x<=n) 
            {
                int idx = x-1;
                nums[idx] = -abs(nums[idx]);
            }
        }
        int i=0;
        for(i;i<n;i++)
        {
            if(nums[i]>0) break;
        }
        return i+1;
    }
};
```



## 矩阵

### [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

> 给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**
>
> 
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)
>
> ```
> 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
> 输出：[[1,0,1],[0,0,0],[1,0,1]]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)
>
> ```
> 输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
> 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
> ```

```
class Solution {
public:
    typedef pair<int,int> PII;
   
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        bool hash[m][n];
        memset(hash,0,sizeof hash);

        function<void(int,int)> func =  [&](int x,int y)
        {
            for(int i=0;i<n;i++)
            {
                hash[x][i] = true;
            }
            for(int i=0;i<m;i++)
            {
                hash[i][y] = true;
            }
            return;
        };

        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(matrix[i][j]==0) func(i,j);
            }
        }
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(hash[i][j]) matrix[i][j]=0;
            }
        }
        return;
    }
};
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)
>
> ```
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[1,2,3,6,9,8,7,4,5]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)
>
> ```
> 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
> 输出：[1,2,3,4,8,12,11,10,9,5,6,7]
> ```

```c
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        typedef pair<int,int> PII;
        int m = matrix.size(),n = matrix[0].size(),i=0,j=0,d=0,cnt=1;
        bool f[m][n];
        memset(f,0,sizeof f);
        vector<PII> dir = {{0,1},{1,0},{0,-1},{-1,0}};
        vector<int> res;
        res.push_back(matrix[0][0]);
        f[0][0] = true;
        while(cnt<n*m)
        {
            i = i + dir[d%4].first;
            j =  j + dir[d%4].second;
            if(i<0||j <0||i>=m||j >=n||f[i][j])
            {
                i = i - dir[d%4].first;
                j =  j - dir[d%4].second;
                d++;
                continue;
            } 
            cnt++;
            res.push_back(matrix[i][j]);
            f[i][j] = true;
            //cout << i << j <<endl;
            
        }
        return res;
    }
};
```

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

> 给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。
>
> 你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)
>
> ```
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[[7,4,1],[8,5,2],[9,6,3]]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)
>
> ```
> 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
> 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
> ```

```c
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n =matrix.size();
        for(int i=0;i<n;i++)
        {
            for(int j=i;j<n;j++)
            {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] =temp;
            }
        }
         for(int i=0;i<n;i++)
        {
            for(int j=0;j<n/2;j++)
            {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][n-j-1];
                matrix[i][n-j-1] =temp;
            }
        }
        return;
    }
};
```

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

> 编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：
>
> - 每行的元素从左到右升序排列。
> - 每列的元素从上到下升序排列。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)
>
> ```
> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)
>
> ```
> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
> 输出：false
> ```

```c
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int idx =0;
        if(matrix[0][0]>target) return false;
        if(matrix[0][0]==target) return true;

        
        for(int i=0;i<m;i++)
        {
            if(matrix[i][0]>target) continue;
            if(matrix[i][n-1]>=target)
            {
                for(int j=0;j<n;j++)
                {
                    if(matrix[i][j]==target) return true;
                }
            } 
        }
        return false;
    }
};
```

## 链表

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

> 你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。
>
> 图示两个链表在节点 `c1` 开始相交**：**
>
> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)
>
> 题目数据 **保证** 整个链式结构中不存在环。
>
> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。
>
> **自定义评测：**
>
> **评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：
>
> - `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
> - `listA` - 第一个链表
> - `listB` - 第二个链表
> - `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
> - `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数
>
> 评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。
>
>  
>
> **示例 1：**
>
> [![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)
>
> ```
> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
> 输出：Intersected at '8'
> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
> — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
> ```

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode * headB) {
        ListNode *now1 = headA;
        while(now1!=NULL)
        {
            ListNode *now2 = headB;
            while(now2!=NULL)
            {
                if(now2==now1) return now1;
                now2 = now2->next;
            }
            now1 = now1->next;
        }
        
        return NULL;
    }
};
```



### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)
>
> ```
> 输入：head = [1,2]
> 输出：[2,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = []
> 输出：[]
> ```

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr) return nullptr;
       
        ListNode* last =nullptr;
        while(head!=nullptr)
        {
            ListNode* nd = new ListNode;
            nd->val = head->val;
            nd->next = last;
            last = nd;
            head = head->next;
        }
        return last;
    }
};

//不能在while里面写ListNode(int x, ListNode *next)，因为链表next指向局部变量被释放了
```





### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

> 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)
>
> ```
> 输入：head = [1,2,2,1]
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)
>
> ```
> 输入：head = [1,2]
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - 链表中节点数目在范围`[1, 105]` 内
> - `0 <= Node.val <= 9`

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> v;
        ListNode* h = head;
        while(h!=nullptr)
        {
            v.push_back(h->val);
            h = h->next;
        }
        h = head;
        while(!v.empty())
        {
            if(h->val!=v.back()) return false;
            v.pop_back();
            h = h->next;
        }
        return true;
    }
};
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

> 给你一个链表的头节点 `head` ，判断链表中是否有环。
>
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。
>
> *如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)
>
> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：true
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)
>
> ```
> 输入：head = [1,2], pos = 0
> 输出：true
> 解释：链表中有一个环，其尾部连接到第一个节点。
> ```
>
> **示例 3：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)
>
> ```
> 输入：head = [1], pos = -1
> 输出：false
> 解释：链表中没有环。
> ```

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_map<ListNode *,int> mp;
        while(head!=nullptr)
        {
            if(mp[head]==1) return true;
            mp[head] ++;
            head = head->next;
            
        }
        return false;
    }
};
```



### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

> 给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*
>
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。
>
> **不允许修改** 链表。
>
> 
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)
>
> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：返回索引为 1 的链表节点
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)
>
> ```
> 输入：head = [1,2], pos = 0
> 输出：返回索引为 0 的链表节点
> 解释：链表中有一个环，其尾部连接到第一个节点。
> ```

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_map<ListNode *,int> mp;
        while(head!=nullptr)
        {
            if(mp[head]==1) return head;
            mp[head] ++;
            head = head->next;
            
        }
        return NULL;
    }
};
```

==快慢指针==

![image-20240402204522314](/home/wangkai/codenotes_ubuntu/Leecode/img/image-20240402204522314.png)

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

> 
>
> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)
>
> ```
> 输入：l1 = [1,2,4], l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]
> ```
>
> **示例 2：**
>
> ```
> 输入：l1 = [], l2 = []
> 输出：[]
> ```

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1) return list2;
        if(!list2) return list1;
        if(list1->val<=list2->val) 
        {
            list1->next = mergeTwoLists(list1->next,list2);
            return list1;
        }
        if(list1->val>list2->val) 
        {
            list2->next = mergeTwoLists(list1,list2->next);
            return list2;
        }
        return nullptr;
    }
};
```

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

> 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)
>
> ```
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[7,0,8]
> 解释：342 + 465 = 807.
> ```
>
> **示例 2：**
>
> ```
> 输入：l1 = [0], l2 = [0]
> 输出：[0]
> ```
>
> **示例 3：**
>
> ```
> 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
> 输出：[8,9,9,9,0,0,0,1]
> ```

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

    ListNode* nadd(ListNode* l1,ListNode* l2,int  f=0)
    {
        ListNode * n = new(ListNode);
        if(l1==nullptr) return l2;
        if(l2==nullptr) return l1;

        int a = l1->val;
        int b = l2->val;
        n->val = a+b + f;
        if(n->val==0) return nullptr;
        if(n->val>=10)
        {
            f = 1;
            n->val %=10;
        }
        n->next = nadd(l1->next,l2->next,f);
        return n;
    }

    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        return nadd(l1,l2);
        
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = [1], n = 1
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [1,2], n = 1
> 输出：[1]
> ```

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int len = 0;
        ListNode* b = head;
        while(b!=nullptr)
        {
            b=b->next;
            len++;
        }
        if(len==n) return head->next;
        b = head;
        while(b!=nullptr)
        {
            len--;
            if(len==n) 
            {
                if(b->next==nullptr)  cout << "err" <<endl;
                b->next = b->next->next;
            }
            b=b->next; 
        }
        return head;
    }
};
```

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [1]
> 输出：[1]
> ```

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        
        ListNode* res = new ListNode;
        bool first = false;
        ListNode* now = head;
        ListNode* before =res;
        if(now==nullptr||now->next==nullptr) return now;
        while(now!=nullptr&&now->next!=nullptr)
        {
            ListNode* ne = now->next;
            before->next = ne;
           
            now->next = ne->next;
            ne->next = now;
            before = now;
            now = now->next;
            //cout <<now->val << endl;
        }
        //if(res!=nullptr&&res->next!=nullptr) return res->next;
        return res->next;
    }
};
```

K 个一组翻转链表

困难



### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

> 给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。
>
> 构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。
>
> 例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。
>
> 返回复制链表的头节点。
>
> 用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：
>
> - `val`：一个表示 `Node.val` 的整数。
> - `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。
>
> 你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)
>
> ```
> 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
> 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)
>
> ```
> 输入：head = [[1,1],[2,1]]
> 输出：[[1,1],[2,1]]
> ```
>
> **示例 3：**
>
> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**
>
> ```
> 输入：head = [[3,null],[3,0],[3,null]]
> 输出：[[3,null],[3,0],[3,null]]
> ```

```c
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

//这是无向图？
class Solution {
public:
    Node* copyRandomList(Node* head) {
        vector<int> randoms;
        vector<Node*> ptrs;
        int cnt=0;
        if(head==NULL) return NULL;
        Node* nd = head->next;
        Node* nowcopy = new Node(head->val);
        ptrs.push_back(nowcopy);
        while(nd!=NULL)
        {
            Node* ndcopy =  new Node(nd->val);
            nowcopy->next = ndcopy;
            ptrs.push_back(ndcopy);
            nd = nd->next;
            nowcopy = nowcopy->next;
        }
        ptrs.push_back(NULL);

        nd = head;
        int i =0;
        while(nd!=NULL)
        {
            int x = 0;
            Node* t = head;//需要nd的random指向第几个
            while(t!=NULL&&t!=nd->random)
            {
                x++;
                t = t->next;
            } 
            ptrs[i]->random = ptrs[x];
            i++;
            nd = nd->next;
        }


        // for(int i=0;i<ptrs.size();i++)
        // {
        //     cout<< ptrs[i]->val<<endl;
            
        // }
        return ptrs[0];
    }
};
```



### 排序链表==难==

中等

数组的归并

```c
//首先确定分界点，与快速排序不同，先递归再排序
 
#include<iostream>
 
using namespace std;
 
const int N = 100010;
int n, a[N], tmp[N];//与快速排序相比需要额外用到一个数组来存储归并
 
//归并排序的时间复杂度一般为O(nlogn)
void merge_sort(int a[],int l,int r)
{
    if(l>=r) return ;
    
    int mid=l+r>>1;
    merge_sort(a,l,mid),//;
    merge_sort(a,mid+1,r);//这里用逗号更快一些，因为用逗号是俩同时进行递归
    //无影响 还是递归第一个先
    
    int k=0,i=l,j=mid+1;
    while(i<=mid&&j<=r)
    {
        if(a[i]<a[j]) tmp[k++]=a[i++];
        else tmp[k++]=a[j++];
    }
    while(i<=mid) tmp[k++]=a[i++];
    while(j<=r) tmp[k++]=a[j++];//这两个while是将剩下的全部拿过去
    
    for(int i=l,j=0;i<=r;i++,j++) a[i]=tmp[j];
}
 
int main()
{
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    
    merge_sort(a,0,n-1);
    
    for(int i=0;i<n;i++) cout<<a[i]<<" ";
    
    return 0;
}
```

归并排序

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    //常数级空间复杂度下所以要原地排序
    //这里比较好理解的是归并排序
    ListNode* findmid(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast->next&&fast->next->next)
        {
            slow = slow->next;
            fast = fast ->next->next;
        }
        return slow;
    }
    ListNode* merge(ListNode* l,ListNode*r)
    {
        
        if(!l) return r;
        if(!r) return l;
        if(l->val<r->val)
        {
            l ->next = merge(l->next,r);
            return l;
        }
        else
        {
            r ->next = merge(l,r->next);
            return r;
        }
    }
    ListNode* sortnode(ListNode* head) {
        if(!head||!head->next) return head;
        ListNode* mid= findmid(head);

        ListNode* r = mid->next;
        mid->next = nullptr;
        ListNode* l = head;
        r = sortnode(r);
        l = sortnode(l); 
        // ListNode* t = l;
        // while(t!=nullptr) 
        // {
        //     cout << t->val << " " ;
        //     t=t->next;
        // } 
        // cout << endl;
        return merge(l,r);
 
    }
    ListNode* sortList(ListNode* head) {
        
        return sortnode(head);
    }
};
```

快速排序   

```cc
class Solution {
  public:
    ListNode *sortList(ListNode *head) {
        return quickSort(head);
    }

    ListNode *quickSort(ListNode *head) {
        if (!head || !head->next) return head;

        // partition之后, head为右半端链表的头节点
        ListNode* leftHead = partition(head);
        ListNode *rightHead = head->next;
        head->next = nullptr; // 注意这里, 必须断链, 从而将左右两段链表切开

        ListNode *left = quickSort(leftHead);
        ListNode *right = quickSort(rightHead);
        return connectTwoSortedList(left, right);
    }

    // 链表划分
    ListNode* partition(ListNode* head) {
        // pivot选择头节点(链表高度有序时, 超时), 优化为选择中间节点
        int pivot = head->val;

        ListNode *leftDummyNode = new ListNode(-1);
        ListNode *rightDummyNode = new ListNode(-1);
        ListNode *leftTail = leftDummyNode;
        ListNode *rightTail = rightDummyNode;

        ListNode *p = head;
        while (p) {
            auto tmp = p->next;
            // 必须是<, 目的是将head放在右半段的头结点位置
            //因为这样第一次这个循环一定会执行else也就是rightTail->next = p;
            if (p->val < pivot) {
                leftTail->next = p;
                leftTail = leftTail->next;
                p->next = nullptr;
            } else {
                rightTail->next = p;
                rightTail = rightTail->next;
                p->next = nullptr;
            }
            p = tmp;
        }

        // 左边都是小于pivot的, 右边都是大于等于pivot的
        leftTail->next = rightDummyNode->next;
        rightTail->next = nullptr;
        return leftDummyNode->next;;
    }

    // 拼接左半部分和右半部分
    ListNode* connectTwoSortedList(ListNode* left, ListNode* right) {
        ListNode *p = left;
        while (p->next) {
            p = p->next;
        }
        p->next = right;
        return left;
    }
};

作者：smd
链接：https://leetcode.cn/problems/sort-list/solutions/2400774/ge-chong-pai-xu-suan-fa-jie-jue-mou-pao-9dwmt/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

合并 K 个升序链表

困难



LRU 缓存

中等

二叉树

## 二叉树

### 二叉树的中序遍历

```c
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root==nullptr) return {};
        vector<int> res;
        res.push_back(root->val);
        vector<int> l = inorderTraversal(root->left);
        vector<int> r = inorderTraversal(root->right);
        cout<< root->val << endl;
        merge(res.begin(),res.end(), l.begin(), l.end(), back_inserter(res));
        merge(res.begin(),res.end(), r.begin(), r.end(), back_inserter(res));
        return res;
    }
};
```

极其错误的写法，

1. 应该用引用vector而不是每次都merge

2. 到叶节点root不是nullptr但是左右vector都是空的

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void midord(TreeNode* root,vector<int>& res) {
        if(root==nullptr) return;
        midord(root->left,res);
        res.push_back(root->val);
        midord(root->right,res);
        return;
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        midord(root,res);
        return res;
    }
};
```



### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

> 
>
> 给定一个二叉树 `root` ，返回其最大深度。
>
> 二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：3
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1,null,2]
> 输出：2
> ```
>
> **提示：**
>
> - 树中节点的数量在 `[0, 104]` 区间内。
> - `-100 <= Node.val <= 100`

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        int res = 0;
        res = max(maxDepth(root->left)+1,maxDepth(root->right)+1);
        return res;
    }
};
```



### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)
>
> ```
> 输入：root = [4,2,7,1,3,6,9]
> 输出：[4,7,2,9,6,3,1]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)
>
> ```
> 输入：root = [2,1,3]
> 输出：[2,3,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：[]
> ```



```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return nullptr;
        cout << root ->val <<endl;
        root->left = invertTree(root->left);
        root->right = invertTree(root->right);
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;
        return root;
    }
};

```

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
>
>  
>
> **示例 1：**
>
> ![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)
>
> ```
> 输入：root = [1,2,2,3,4,4,3]
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)
>
> ```
> 输入：root = [1,2,2,null,3,null,3]
> 输出：false 
> ```
>
> **提示：**
>
> - 树中节点数目在范围 `[1, 1000]` 内
> - `-100 <= Node.val <= 100`

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* retree(TreeNode* root)
    {
        if(root==nullptr) return nullptr;
        retree(root->left);
        retree(root->right);
        TreeNode* temp = root->left;
        root->left  = root->right;
        root->right = temp;
        return root;
    }
    void issame(TreeNode* l,TreeNode* r,bool& f) {
        if(l==nullptr||r==nullptr)
        {
            if((l!=r)) f = false;
            return;
        }
        if(l->val!=r->val){
            f= false;
            return;
        } 
        issame(l->left,r->left,f);
        issame(l->right,r->right,f);
        return;
    }

    bool isSymmetric(TreeNode* root) {
        root->left = retree(root->left); 
        bool res= true;
        issame(root->left,root->right,res);
        return res;
    }
};
//翻转一个子树，然后判断是不是完全一样
```





二叉树的直径

简单



### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[9,20],[15,7]]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1]
> 输出：[[1]]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：[]
> ```

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root==nullptr) return {};
        typedef  pair<TreeNode*,int> PTI;
        queue<PTI> q;
        vector<vector<int >> res;
        vector<int> v;
        int c = 0;
        q.push({root,0});
        while(!q.empty())
        {
            PTI t = q.front();
            if(t.second!=c) {
                res.push_back(v);
                v.clear();
                c++;
            }
            if(t.first->left!=nullptr) q.push({t.first->left,c+1});
            if(t.first->right!=nullptr) q.push({t.first->right,c+1});
            v.push_back(t.first->val);
            q.pop();      
        }
        if(!v.empty()) res.push_back(v);
        return res;

    }
};
```

这题做的很流畅O(∩_∩)O







### 将有序数组转换为二叉搜索树

简单



### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

> 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。
>
> **有效** 二叉搜索树定义如下：
>
> - 节点的左
>
>   子树
>
>   只包含
>
>    小于 
>
>   当前节点的数。
>
> - 节点的右子树只包含 **大于** 当前节点的数。
>
> - 所有左子树和右子树自身必须也是二叉搜索树。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)
>
> ```
> 输入：root = [2,1,3]
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)
>
> ```
> 输入：root = [5,1,4,null,null,3,6]
> 输出：false
> 解释：根节点的值是 5 ，但是右子节点的值是 4 。
> ```

后序

```c
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool BST(TreeNode* root,int &mx,int &mi)
    {
        if(root==nullptr) return true;
       
        int lmx=INT_MIN,lmi=INT_MAX,rmi =INT_MAX,rmx =INT_MIN;
        if(!BST(root->left,lmx,lmi)) return false;
        if(!BST(root->right,rmx,rmi)) return false;
       

        if(lmx!=INT_MIN&&root->val<=lmx) return false;
        if(rmi!=INT_MAX&&root->val>=rmi) return false;
        if(rmi==INT_MAX&&root->val==INT_MAX&&root->right!=nullptr) return false;
        if(lmx==INT_MIN&&root->val==INT_MIN&&root->left!=nullptr) return false;

        
        mx =max(rmx,root->val);
        mi =min(lmi,root->val);
        //cout << root->val << mx << mi  <<lmx << rmi << endl;
        return true;
    }
    bool isValidBST(TreeNode* root) {
        int mx, mi;
        if(root->left==nullptr&&root->right==nullptr) return true;
        return BST(root,mx,mi);
    }
};
```

前序

```c
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/validate-binary-search-tree/solutions/230256/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

> 给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)
>
> ```
> 输入：root = [3,1,4,null,2], k = 1
> 输出：1
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)
>
> ```
> 输入：root = [5,3,6,2,4,null,null,1], k = 3
> 输出：3
> ```
>
>  
>
>  
>
> **提示：**
>
> - 树中的节点数为 `n` 。
> - `1 <= k <= n <= 104`
> - `0 <= Node.val <= 104`

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        
        priority_queue<int,vector<int>,greater<int>> q;
        function<void(TreeNode* r)> dfs = [&](TreeNode* r)
        {
            if(r==nullptr) return;
            q.push(r->val);
            dfs(r->left);
            dfs(r->right);
            return;
        };
        dfs(root);
        k--;
        while(!q.empty()&&k--)
        {
            //cout << q.top()<<endl;
            q.pop();
        }
        return q.top();
    }
};
```

### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
>  
>
> **示例 1:**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)
>
> ```
> 输入: [1,2,3,null,5,null,4]
> 输出: [1,3,4]
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,null,3]
> 输出: [1,3]
> ```
>
> **示例 3:**
>
> ```
> 输入: []
> 输出: []
> ```

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //感觉是bfs的感觉
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
       
        vector<int> res;
        if(root ==nullptr) return {};
        res.push_back(root->val);
        queue<TreeNode*> q;
        q.push(root);
        int size = q.size();
        while(!q.empty())
        {
            size--;
            TreeNode* point = q.front();
            q.pop();
            if(point->left!=nullptr) q.push(point->left);
            if(point->right!=nullptr) q.push(point->right);
            if(size==0)
            {
                size=q.size();
                if(size==0) break;
                res.push_back(q.back()->val);
            }
        }
        return res;
    }
};
```

### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool dfs(TreeNode* root,TreeNode* res)
    {
       
        if(root==nullptr) return false; 
        
        TreeNode* ne = res;
        if(root->left!= nullptr)
        {
            ne->right = new TreeNode(root->left->val);
            if(dfs(root->left,ne->right)) ne = ne->right;//!!!严重的错误，因为其实ne可能已经不是ne->right了而是ne->right->right->right->right.....
        } 
        if(root->right!= nullptr)
        {
            ne->right = new TreeNode(root->right->val);
            dfs(root->right,ne->right);
        } 
        return true;
    }
    void flatten(TreeNode* root) {
        if(root==nullptr) return;
        TreeNode* res  = new TreeNode(root->val);
        dfs(root,res);
        root->left = res->left;
        root->right = res->right;
        return;
    }
};
```

所以下探后的节点需要返回的

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* dfs(TreeNode* root,TreeNode* res)
    {
       
        if(root==nullptr) return res; 
        
        TreeNode* ne = res;
        if(root->left!= nullptr)
        {
            ne->right = new TreeNode(root->left->val);
            ne = ne->right;
            ne = dfs(root->left,ne);
        } 
        if(root->right!= nullptr)
        {
            ne->right = new TreeNode(root->right->val);
            ne = ne->right;
            ne =dfs(root->right,ne);
        } 
        return ne;
    }
    void flatten(TreeNode* root) {
        if(root==nullptr) return;
        TreeNode* res  = new TreeNode(root->val);
        dfs(root,res);
        root->left = res->left;
        root->right = res->right;
        return;
    }
};
```



<img src="/home/wangkai/codenotes_ubuntu/Leecode/img/image-20240401171129132.png" alt="image-20240401171129132" style="zoom:50%;" />

更好的方法应该是在原树操作，用左节点修改右节点这样就不会new的耗时了

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)==难==

一开始以为中序遍历的索引的差值是子树的节点的个数，结果发现不是

错的：

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
//中序的索引差值决定这个树一共有多少个节点
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int,int> hash;
        int N =preorder.size();
        if(N==0) return nullptr;
        for(int i=0;i<N;i++)
        {
            hash[inorder[i]] = i;
        }
        TreeNode * res = new TreeNode(preorder[0]);
        int c=0;
        int s = N;
        function<void(TreeNode *,int,int)> dfs = [&](TreeNode * root,int size,int cnt)
        {
            cout <<root->val << size << cnt << endl;
            if(size<=1) return;
            int num = preorder[cnt];
            int nnum = preorder[cnt+1];
            int dis = hash[nnum] - hash[num];
            if(dis<0)
            {
                root->left = new TreeNode(nnum);
                dfs(root->left,-dis,cnt+1);
            }
            dis = min(dis,0);
            if(size+dis-1>0)
            {
                nnum = preorder[cnt+1-dis];
                root->right = new TreeNode(nnum);
                dfs(root->right,size+dis-1,cnt+1-dis);
            }

            return;
        };
        dfs(res,s,c);
        return res;
    }
};
```

<img src="/home/wangkai/codenotes_ubuntu/Leecode/img/image-20240401200037444.png" alt="image-20240401200037444" style="zoom:50%;" />

答案：

![image-20240401200519272](/home/wangkai/codenotes_ubuntu/Leecode/img/image-20240401200519272.png)

```c
class Solution {
private:
    unordered_map<int, int> index;

public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return nullptr;
        }
        
        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = index[preorder[preorder_root]];
        
        // 先把根节点建立出来
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // 构造哈希映射，帮助我们快速定位根节点
        for (int i = 0; i < n; ++i) {
            index[inorder[i]] = i;
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

> 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。
>
> **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)
>
> ```
> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
> 输出：3
> 解释：和等于 8 的路径有 3 条，如图所示。
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
> 输出：3
> ```
>
>  
>
> **提示:**
>
> - 二叉树的节点个数的范围是 `[0,1000]`
> - `-109 <= Node.val <= 109` 
> - `-1000 <= targetSum <= 1000` 

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public: 
    int target;
    void dfs(TreeNode*root,vector<int> q,long sum,int& res)
    {
        if(root==nullptr)
        {
           
            return ;
        } 

        sum= long(sum + root->val);

        for(int i=0;i<q.size();i++)
        {
            if(sum - q[i]==target)
            {
                res++;
                // for(auto x:q) cout << x << " ";
                // cout <<endl;
            }
        }
        q.push_back(sum);

        dfs(root->left,q,sum,res);
        dfs(root->right,q,sum,res);
        return;
    }

    int pathSum(TreeNode* root, int targetSum) {
        target =targetSum;
        long sum=0;
        int res=0;
        vector<int> q;
        q.push_back(0);
        dfs(root,q,sum,res);
        return res;
    }
};
//queue加前缀和？
```



二叉树的最近公共祖先

中等



二叉树中的最大路径和

## 图论

### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

> 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>
>  
>
> **示例 1：**
>
> ```
> 输入：grid = [
>   ["1","1","1","1","0"],
>   ["1","1","0","1","0"],
>   ["1","1","0","0","0"],
>   ["0","0","0","0","0"]
> ]
> 输出：1
> ```
>
> **示例 2：**
>
> ```
> 输入：grid = [
>   ["1","1","0","0","0"],
>   ["1","1","0","0","0"],
>   ["0","0","1","0","0"],
>   ["0","0","0","1","1"]
> ]
> 输出：3
> ```
>
>  
>
> **提示：**
>
> - `m == grid.length`
> - `n == grid[i].length`
> - `1 <= m, n <= 300`
> - `grid[i][j]` 的值为 `'0'` 或 `'1'`

```c
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int cnt=0,m = grid.size(),n = grid[0].size();
        bool f[m][n];
        memset(f,0,sizeof f);
        typedef pair<int,int> PII;
        vector<PII> dir = {{0,1},{1,0},{-1,0},{0,-1}};
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                queue<PII> q;
                if(grid[i][j]=='1'&&!f[i][j]) 
                {
                    //cout << i << j <<endl;
                    cnt++;
                    q.push({i,j});
                    f[i][j]=true;
                    while(!q.empty())
                    {
                        PII set = q.front();
                        q.pop();
                        //cout << "set" << set.first << set.second << endl;
                        for(auto d:dir)
                        {
                            PII t = {set.first+d.first,set.second+d.second};
                           
                            if(t.first>=0&&t.first<m&&t.second>=0&&t.second<n)
                            {
                                //cout << "t" << t.first << t.second << grid[t.first][t.second] << f[t.first][t.second] << endl;
                                if(f[t.first][t.second]==false&&grid[t.first][t.second]=='1')
                                {
                                    //cout << "push"<<  t.first << t.second <<endl;
                                    q.push(t);
                                    f[t.first][t.second]=true;
                                }
                               
                            }  
                        
                        }
                    } 
                }
            }
        }
        return cnt;
    }
};
```

### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

> 在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：
>
> - 值 `0` 代表空单元格；
> - 值 `1` 代表新鲜橘子；
> - 值 `2` 代表腐烂的橘子。
>
> 每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。
>
> 返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。
>
>  
>
> **示例 1：**
>
> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)**
>
> ```
> 输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
> 输出：4
> ```
>
> **示例 2：**
>
> ```
> 输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
> 输出：-1
> 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。
> ```
>
> **示例 3：**
>
> ```
> 输入：grid = [[0,2]]
> 输出：0
> 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
> ```

```c
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        typedef pair<int,int> PII;
        vector<PII> dir = {{1,0},{-1,0},{0,1},{0,-1}};
        int m = grid.size(),n = grid[0].size(),size=0,cnt=0,res=0;
        queue<PII> q;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==2) q.push({i,j});
                if(grid[i][j]==1) cnt++;
            }
        }
        if(cnt==0) return 0;
        size = q.size();
        while(!q.empty())
        {
            size--;
            int x = q.front().first, y = q.front().second;
            q.pop();
            //cout << x << y << endl;
            for(auto d:dir)
            {
                int px =x+ d.first, py=y +d.second;
                if(px>=0&&px<m&&py>=0&&py<n&&grid[px][py]==1) 
                {
                    grid[px][py]=2;
                    cnt --;
                    //cout << px << py <<grid[px][py] << endl;
                    q.push({px,py});
                }
            }
            if(size==0)
            {
                size = q.size();
                res++;
            } 
        }
        //cout<< cnt << endl;
        if(cnt==0) return res-1;
        return -1;
    }
};
```

### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

> 你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。
>
> 在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。
>
> - 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
>
> 请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：true
> 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
> ```
>
> **示例 2：**
>
> ```
> 输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
> 输出：false
> 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
> ```
>
>  
>
> **提示：**
>
> - `1 <= numCourses <= 2000`
> - `0 <= prerequisites.length <= 5000`
> - `prerequisites[i].length == 2`
> - `0 <= ai, bi < numCourses`
> - `prerequisites[i]` 中的所有课程对 **互不相同**

```c
class Solution {
public:
    int h[2001],e[5001],ne[5001],in[2001],idx = 0;//起始像是模拟了链表
    void addd(int a,int b)
    {
        e[idx] = b;ne[idx] = h[a];h[a] = idx++;
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        queue<int> q;
        memset(h,-1,sizeof h);
        int n = numCourses,m = prerequisites.size(),cnt=0;
        for(auto v : prerequisites)
        {
            addd(v[1],v[0]);
            in[v[0]]++;
        }
       for(int i=0;i<n;i++)
        {
            if(!in[i])
            {
                q.push(i);
            }
        }
        while(!q.empty())
        {
            int t = q.front();
            //cout << t <<endl;
            q.pop();
            
            for(int i = h[t];i!=-1;i=ne[i])
            {
                int j = e[i];
                in[j]--;
                if(in[j]==0) q.push(j);
            }
            cnt ++;
        }
        return n==cnt;
    }
};
```

实现 Trie (前缀树)

中等



## 回溯

### 全排列

> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1]
> 输出：[[0,1],[1,0]]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1]
> 输出：[[1]]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 6`
> - `-10 <= nums[i] <= 10`
> - `nums` 中的所有整数 **互不相同**

```c
class Solution {
public:
   

    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> res;
        vector<int> as;
        vector<bool> flag(n,false);

        function<void(vector<int>&,vector<bool>&,vector<vector<int>> &)> mysort = [&](vector<int>& as, vector<bool>& flag ,vector<vector<int>> & res)
        {
            bool f=false;
            for(int i=0;i<flag.size();i++)
            {
                if(!flag[i])
                {
                    f = true;
                    flag[i] =true;
                    as.push_back(nums[i]);
                    mysort(as,flag,res);
                    as.pop_back();
                    flag[i] =false;
                }
            }
            if(!f) res.push_back(as);
            return;
        };

        mysort(as,flag,res);
        return res;
    }
};
```



### [78. 子集](https://leetcode.cn/problems/subsets/)

> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0]
> 输出：[[],[0]]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 10`
> - `-10 <= nums[i] <= 10`
> - `nums` 中的所有元素 **互不相同**

```c
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> vec;
        int n = nums.size();
        vector<bool> flag(n,false);
        
        function<void(vector<int>&,vector<bool>&)> dfs = [&](vector<int>& v,vector<bool>& f) ->void
        {
            for(int i=0;i<n;i++)
            {
                if(!f[i])
                {
                    f[i] = true;
                    v.push_back(nums[i]);
                    res.push_back(vec);
                    dfs(v,f);
                    v.pop_back();
                    f[i] = false;
                }
            }
            return;
        };
        dfs(vec,flag);
        return res;
    }
};

输入
nums =
[1,2,3]
输出
[[1],[1,2],[1,2,3],[1,3],[1,3,2],[2],[2,1],[2,1,3],[2,3],[2,3,1],[3],[3,1],[3,1,2],[3,2],[3,2,1]]
预期结果
[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

这题一开始用flag作为mask没做出来，会重复

```c
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> vec;
        int n = nums.size();
        int c=0;
        
        function<void(vector<int>&,int)> dfs = [&](vector<int>& v,int cnt) ->void
        {
  
            if(cnt==n) {
            res.push_back(v);
            return;
            }
            v.push_back(nums[cnt]);
            dfs(v,cnt+1);
            v.pop_back();
            dfs(v,cnt+1);
    
            return;
        };

        dfs(vec,c);
        return res;
    }
};
```



### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)
>
>  
>
> **示例 1：**
>
> ```
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```
>
> **示例 2：**
>
> ```
> 输入：digits = ""
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：digits = "2"
> 输出：["a","b","c"]
> ```

```c
class Solution {
public:
   

    vector<string> letterCombinations(string digits) {
        string s[10] = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        vector<string> res;
        if(digits.size()==0) return {};
        function<void(string,vector<string> &,int)> dfs = [&](string f,vector<string> & res,int idx)
        {
            int dig = digits[idx]-'0';
            //cout << dig <<endl;
            if(f.size()==digits.size()) res.push_back(f);
            else
            {
                
                for(auto c:s[dig])
                {
                    f.push_back(c);
                    idx++;
                    cout << f <<endl;
                    dfs(f,res,idx);
                    f.pop_back();
                    idx--;
                }   

            }  
            return;
        };
        string f;
        dfs(f,res,0);
        return res;
    }
};
```

### [组合总和](https://leetcode.cn/problems/combination-sum/)

> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。
>
>  
>
> **示例 1：**
>
> ```
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
> 7 也是一个候选， 7 = 7 。
> 仅有这两种组合。
> ```
>
> **示例 2：**
>
> ```
> 输入: candidates = [2,3,5], target = 8
> 输出: [[2,2,2,2],[2,3,3],[3,5]]
> ```
>
> **示例 3：**
>
> ```
> 输入: candidates = [2], target = 1
> 输出: []
> ```
>
>  

```c
class Solution {
public:
    void dfs(vector<vector<int>> &res,vector<int> candidates,vector<int>& nums,int sum,int target,int idx)
    {
        if(sum>target) return;
        if(sum==target)
        {
            res.push_back(nums);
            return;
        }
        for(int i=idx;i<candidates.size();i++) 
        {
            sum+=candidates[i];
            nums.push_back(candidates[i]);
            dfs(res,candidates,nums,sum,target,i);
            sum-=candidates[i];
            nums.pop_back();
        }
        return;
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int>nums;
        int sum=0;
        dfs(res,candidates,nums,sum,target,0);
        return res;
    }
};
```

### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 3
> 输出：["((()))","(()())","(())()","()(())","()()()"]
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：["()"]
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 8`

```c
class Solution {
public:
    void dfs(vector<string>& res,string s,int l,int r)
    {
        int tl=l;
        if(l==0&&r==0) 
        {
            res.push_back(s);
            return;
        }
        if(tl--)
        {
            s.push_back('(');
            dfs(res,s,tl,r);
            s.pop_back();
        }
        if(r>l)
        {
            r--;
            s.push_back(')');
            dfs(res,s,l,r);
            s.pop_back();
        }
        cout << s <<endl;
        return;
    }
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        string s = "";
        dfs(res,s,n,n);
        return res;
    }
};
```



### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

> 给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)
>
> ```
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)
>
> ```
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
> 输出：true
> ```
>
> **示例 3：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)
>
> ```
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
> 输出：false
> ```

```c
class Solution {
public:
    
    vector<pair<int,int>> dir = {{0,1},{0,-1},{1,0},{-1,0}};
   

    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(),n = board[0].size();
        bool  f[m][n];
        
        function<bool (int,int,int)> dfs = [&](int x,int y,int len)
        {
            if(len==word.size()) return true;
            for(auto d:dir)
            {
                int xx= x + d.first,yy= y + d.second;
                if(xx>=0&&xx<m&&yy>=0&&yy<n&&!f[xx][yy]&&word[len]==board[xx][yy])
                {   
                    f[xx][yy] = true; 
                    len++;
                    if(dfs(xx,yy,len)) return true;
                    f[xx][yy] = false; 
                    len--;
                }
            } 
            return false ;
        };

        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                memset(f,0,sizeof f);
                f[i][j] =true;
                if(word[0]==board[i][j]) 
                {
                    if(dfs(i,j,1)) return true;
                }
            }
        }
       
        return false;


    }
};
```



分割回文串

中等



N 皇后

困难

## 二分查找



### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```
>
> **示例 3:**
>
> ```
> 输入: nums = [1,3,5,6], target = 7
> 输出: 4
> ```
>
>  
>
> **提示:**
>
> - `1 <= nums.length <= 104`
> - `-104 <= nums[i] <= 104`
> - `nums` 为 **无重复元素** 的 **升序** 排列数组
> - `-104 <= target <= 104`

```c
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0,r = nums.size()-1,mid;
        if(nums.back()<target) return nums.size();
        while(l<r)
        {
            mid = (l+ r)>>1;
            //cout << l << r << mid <<endl;
            if(nums[mid]>=target) r = mid;
            else l = mid+1;
        }
        return r;
    }
};
```



### [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

> 给你一个满足下述两条属性的 `m x n` 整数矩阵：
>
> - 每行中的整数从左到右按非严格递增顺序排列。
> - 每行的第一个整数大于前一行的最后一个整数。
>
> 给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)
>
> ```
> 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)



```c
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m=matrix.size(),n = matrix[0].size(),l=0,r=m-1,mid;
        while(l<r)
        {
            mid = (l+r+1)>>1;
            if(matrix[mid][0]<=target) l = mid;
            else r = mid -1;
        } 

        int row = l;
        l = 0;
        r = n-1;
        while(l<r)
        {
            mid = (l+r+1)>>1;
            if(matrix[row][mid]<=target) l = mid;
            else r = mid -1;
        } 
        cout <<  row << l << matrix[row][l]; 
        if(matrix[row][l]==target)return true;
        return false;
    }
};
```



### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

> 给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 `target`，返回 `[-1, -1]`。
>
> 你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [5,7,7,8,8,10], target = 8
> 输出：[3,4]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [5,7,7,8,8,10], target = 6
> 输出：[-1,-1]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [], target = 0
> 输出：[-1,-1]
> ```
>
>  

```c
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        if(n==0) return {-1,-1};
        if(nums[0]>target) return {-1,-1};
        if(nums[n-1]<target) return {-1,-1};
        int l = 0,r = n-1,mid;
        while(l<r)
        {
            mid = (l+r+1)>>1;
            if(nums[mid]<=target) l = mid; 
            else r = mid - 1;
        }
        int res1 = l;
        l = 0;
        r = n-1;
        while(l<r)
        {
            mid = (l+r)>>1;
            if(nums[mid]>=target) r = mid; 
            else l = mid + 1;
        }
        int res2 = r;
        if(res2>res1) return {-1,-1};
        return {res2,res1};
    }
};
```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

> 整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。
>
> 在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。
>
> 给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 3
> 输出：-1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1], target = 0
> 输出：-1
> ```

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        //先找到旋转点
        
        int l =0, n = nums.size(), r = n-1,mid;
        if(n==1)
        {
            if(nums[0]!=target) return -1;
            return 0;
        }
        if(nums[0]>nums[n-1])
        {
            while(l<r)
            {
                mid = (l+r+1)>>1;
                if(nums[mid]>nums[l])  l = mid;
                else r = mid-1;
            }
            int idx = l;
            cout << idx <<endl;
            if(target>=nums[0])   l =0,  r = idx;
            else   l =idx+1,  r = n-1;
        }
       
        while(l<r)
        {
            mid = (l+r+1)>>1;
            if(nums[mid]<=target)  l = mid;
            else r = mid-1;
        }
        if(nums[l]!=target) return -1;
        return l;
    }
};
```

寻找旋转排序数组中的最小值

中等



寻找两个正序数组的中位数

困难

## 栈



### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。
>
> 有效字符串需满足：
>
> 1. 左括号必须用相同类型的右括号闭合。
> 2. 左括号必须以正确的顺序闭合。
> 3. 每个右括号都有一个对应的相同类型的左括号。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "()"
> 输出：true
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "()[]{}"
> 输出：true
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "(]"
> 输出：false
> ```

```c
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        map<char,int> l = {
            {'(',1}, {')',-1}, {'[',2}, {']',-2}, {'{',3}, {'}',-3}
        };
        for(auto c:s)
        {
            if(st.size()!=0&&l[st.top()]+l[c]==0&&l[st.top()]>0) st.pop();
            else st.push(c);
            //cout << st.size() << endl;
        }
        if(st.size()==0) return true;
        return false;
    }
};
```

### [155. 最小栈](https://leetcode.cn/problems/min-stack/)

> 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。
>
> 实现 `MinStack` 类:
>
> - `MinStack()` 初始化堆栈对象。
> - `void push(int val)` 将元素val推入堆栈。
> - `void pop()` 删除堆栈顶部的元素。
> - `int top()` 获取堆栈顶部的元素。
> - `int getMin()` 获取堆栈中的最小元素。
>
>  
>
> **示例 1:**
>
> ```
> 输入：
> ["MinStack","push","push","push","getMin","pop","top","getMin"]
> [[],[-2],[0],[-3],[],[],[],[]]
> 
> 输出：
> [null,null,null,null,-3,null,0,-2]
> 
> 解释：
> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.getMin();   --> 返回 -3.
> minStack.pop();
> minStack.top();      --> 返回 0.
> minStack.getMin();   --> 返回 -2.
> ```

```c
class MinStack {
public:
    vector<pair<int,int>> idx;
    stack<int> st;
    MinStack() {
        
    }
    
    void push(int val) {
        cout<< "push" << val <<endl;
        this->st.push(val);

        if(this->idx.empty()|| val<this->idx.back().first)  idx.push_back({val,this->st.size()});
        return;
    }
    
    void pop() {
        cout<< "pop" <<endl;
        this->st.pop();
        if(this->st.size()<this->idx.back().second) this->idx.pop_back();
    }
    
    int top() {
        cout<< "top" <<endl;
        return this->st.top();
    }
    
    int getMin() {
         cout<< "getMin" <<endl;
        return this->idx.back().first;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```



### [394. 字符串解码](https://leetcode.cn/problems/decode-string/) ==难==

> 这题夸张在 找到一个右括号后，一直出栈到左括号，并且用isdigit和stoi(stk.back());解码计算获得的字符串==然后再次放入栈里==

> 给定一个经过编码的字符串，返回它解码后的字符串。
>
> 编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。
>
> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
>
> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "3[a]2[bc]"
> 输出："aaabcbc"
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "3[a2[c]]"
> 输出："accaccacc"
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "2[abc]3[cd]ef"
> 输出："abcabccdcdcdef"
> ```
>
> **示例 4：**
>
> ```
> 输入：s = "abc3[cd]xyz"
> 输出："abccdcdcdxyz"
> ```



官方栈解

```c
class Solution {
public:
    string getDigits(string &s, size_t &ptr) {
        string ret = "";
        while (isdigit(s[ptr])) {
            ret.push_back(s[ptr++]);
        }
        return ret;
    }

    string getString(vector <string> &v) {
        string ret;
        for (const auto &s: v) {
            ret += s;
        }
        return ret;
    }

    string decodeString(string s) {
        vector <string> stk;
        size_t ptr = 0;

        while (ptr < s.size()) {
            char cur = s[ptr];
            if (isdigit(cur)) {
                // 获取一个数字并进栈
                string digits = getDigits(s, ptr);
                stk.push_back(digits);
            } else if (isalpha(cur) || cur == '[') {
                // 获取一个字母并进栈
                stk.push_back(string(1, s[ptr++])); 
            } else {
                ++ptr;
                vector <string> sub;
                while (stk.back() != "[") {
                    sub.push_back(stk.back());
                    stk.pop_back();
                }
                reverse(sub.begin(), sub.end());
                // 左括号出栈
                stk.pop_back();
                // 此时栈顶为当前 sub 对应的字符串应该出现的次数
                int repTime = stoi(stk.back()); 
                stk.pop_back();
                string t, o = getString(sub);
                // 构造字符串
                while (repTime--) t += o; 
                // 将构造好的字符串入栈
                stk.push_back(t);
            }
        }

        return getString(stk);
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/decode-string/solutions/264391/zi-fu-chuan-jie-ma-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

自己递归解

```c
class Solution {
public:

    int  getdigits(string s,int i)
    {
        string res="";
        i--;
        while(i>=0&&isdigit(s[i]))
        {
            res.push_back(s[i]);
            reverse(res.begin(),res.end());
            i--;
        }
        return stoi(res);
    }

    string decodeString(string s) {
        string res = "";
        unordered_map<int,int> hash;
        stack<int> st;
        int n = s.size();
        for(int i =0;i<s.size();i++)
        {
            if(s[i]=='[') st.push(i);
            else if(s[i]==']')
            {
                hash[st.top()] = i;
                st.pop();
            } 
        }
        //for(auto [k,v]:hash) cout << k <<v<<endl;

        function <string(int,int,int)> func = [&](int start,int end,int cnt)
        {

            string r = "";
            
            for(int i=start;i<=end;i++)
            {
                if(hash[i]!=0)  
                {
                    int cnt = getdigits(s,i);
                    string add = func(i+1,hash[i]-1,cnt);
                    r +=add;
                    i = hash[i];
                }   
                else if(isalpha(s[i])) r +=s[i];
            }
            
            string add = r;
            while(--cnt)
            {
                r +=add;
            }

            return r;

        };
        res = func(0,n-1,1);
        return res;
    }
};
```



### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

> 给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。
>
>  
>
> **示例 1:**
>
> ```
> 输入: temperatures = [73,74,75,71,69,72,76,73]
> 输出: [1,1,4,2,1,1,0,0]
> ```
>
> **示例 2:**
>
> ```
> 输入: temperatures = [30,40,50,60]
> 输出: [1,1,1,0]
> ```
>
> **示例 3:**
>
> ```
> 输入: temperatures = [30,60,90]
> 输出: [1,1,0]
> ```
>
>  
>
> **提示：**
>
> - `1 <= temperatures.length <= 105`
> - `30 <= temperatures[i] <= 100`

```c
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        stack<int> st;
        vector<int>  res = vector<int> (n,0);
        for(int i=0;i<n;i++)
        {
            //cout << i <<endl;
            
            int cnt = 0;
            while(!st.empty())
            {
                if(temperatures[st.top()]>=temperatures[i]) break;
                res[st.top()] = i - st.top();
                st.pop();
            }
            
            st.push(i);
        }
        return res;
    }
};
```

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

> 给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
>
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。
>
>  
>
> **示例 1:**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)
>
> ```
> 输入：heights = [2,1,5,6,2,3]
> 输出：10
> 解释：最大的矩形为图中红色区域，面积为 10
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)
>
> ```
> 输入： heights = [2,4]
> 输出： 4
> ```
>
>  
>
> **提示：**
>
> - `1 <= heights.length <=105`
> - `0 <= heights[i] <= 104`

```c
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> st;
        
        int n = heights.size();
        int l[n],r[n];
        for(int i=0;i<n;i++)
        {
            while(!st.empty()&&heights[st.top()]>=heights[i]) st.pop();
            if(st.empty()) l[i] = -1;
            else l[i] = st.top();
            st.push(i);
        }
        //for(auto x:l) cout << x << endl;
        st = stack<int> ();

        for(int i=n-1;i>=0;i--)
        {
            while(!st.empty()&&heights[st.top()]>=heights[i]) st.pop();
            if(st.empty()) r[i] = n;
            else r[i] = st.top();
            st.push(i);
        }
        //for(auto x:r) cout << x << endl;
        int res=0;
        for(int i=0;i<n;i++)
        {
            res = max(res,heights[i]*(r[i]-l[i]-1));
            //cout << r[i] << " " << l[i] << endl;
        }
        return res;
    }
};
```



## 堆

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

 

示例 1:

输入: [3,2,1,5,6,4], k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
 

提示：

1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104
```

```c
class Solution {
public:
    void bigfy(vector<int>& a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a[i], a[largest]);
            bigfy(a, largest, heapSize);
        }
    }


    void buildbig(vector<int>& nums)
    {
        for(int i=nums.size()/2-1;i>=0;i--)
        {
            bigfy(nums,i,nums.size());
        }
        return;
    }
    int findKthLargest(vector<int>& nums, int k) {
        int n =nums.size();
        buildbig(nums);
      
        while(--k)
        {
            //for(auto x:nums) cout << x;
            // cout <<endl;
            int temp = nums.back();
            nums.pop_back();
            nums[0] = temp;
            bigfy(nums, 0, nums.size());
        }
        return nums[0];
    }
};
```



### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [1,1,1,2,2,3], k = 2
> 输出: [1,2]
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [1], k = 1
> 输出: [1]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
> - 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的
>
>  
>
> **进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

快排

```c
class Solution {
public:
    void qsort(vector<pair<int, int>> & values, int l ,int r,int  k)
    {
        if(r<=l) return; 
        int target =  values[(l+r)>>1].second;
        int i = l - 1, j = r + 1;
        while(i<j)
        {
            do ++i; while(values[i].second>target);
            do --j; while(values[j].second<target);
            if(i<j) swap(values[i],values[j]);
            //cout << i << j << target <<endl;
        }
        
        if(j>=k) qsort(values, l, j, k);
        else  qsort(values, j+1, r, k);
        return;
    }
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 获取每个数字出现次数
        unordered_map<int, int> occurrences;
        for (auto& v: nums) {
            occurrences[v]++;
        }

        vector<pair<int, int>> values;
        for (auto& kv: occurrences) {
            values.push_back(kv);
        }
        vector<int> ret;

        // for (auto& [k,v]: values) {
        //     cout << k << v <<endl;
        // }
        qsort(values, 0, values.size() - 1, k);

        // for (auto& [k,v]: values) {
        //     cout << k << v <<endl;
        // }

        for(int i=0;i<k;i++)
        {
            
            ret.push_back(values[i].first);
        } 
        return ret;
    }
};
```

堆排

```c
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> hash;
        int n = nums.size();
        for(int i=0;i<n;i++)
        {
            hash[nums[i]]++;
        } 
        priority_queue<pair<int,int>> q;
        for(auto [k,v] :hash)
        {
            q.push({v,k});
        }
        vector<int>  res;
        while(k--)
        {
            res.push_back(q.top().second);
            q.pop();
        }
        //cout << q.top().first << q.top().second <<endl;
        return res;
    }
};
```

数据流的中位数

困难

## 贪心算法

### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

> 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。
>
> 你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
> ```
>
>  

```c
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0,l=0,r;
        for(int i=1;i<prices.size();i++)
        {
            if(prices[i]<prices[l]) l = i;
            res = max(prices[i]- prices[l],res);
        }
        return res;
    }
};
```

### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

> 给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,3,1,1,4]
> 输出：true
> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,2,1,0,4]
> 输出：false
> 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
> ```

```c
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int mx=0,set=0;
        while(set<=mx&&set<nums.size())
        {
            mx = max(set + nums[set],mx);
            set++;
        }
        if(mx >=nums.size()-1)  return true;
        return false;
    }
};
```

### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。
>
> 每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:
>
> - `0 <= j <= nums[i]` 
> - `i + j < n`
>
> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [2,3,0,1,4]
> 输出: 2
> ```
>
>  
>
> **提示:**
>
> - `1 <= nums.length <= 104`
> - `0 <= nums[i] <= 1000`
> - 题目保证可以到达 `nums[n-1]`

```c
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size(), max=0;
        int f[n];
        memset(f,0x3f,sizeof f);
        f[0] = 0;
        for(int i=0;i<n;i++)
        {
            int len = nums[i];
            for(int j=max;j<=i+len;j++)
            {
                if(j>=n) return f[n-1];
                f[j] = min(f[j],f[i]+1);
            }
            max = i+len;
        }
        return f[n-1];
    }
};
```

划分字母区间

中等

## 动态规划

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：2
> 解释：有两种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶
> 2. 2 阶
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 3
> 输出：3
> 解释：有三种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶
> ```

```c
class Solution {
public:
    int climbStairs(int n) {
        
        int f[n+1];
        memset(f,0,sizeof f);
        if(n==1) return 1;
        f[1] =1;
        f[0] =1;
        for(int i=2;i<=n;i++)
        {
            f[i] = f[i-1] + f[i-2];
        }
        return f[n];
    }
};
```



### [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

> 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
>  
>
> **示例 1:**
>
> ```
> 输入: numRows = 5
> 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
> ```
>
> **示例 2:**
>
> ```
> 输入: numRows = 1
> 输出: [[1]]
> ```
>
>  
>
> **提示:**
>
> - `1 <= numRows <= 30`

```c
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        int n = numRows;
        vector<vector<int>> res;
        vector<int> r; 
        r.push_back(1);
        res.push_back(r);
        if(numRows==1) return res;
        r.push_back(1);
        res.push_back(r);
        if(numRows==2) return res;
        for(int i=2;i<n;i++)
        {
            for(int j=i-1;j>=1;j--)
            {
                r[j] = r[j-1] + r[j];
            }
            r.push_back(1);
            res.push_back(r);
        }
        return res;
    }
};
```



### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。
>
>  
>
> **示例 1：**
>
> ```
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```
>
> **示例 2：**
>
> ```
> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 100`

```c
class Solution {
public:
    int rob(vector<int>& nums) {
        const int n = nums.size();
        int f[n][2];
        memset(f,0,sizeof f);
        f[0][0] = 0;
        f[0][1] = nums[0];
        for(int i=1;i<nums.size();i++)
        {
            f[i][0] = max(f[i-1][1],f[i-1][0]);
            f[i][1] = f[i-1][0] + nums[i];  
        }
        return  max(f[n-1][1],f[n-1][0]);
    }
};
```



### 完全平方数

```c
class Solution {
public:
    bool is_q(int a)
    {
        int x =1;
        int m = x*x;
        while(m<a)
        {
           x++;
           m = x*x;
        }
        if(m==a) return true;
        return false;
    }

    int numSquares(int n) {
        unordered_map<int,int> ha;
        function<int(int)> myfun = [&](int x){
            int res = 1e5;
            if(ha[x]!=0) return ha[x];
            if(is_q(x))
            {
                ha[x] = 1;
                return 1;
            } 
            for(int i=1;i<x/2+1;i++)
            {
                int a,b;
                a = myfun(i);
                ha[i] = a;
                b = myfun(x-i);
                ha[x-i] = b;
                int t = a + b;
                res = min(t,res);
            }
            ha[x] = res;
            return res;
        };
        return myfun(n);

       
    }
};
```

↑ 递归超时了

↓  ==f[i] = f[i - j*j] + 1;==      改进后的递归

```c
class Solution {
public:

    int numSquares(int n) {
        unordered_map<int,int> ha;
        function<int(int)> myfun = [&](int x){
            int res = 1e5;
            if(x<=2) return x;
            if(ha[x]!=0) return ha[x];
            for(int i=1;i*i<=x;i++)
            {
                res = min(myfun(x-i*i) + 1,res);
            }
            ha[x] = res;
            //cout << x << " " << res << endl;
            return res;
        };
        return myfun(n);

       
    }
};
```



> [<img src="https://assets.leetcode.cn/aliyun-lc-upload/users/xiao-wei-w1/avatar_1602389848.png" alt="img" style="zoom:25%;" />](https://leetcode.cn/u/hust_wei/)[不上guardian不改名](https://leetcode.cn/u/hust_wei/)
>
> 发布于 湖北(编辑过)
>
> 2023.05.23
>
> 完全背包问题，所有的完全平方数是可选的物品。
>
> ```java
> class Solution {
>     public int numSquares(int n) {
>         List<Integer> nums = new ArrayList();
>         for (int i = 1; i * i <= n; ++i) nums.add(i * i);   // 把可选的物品算出来
>         int[] dp = new int[n + 1];
>         Arrays.fill(dp, n + 1);
>         dp[0] = 0;
>         for (int i = 0; i < nums.size(); ++i) {
>             for (int j = nums.get(i); j < n + 1; ++j) {
>                 dp[j] = Math.min(dp[j], dp[j - nums.get(i)] + 1);
>             }
>         }
>         return dp[n];
>     }
> }
> ```
>
> 和官解的区别在于，它是外层是容量的循环，我的是外层是物品的循环。对于完全背包问题来说这两种循环方式都是可以的。
>
> ```java
> class Solution {
>     public int numSquares(int n) {
>         int[] dp = new int[n + 1];
>         Arrays.fill(dp, n + 1);
>         dp[0] = 0;
>         for (int i = 1; i <= n; ++i) {
>             for (int j = 1; j * j <= i; ++j) {
>                 dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
>             }
>         }
>         return dp[n];
>     }
> }
> ```
>
> 关键要想到 f的函数递推式    ==f[i] = f[i - j*j] + 1;==



### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

> 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>
> 你可以认为每种硬币的数量是无限的。
>
>  
>
> **示例 1：**
>
> ```
> 输入：coins = [1, 2, 5], amount = 11
> 输出：3 
> 解释：11 = 5 + 5 + 1
> ```
>
> **示例 2：**
>
> ```
> 输入：coins = [2], amount = 3
> 输出：-1
> ```
>
> **示例 3：**
>
> ```
> 输入：coins = [1], amount = 0
> 输出：0
> ```

```c
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        int p[amount+1];
        memset(p,0x3f,sizeof p);
         for(int j=0;j<n;j++)
        {
            if(coins[j]<=amount) p[coins[j]]=1;
        }
        for(int i=1;i<=amount;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(i - coins[j]>=0&&p[i - coins[j]]<=1e5)  p[i] =min(p[i], p[i - coins[j]] +1);
            }
        }
        if(amount==0) return 0;
        if(p[amount]>=1e4+10) return -1;
        return p[amount];
    }
};
```

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

> 给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。
>
> **注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
>
>  
>
> **示例 1：**
>
> ```
> 输入: s = "leetcode", wordDict = ["leet", "code"]
> 输出: true
> 解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
> ```
>
> **示例 2：**
>
> ```
> 输入: s = "applepenapple", wordDict = ["apple", "pen"]
> 输出: true
> 解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
>      注意，你可以重复使用字典中的单词。
> ```
>
> **示例 3：**
>
> ```
> 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
> 输出: false
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 300`
> - `1 <= wordDict.length <= 1000`
> - `1 <= wordDict[i].length <= 20`
> - `s` 和 `wordDict[i]` 仅由小写英文字母组成
> - `wordDict` 中的所有字符串 **互不相同**

```c
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size();
        bool f[n+1];
        memset(f,0,sizeof f);
        f[0] = true;
        for(int i =1;i<=n;i++)
        {
            for(int j =0;j<wordDict.size();j++)
            {
                int l= i - wordDict[j].size();
                if(l>=0)cout << i  << l << s.substr(l,wordDict[j].size())<<endl;
                if(l>=0&&f[l] == true&&s.substr(l,wordDict[j].size())== wordDict[j])
                {   
                    f[i] = true;
                    //cout << i <<endl;
                    break;
                } 
            }
            
        }
        return f[s.size()];
    }
};
```

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

> 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。
>
> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的
>
> 子序列
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1,0,3,2,3]
> 输出：4
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 2500`
> - `-104 <= nums[i] <= 104`



### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

> 给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续
>
> 子数组
>
> （该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
>
> 
>
> 测试用例的答案是一个 **32-位** 整数。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [2,3,-2,4]
> 输出: 6
> 解释: 子数组 [2,3] 有最大乘积 6。
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [-2,0,-1]
> 输出: 0
> 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
> ```
>
>  
>
> **提示:**
>
> - `1 <= nums.length <= 2 * 104`
> - `-10 <= nums[i] <= 10`
> - `nums` 的任何前缀或后缀的乘积都 **保证** 是一个 **32-位** 整数

```c
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int mi[n],mx[n];
        mi[0] = nums[0];
        mx[0] = nums[0];
        int res=-999999;
        res = max(res,mx[0]);
        for(int i =1;i<n;i++)
        {
            mx[i] = max(mx[i-1]*nums[i],max(mi[i-1]*nums[i],nums[i]));
            mi[i] = min(mi[i-1]*nums[i],min(mx[i-1]*nums[i],nums[i]));
            res = max(res,mx[i]);
        }
        return res;
    }
};
```

### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)==01背包==

> 给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,5,11,5]
> 输出：true
> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,3,5]
> 输出：false
> 解释：数组不能分割成两个元素和相等的子集。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 200`
> - `1 <= nums[i] <= 100`

```c
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n =  nums.size();
        int target = accumulate(nums.begin(), nums.end(), 0);
        if(target%2==1) return false;
        else target/= 2;
        bool dp[target+1];
        memset(dp,0,sizeof dp);
        dp[0] = true;
        for(int i=0;i<n;i++)
        {
            for(int j=target;j>=nums[i];--j)
            {
                dp[j] |= dp[j- nums[i]];
            }
        }
        return dp[target];
    }
};
```

```c
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;

        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int> dp(10001, 0);
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        // 也可以使用库函数一步求和
        // int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 == 1) return false;
        int target = sum / 2;

        // 开始 01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        // 集合中的元素正好可以凑成总和target
        if (dp[target] == target) return true;
        return false;
    }
};]
    
    
    //代码随想录
```

```
for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历

但是如果是可以多个重复的放应该就是从前往后遍历
```

### 最长有效括号==难==

> 给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号
>
> 子串
>
> 的长度。
>
> 
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "(()"
> 输出：2
> 解释：最长有效括号子串是 "()"
> ```
>
> **示例 2：**
>
> ```
> 输入：s = ")()())"
> 输出：4
> 解释：最长有效括号子串是 "()()"
> ```
>
> **示例 3：**
>
> ```
> 输入：s = ""
> 输出：0
> ```
>
>  
>
> **提示：**
>
> - `0 <= s.length <= 3 * 104`
> - `s[i]` 为 `'('` 或 `')'`

```c
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if(n==0) return 0;
        int dp[n],res=0;
        memset(dp,0,sizeof dp);
        stack<pair<char,int>> st;
        for(int i=0;i<n;i++)
        {
            if(st.empty()||s[i]=='(') st.push({s[i],i});
            else{
                if(s[i]==')'&&st.top().first=='(')
                {
                    dp[i]=dp[max(0,st.top().second-1)] + (i-st.top().second+1);
                    res = max(res, dp[i]);
                    st.pop();
                }
            }
            //cout << dp[i] << endl;
        }
        return res;
    }
};

//)（（）（））（（）））（）（）（（（）
//栈+dp
```



## 多维动态规划

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

> 一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
> 问总共有多少条不同的路径？
>
>  
>
> **示例 1：**
>
> ![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)
>
> ```
> 输入：m = 3, n = 7
> 输出：28
> ```
>
> **示例 2：**
>
> ```
> 输入：m = 3, n = 2
> 输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下
> ```

```c
class Solution {
public:

    int uniquePaths(int m, int n) {
        int p[m][n];
        memset(p,0,sizeof p);
        p[0][0] = 1;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(i>0) p[i][j]+= p[i-1][j];
                if(j>0) p[i][j]+= p[i][j-1];
            
            }
        }
        return p[m-1][n-1];

    }
};
```

### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

> 给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
> **说明：**每次只能向下或者向右移动一步。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)
>
> ```
> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
> 输出：7
> 解释：因为路径 1→3→1→1→1 的总和最小。
> ```
>
> **示例 2：**
>
> ```
> 输入：grid = [[1,2,3],[4,5,6]]
> 输出：12
> ```

```c
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int N=grid.size(),M=grid[0].size();
        int sum[N][M];
        memset(sum,0x3f,sizeof sum);
        sum[0][0] = grid[0][0];
        for(int i=0;i<N;i++)
        {
            for(int j=0;j<M;j++)
            {
                if(i-1>=0) sum[i][j] =min(sum[i][j],sum[i-1][j]+grid[i][j]);
                if(j-1>=0) sum[i][j] =min(sum[i][j],sum[i][j-1]+grid[i][j]);
                //cout << i <<j << sum[i][j] <<endl;
            }
        }
        return sum[N-1][M-1];

    }
};
```

### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)==难==

> 给你一个字符串 `s`，找到 `s` 中最长的回文
>
> 子串
>
> 。
>
> 
>
> 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "cbbd"
> 输出："bb"
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s` 仅由数字和英文字母组成

```c
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        vector<vector<int>> dp(n, vector<int>(n));
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= n; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < n; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= n) {
                    break;
                }

                if (s[i] != s[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
};
```

最长公共子序列

中等



编辑距离

中等

## 技巧

### [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

> 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
>
>  
>
> **示例 1 ：**
>
> ```
> 输入：nums = [2,2,1]
> 输出：1
> ```
>
> **示例 2 ：**
>
> ```
> 输入：nums = [4,1,2,1,2]
> 输出：4
> ```
>
> **示例 3 ：**
>
> ```
> 输入：nums = [1]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 3 * 104`
> - `-3 * 104 <= nums[i] <= 3 * 104`
> - 除了某个元素只出现一次以外，其余每个元素均出现两次。

```c
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res=0;
        for(auto x: nums) res^=x;
        return res;

    }
};
```

### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

> 给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [3,2,3]
> 输出：3
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,2,1,1,1,2,2]
> 输出：2
> ```
>
>  
>
> **提示：**
>
> - `n == nums.length`
> - `1 <= n <= 5 * 104`
> - `-109 <= nums[i] <= 109`

```c
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        return nums[nums.size()/2];
    }
};
```

### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

> 给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。
>
> 
>
> 必须在不使用库内置的 sort 函数的情况下解决这个问题。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,0,2,1,1,0]
> 输出：[0,0,1,1,2,2]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,0,1]
> 输出：[0,1,2]
> ```

```c
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int cnt [3];
        memset(cnt,0,sizeof cnt);
        for(int i=0;i<nums.size();i++)
        {
            cnt[nums[i]]++;
        }
        int idx =0;
        for(int i =0;i<3;i++)
        {
            int n = cnt[i];
            while(n--)
            {
                nums[idx++] = i;
            }
        }
        return;
    }
};
```

```c
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int ptr = 0;
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 0) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
        for (int i = ptr; i < n; ++i) {
            if (nums[i] == 1) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/sort-colors/solutions/437968/yan-se-fen-lei-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

> 整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。
>
> - 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。
>
> 整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
>
> - 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
> - 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
> - 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。
>
> 给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。
>
> 必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[1,3,2]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,2,1]
> 输出：[1,2,3]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1,1,5]
> 输出：[1,5,1]
> ```

```c
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int last = nums.back();
        int cmp = last;
        reverse_iterator it =nums.rbegin();
        it++;
        for(it;it!=nums.rend();it++)
        {
            if(*it<cmp) break;
            cmp = *it;
        }
        cout << cmp << endl;//cmp是左侧下降的 右边那个数 it是左边那个数
        if(it==nums.rend()) reverse(nums.rbegin(),it);
        else
        {
            reverse_iterator tt = nums.rbegin();
            while(*it>=*tt) tt++;
            swap(*it,*tt);
            //reverse(nums.rbegin(),tt);//不是翻转一下而是要排序
            cout << *it << endl;
            sort(nums.rbegin(),it,greater<int>()); //这里不需要it--因为it是需要排序的最后一个的下一个
            for(auto x:nums) cout << x << endl;
        }
       
        
        return;
    }
};

//25432221
//35422221
//31222245
```



### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

难在不能修改原数组 只能空间 o1所以，不能排序和拷贝

> 给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。
>
> 假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。
>
> 你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,3,4,2,2]
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,1,3,4,2]
> 输出：3
> ```
>
> **示例 3 :**
>
> ```
> 输入：nums = [3,3,3,3,3]
> 输出：3
> ```

1. 复杂度n2超时

```c
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int res=0;
        for(int i=0;i<nums.size();i++)
        {
            for(int j=i+1;j<nums.size();j++)
            {
                if(nums[i]==nums[j]) return nums[i];
            } 
        } 
        return -1;
    }
};
```

2. 二分 nlogn

![image-20240402205619774](/home/wangkai/codenotes_ubuntu/Leecode/img/image-20240402205619774.png)

3. 最可能得应该是位运算

`n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 所以其实==注意是n+1个数字==

重复一次也就是有两个target   就是多一个数字

重复两次以上  其实就是把另一个数字给替换成了target

![image-20240402210807328](/home/wangkai/codenotes_ubuntu/Leecode/img/image-20240402210807328.png)