## 数组和字符串

### [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

> 给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。
>
> 
>
> **说明：**
>
> 为什么返回数值是整数，但输出的答案是数组呢？
>
> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
>
> 你可以想象内部操作如下:
>
> ```
> 1
> // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
> 2
> int len = removeDuplicates(nums);
> 3
> ​
> 4
> // 在函数里修改输入数组对于调用者是可见的。
> 5
> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
> 6
> for (int i = 0; i < len; i++) {
> 7
>  print(nums[i]);
> 8
> }
> ```
>
> 
>
> **示例 1：**
>
> ```
> 1
> 输入：nums = [1,1,1,2,2,3]
> 2
> 输出：5, nums = [1,1,2,2,3]
> 3
> 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
> ```
>
> **示例 2：**
>
> ```
> 1
> 输入：nums = [0,0,1,1,1,1,2,3,3]
> 2
> 输出：7, nums = [0,0,1,1,2,3,3]
> 3
> 解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
> ```

慢指针和快指针

```
1
class Solution {
2
public:
3
    int removeDuplicates(vector<int>& nums) {
4
        //双指针
5
        int l =0,i =0,cnt=0;
6
        int last = 1e5;
7
        for(i;i<nums.size();i++)
8
        {
9
            if(nums[i]==last) 
10
            {
11
                if(cnt<2) nums[l++]= nums[i];
12
                cnt++;
13
                
14
            }
15
            else
16
            {
17
                last = nums[i];
18
                nums[l++]= nums[i];
19
                cnt =1;
20
            }
21
        }
22
        int dis = i-l;
23
        while(dis--)
24
        {
25
            nums.pop_back();
26
        }
27
        return l;
28
    }
29
};
30
​
```



### [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

> 实现`RandomizedSet` 类：
>
> - `RandomizedSet()` 初始化 `RandomizedSet` 对象
> - `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
> - `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。
> - `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。
>
> 你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。
>
> 
>
> **示例：**
>
> ```
> 输入
> ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
> [[], [1], [2], [2], [], [1], [2], []]
> 输出
> [null, true, false, true, 2, true, false, 2]
> 
> 解释
> RandomizedSet randomizedSet = new RandomizedSet();
> randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。
> randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。
> randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
> randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。
> randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
> randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。
> randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
> ```

```c
class RandomizedSet {
public:
    vector<int> nums;
    unordered_map<int, int> indices;

    RandomizedSet() {

    }
    
    bool insert(int val) {
        if (indices.count(val)) {
            return false;
        }
        int idx = nums.size();
        indices[val] = idx;
        nums.push_back(val);
        return true;
    }
    
    bool remove(int val) {
        if (!indices.count(val)) {
            return false;
        }
        int idx = indices[val];
        int last = nums.back();
        nums[idx] = last;
        indices[last] = idx;
        nums.pop_back();
        indices.erase(val);
        return true;

    }
    
    int getRandom() {
        int randomIndex = rand()%nums.size();
        return nums[randomIndex];
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```



### [134. 加油站](https://leetcode.cn/problems/gas-station/)

一句话概括：如果x到达不了y+1，那么x-y之间的点也不可能到达y+1，因为中间任何一点的油都是拥有前面的余量的，所以下次遍历直接从y+1开始

> 在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。
>
> 你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。
>
> 
>
> **示例 1:**
>
> ```
> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> 输出: 3
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。
> ```
>
> **示例 2:**
>
> ```
> 输入: gas = [2,3,4], cost = [3,4,3]
> 输出: -1
> 解释:
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。
> ```

```c
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int i = 0;
        while (i < n) {
            int sumOfGas = 0, sumOfCost = 0;
            int cnt = 0;
            while (cnt < n) {
                int j = (i + cnt) % n;
                sumOfGas += gas[j];
                sumOfCost += cost[j];
                if (sumOfCost > sumOfGas) {
                    break;
                }
                cnt++;
            }
            if (cnt == n) {
                return i;
            } else {
                i = i + cnt + 1;
            }
        }
        return -1;
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/gas-station/solutions/488357/jia-you-zhan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# 新特性

### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

> 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[3.00000,14.50000,11.00000]
> 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
> 因此返回 [3, 14.5, 11] 。
> ```

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ret;
        if (!root) return {};
        queue q{deque{root}};
        while(!empty(q)) {
            int sz = size(q);
            double sum = 0;
            for (int i = 0; i != sz; ++i) {
                TreeNode* t=q.front();
                auto [val, left, right] = *t;
                q.pop();
                sum += val;
                if (left)  q.push( left);
                if (right) q.push(right);
            }
            ret.push_back(sum / sz);
        }
        return ret;
    }
};
```



> 
>
> [![img](https://assets.leetcode.cn/aliyun-lc-upload/users/cool_learner/avatar_1584006146.png)](https://leetcode.cn/u/shira_yuki/)
>
> [shira_yuki](https://leetcode.cn/u/shira_yuki/)
>
> 发布于 辽宁
>
> 2020.09.12
>
> C++简洁代码
>
> ```cpp
> class Solution {
> public:
>  vector<double> averageOfLevels(TreeNode* root) {
>      vector<double> ret;
>      if (!root) return {};
>      queue q{deque{root}};
>      while(!empty(q)) {
>          int sz = size(q);
>          double sum = 0;
>          for (int i = 0; i != sz; ++i) {
>              auto [val, left, right] = *q.front();
>              q.pop();
>              sum += val;
>              if (left)  q.push( left);
>              if (right) q.push(right);
>          }
>          ret.push_back(sum / sz);
>      }
>      return ret;
>  }
> };
> ```
>
> [BAKEZQ❄️](https://leetcode.cn/u/bakezq/)
>
> 发布于 湖北
>
> 2020.09.12
>
> [@shira_yuki](https://leetcode.cn/u/shira_yuki) 你这个deque为啥能被解包啊
>
> 
>
> [dylanethan](https://leetcode.cn/u/dylanethan/)
>
> 发布于 上海
>
> 2020.09.12
>
> [@shira_yuki](https://leetcode.cn/u/shira_yuki) c++ 新标准的牛逼写法，大兄弟掌握的炉火纯青啊， queue q{deque{root}}; 和 auto [val, left, right] = *q.front(); 都是怎么操作的啊。 我写个 queue<TreeNode*> que{root} 都没这种构造方法。。。
>
> 
>
> 发布于 辽宁
>
> 2020.09.12
>
> [@dylanethan](https://leetcode-cn.com/u/dylanethan/)
> queue是容器适配器，必须从底层容器构造 `queue<TreeNode*> q {deque<TreeNode*>{root}}`是用deque做底层的queue适配器 c++17支持类模板参数推导。在可以推导成功的前提下，可以省略模板参数，模板参数自动推导成root的类型 也可以不用deque做底层容器写list也可以 *用于存储元素的底层容器。容器必须满足序列容器 (SequenceContainer) 的要求。另外，它必须提供带通常语义的下列函数：* *back() front() push_back() pop_front()* 顺带一提stack也是类似这样的容器 `auto [val,left,right]`可以从简单的类中按照声明顺序取出所有元素。`*q.front()`是对`TreeNode*`的解引用。

### [1235. 规划兼职工作](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/)

> 你打算利用空闲时间来做兼职工作赚些零花钱。
>
> 这里有 `n` 份兼职工作，每份工作预计从 `startTime[i]` 开始到 `endTime[i]` 结束，报酬为 `profit[i]`。
>
> 给你一份兼职工作表，包含开始时间 `startTime`，结束时间 `endTime` 和预计报酬 `profit` 三个数组，请你计算并返回可以获得的最大报酬。
>
> 注意，时间上出现重叠的 2 份工作不能同时进行。
>
> 如果你选择的工作在时间 `X` 结束，那么你可以立刻进行在时间 `X` 开始的下一份工作。
>
>  
>
> **示例 1：**
>
> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample1_1584.png)**
>
> ```
> 输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
> 输出：120
> 解释：
> 我们选出第 1 份和第 4 份工作， 
> 时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。
> ```
>
> **示例 2：**
>
> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample22_1584.png)**
>
> ```
> 输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
> 输出：150
> 解释：
> 我们选择第 1，4，5 份工作。 
> 共获得报酬 150 = 20 + 70 + 60。
> ```

#### 优先队列解

```c
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        typedef pair<int,int> PII;
        priority_queue<PII,vector<PII>,greater<PII>> q;
        int n = startTime.size(),earn[2][int(1e9)], pre = 0;
        vector<array<int, 3>> jobs(n);
        for (int i = 0; i < n; i++) {
            jobs[i] = {endTime[i], startTime[i], profit[i]};
        }
        ranges::sort(jobs, [](auto &a, auto &b) { return a[1] < b[1]; }); 
        q.push({jobs[0][0],jobs[0][2]});
        for(int i =1;i<n;i++)
        {
            int ed=jobs[i][0],st=jobs[i][1],pf=jobs[i][2];
            while(!q.empty()&&q.top().first<=st)
            {
                pre = max(pre,q.top().second);
                q.pop();
            }
            q.push({ed,pre+pf});
            //cout << i <<  ed << pre+pf <<endl;
        }
        int res = 0;
        while(!q.empty())
        {
            res = max(res,q.top().second);
            q.pop();
            //cout << res <<endl;
        }
        return res;
    }
};

//1-3 20  2-5 20  
```

#### [==upper_bound==](https://blog.csdn.net/weixin_43967256/article/details/127462617)解

```c
class Solution {
public:
    int jobScheduling(vector<int> &startTime, vector<int> &endTime, vector<int> &profit) {
        int n = startTime.size();
        vector<array<int, 3>> jobs(n);
        for (int i = 0; i < n; i++) {
            jobs[i] = {endTime[i], startTime[i], profit[i]};
        }
        ranges::sort(jobs, [](auto &a, auto &b) { return a[0] < b[0]; }); // 按照结束时间排序

        vector<int> f(n + 1);
        for (int i = 0; i < n; i++) {
            int j = upper_bound(jobs.begin(), jobs.begin() + i, array<int, 3>{jobs[i][1], INT_MAX}) - jobs.begin();
            // 状态转移中，为什么是 j 不是 j+1：上面算的是 > 开始时间，-1 后得到 <= 开始时间，但由于还要 +1，抵消了
            f[i + 1] = max(f[i], f[j] + jobs[i][2]);
        }
        return f[n];
    }
};

//优先队列，要获得小于start的end的利润的最大值需要pop进行遍历，但是pop的数据还有用，没想到存一个preprofit //第二遍   vector，从头遍历,但是 pushb_back结束时间没法排序，应该先对结束时间排序的
//第一要想到按结尾时间排序
//按j动态规划
//按二分找到哪个j的结束时间在左侧
//upper_bound语法
//array
```

array是因为有内置比较函数
