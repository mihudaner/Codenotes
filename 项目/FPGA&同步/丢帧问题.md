# 丢帧问题原因排查

# 硬件触发

## 现象说明

> USB相机在接入超过4个后会出现随机丢帧的现象，
>
> 并且4个鱼眼的丢帧是==同时发生==的
>
> 左右RGB的丢帧大多数也是==同时发生丢帧==的



## 排除触发盒造成

方法：不用触发盒产生的信号来触发采集，而是固定帧率自动触发采集图像

> 触发帧率：
>
> RGB触发信号         30HZ
>
> 鱼眼相机触发信号   20HZ
>

> 固定帧率采集图像：
>
> RGB触发信号         20HZ
>
> 鱼眼相机触发信号   20HZ

<img src="E:\codenotes\FPGA&同步\img\image-20231124120431878.png" alt="image-20231124120431878" style="zoom:200%;" />

==不用触发盒产生的信号来触发采集，而是相机默认频率采集也会丢帧，所以可以确定不是触发电路丢失触发信号造成丢帧==



## 排除相机本身造成

方法：现象不一致。丢帧时候是4个鱼眼同时丢帧所以肯定不是相机硬件过热等因素丢帧

所以一定是主机不稳定的问题

# PC方面

## 排除CPU占用影响

<img src="E:\codenotes\FPGA&同步\img\image-20231116064723935.png" alt="image-20231116064723935" style="zoom:50%;" />

只运行两个RGB，时间戳1700052007开始录到1700052665一共658秒，没有丢帧



<img src="E:\codenotes\FPGA&同步\img\image-20231116064730831.png" alt="image-20231116064730831" style="zoom: 50%;" />

再开两个鱼眼 。鱼眼从时间戳1700052665开始录，到1700052951大概5分钟就丢了一帧

RGB一共开启十几分钟一帧没丢，==而且CPU是活跃的==（但是没有看到CPU占用高和低有明显的区别）。

<img src="E:\codenotes\FPGA&同步\img\image-20231116065111244.png" alt="image-20231116065111244" style="zoom:50%;" />

2个RGB，4个鱼眼一共6个相机全部开启，==一直陆陆续续丢帧，而此时cpu空闲==

> 对比说明：只插2-4个USB相机即使CPU占用率很高丢帧也没有很明显
>
> 插满6个USB，即使CPU空闲丢帧也要更明显
>
> ==CPU占用率和丢帧现象没有很明显的相关性==

## 排除写磁盘速度

- 长时间录包，结束录包会==一段时间处于rosbag.activate，数据是存在内存，缓存，内存交换空间里的==


- 并且没有录包就没有大量的磁盘读写也就不会丢帧才对，但是不录包只是发布节点还是丢帧了

- 只插2个USB相机解包大量读写磁盘也不会丢帧




![image-20231116071131807](E:\codenotes\FPGA&同步\img\image-20231116071131807.png)

磁盘来不及写数据，Memory满后Swap交换空间再开始增加

> 主要是因为长时间录包，磁盘来不及写数据，数据是存在内存，缓存，内存交换空间里的
>
> 磁盘写速度不够理论上也不会造成现在的丢帧现象



## 队列大小问题

[ROS队列丢弃机制](https://blog.csdn.net/qq_40851744/article/details/107600389)

[函数说明](https://zhuanlan.zhihu.com/p/624606278?utm_id=0)

![image-20231116065855473](E:\codenotes\FPGA&同步\img\image-20231116065855473.png)

> Publisher内部有一个publisher message queue (以下简称PMQ)，每调用一次`publish()`都会往 PMQ 当中放入一个消息。同时存在一个线程publisher thread 从PMQ当中取出message并真正发布。
>
> 这里我们叫publish()的循环频率为 **期望发布频率**，publisher thread处理的频率为 **实际发布频率**。
>
> 一般而言，publisher thread的处理频率要比我们调用`publish()`的频率高，所以表现出来发布消息的频率就是我们`publish()`的循环速率，但是如果`publish()`的循环频率过高，以至于超过了publisher thread处理的速度（或者说publisher thread处理的速度低于`publish()`的速度）消息就会在PMQ中积累，超过了queue_size的话旧的消息便会丢失。

排除方式：==把读数据和格式转换换成其他消耗资源和延时接近的函数，发现不会丢帧，说明不是ros的机制对节点发布进行抛弃==，而是从USB读buffer的时候数据就丢失或者覆盖了



## 综合下来

使用大量的传感器，这些传感器的数据量非常庞大。节点之间通信是一帧一帧进行的，大量数据在目前ROS的通讯架构里面会带来比较高的资源消耗。并且开启录包时候消耗进一步加大，造成主机性能不稳定，造成丢帧。

大量对比实验发现不是某一个硬件资源性能不足。因为通过控制变量进行对比实验控制CPU占用,磁盘读写，USB读写在空闲状态运行，也会发生丢帧，只是数量少了：在录包和开启大量算法的情况下就是容易造成丢帧，



